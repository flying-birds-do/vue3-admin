import {
  __commonJS,
  __toESM
} from "./chunk-AC2VUBZ6.js";

// node_modules/.pnpm/global@4.3.2/node_modules/global/window.js
var require_window = __commonJS({
  "node_modules/.pnpm/global@4.3.2/node_modules/global/window.js"(exports, module) {
    var win;
    if (typeof window !== "undefined") {
      win = window;
    } else if (typeof global !== "undefined") {
      win = global;
    } else if (typeof self !== "undefined") {
      win = self;
    } else {
      win = {};
    }
    module.exports = win;
  }
});

// browser-external:min-document
var require_min_document = __commonJS({
  "browser-external:min-document"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "min-document" has been externalized for browser compatibility. Cannot access "min-document.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/global@4.3.2/node_modules/global/document.js
var require_document = __commonJS({
  "node_modules/.pnpm/global@4.3.2/node_modules/global/document.js"(exports, module) {
    var topLevel = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : {};
    var minDoc = require_min_document();
    var doccy;
    if (typeof document !== "undefined") {
      doccy = document;
    } else {
      doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
      if (!doccy) {
        doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
      }
    }
    module.exports = doccy;
  }
});

// node_modules/.pnpm/tsml@1.0.1/node_modules/tsml/tsml.js
var require_tsml = __commonJS({
  "node_modules/.pnpm/tsml@1.0.1/node_modules/tsml/tsml.js"(exports, module) {
    function clean(s) {
      return s.replace(/\n\r?\s*/g, "");
    }
    module.exports = function tsml(sa) {
      var s = "", i = 0;
      for (; i < arguments.length; i++)
        s += clean(sa[i]) + (arguments[i + 1] || "");
      return s;
    };
  }
});

// node_modules/.pnpm/safe-json-parse@4.0.0/node_modules/safe-json-parse/tuple.js
var require_tuple = __commonJS({
  "node_modules/.pnpm/safe-json-parse@4.0.0/node_modules/safe-json-parse/tuple.js"(exports, module) {
    module.exports = SafeParseTuple;
    function SafeParseTuple(obj, reviver) {
      var json;
      var error = null;
      try {
        json = JSON.parse(obj, reviver);
      } catch (err) {
        error = err;
      }
      return [error, json];
    }
  }
});

// node_modules/.pnpm/is-function@1.0.2/node_modules/is-function/index.js
var require_is_function = __commonJS({
  "node_modules/.pnpm/is-function@1.0.2/node_modules/is-function/index.js"(exports, module) {
    module.exports = isFunction;
    var toString = Object.prototype.toString;
    function isFunction(fn) {
      if (!fn) {
        return false;
      }
      var string = toString.call(fn);
      return string === "[object Function]" || typeof fn === "function" && string !== "[object RegExp]" || typeof window !== "undefined" && // IE8 and below
      (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
    }
  }
});

// node_modules/.pnpm/parse-headers@2.0.5/node_modules/parse-headers/parse-headers.js
var require_parse_headers = __commonJS({
  "node_modules/.pnpm/parse-headers@2.0.5/node_modules/parse-headers/parse-headers.js"(exports, module) {
    var trim = function(string) {
      return string.replace(/^\s+|\s+$/g, "");
    };
    var isArray = function(arg) {
      return Object.prototype.toString.call(arg) === "[object Array]";
    };
    module.exports = function(headers) {
      if (!headers)
        return {};
      var result = {};
      var headersArr = trim(headers).split("\n");
      for (var i = 0; i < headersArr.length; i++) {
        var row = headersArr[i];
        var index = row.indexOf(":"), key = trim(row.slice(0, index)).toLowerCase(), value = trim(row.slice(index + 1));
        if (typeof result[key] === "undefined") {
          result[key] = value;
        } else if (isArray(result[key])) {
          result[key].push(value);
        } else {
          result[key] = [result[key], value];
        }
      }
      return result;
    };
  }
});

// node_modules/.pnpm/xtend@4.0.2/node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/.pnpm/xtend@4.0.2/node_modules/xtend/immutable.js"(exports, module) {
    module.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/.pnpm/xhr@2.4.0/node_modules/xhr/index.js
var require_xhr = __commonJS({
  "node_modules/.pnpm/xhr@2.4.0/node_modules/xhr/index.js"(exports, module) {
    "use strict";
    var window2 = require_window();
    var isFunction = require_is_function();
    var parseHeaders = require_parse_headers();
    var xtend = require_immutable();
    module.exports = createXHR;
    createXHR.XMLHttpRequest = window2.XMLHttpRequest || noop;
    createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window2.XDomainRequest;
    forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
      createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback);
        options.method = method.toUpperCase();
        return _createXHR(options);
      };
    });
    function forEachArray(array, iterator) {
      for (var i = 0; i < array.length; i++) {
        iterator(array[i]);
      }
    }
    function isEmpty(obj) {
      for (var i in obj) {
        if (obj.hasOwnProperty(i))
          return false;
      }
      return true;
    }
    function initParams(uri, options, callback) {
      var params = uri;
      if (isFunction(options)) {
        callback = options;
        if (typeof uri === "string") {
          params = { uri };
        }
      } else {
        params = xtend(options, { uri });
      }
      params.callback = callback;
      return params;
    }
    function createXHR(uri, options, callback) {
      options = initParams(uri, options, callback);
      return _createXHR(options);
    }
    function _createXHR(options) {
      if (typeof options.callback === "undefined") {
        throw new Error("callback argument missing");
      }
      var called = false;
      var callback = function cbOnce(err, response, body2) {
        if (!called) {
          called = true;
          options.callback(err, response, body2);
        }
      };
      function readystatechange() {
        if (xhr.readyState === 4) {
          setTimeout(loadFunc, 0);
        }
      }
      function getBody() {
        var body2 = void 0;
        if (xhr.response) {
          body2 = xhr.response;
        } else {
          body2 = xhr.responseText || getXml(xhr);
        }
        if (isJson) {
          try {
            body2 = JSON.parse(body2);
          } catch (e) {
          }
        }
        return body2;
      }
      function errorFunc(evt) {
        clearTimeout(timeoutTimer);
        if (!(evt instanceof Error)) {
          evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"));
        }
        evt.statusCode = 0;
        return callback(evt, failureResponse);
      }
      function loadFunc() {
        if (aborted)
          return;
        var status;
        clearTimeout(timeoutTimer);
        if (options.useXDR && xhr.status === void 0) {
          status = 200;
        } else {
          status = xhr.status === 1223 ? 204 : xhr.status;
        }
        var response = failureResponse;
        var err = null;
        if (status !== 0) {
          response = {
            body: getBody(),
            statusCode: status,
            method,
            headers: {},
            url: uri,
            rawRequest: xhr
          };
          if (xhr.getAllResponseHeaders) {
            response.headers = parseHeaders(xhr.getAllResponseHeaders());
          }
        } else {
          err = new Error("Internal XMLHttpRequest Error");
        }
        return callback(err, response, response.body);
      }
      var xhr = options.xhr || null;
      if (!xhr) {
        if (options.cors || options.useXDR) {
          xhr = new createXHR.XDomainRequest();
        } else {
          xhr = new createXHR.XMLHttpRequest();
        }
      }
      var key;
      var aborted;
      var uri = xhr.url = options.uri || options.url;
      var method = xhr.method = options.method || "GET";
      var body = options.body || options.data;
      var headers = xhr.headers = options.headers || {};
      var sync = !!options.sync;
      var isJson = false;
      var timeoutTimer;
      var failureResponse = {
        body: void 0,
        headers: {},
        statusCode: 0,
        method,
        url: uri,
        rawRequest: xhr
      };
      if ("json" in options && options.json !== false) {
        isJson = true;
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json");
        if (method !== "GET" && method !== "HEAD") {
          headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json");
          body = JSON.stringify(options.json === true ? body : options.json);
        }
      }
      xhr.onreadystatechange = readystatechange;
      xhr.onload = loadFunc;
      xhr.onerror = errorFunc;
      xhr.onprogress = function() {
      };
      xhr.onabort = function() {
        aborted = true;
      };
      xhr.ontimeout = errorFunc;
      xhr.open(method, uri, !sync, options.username, options.password);
      if (!sync) {
        xhr.withCredentials = !!options.withCredentials;
      }
      if (!sync && options.timeout > 0) {
        timeoutTimer = setTimeout(function() {
          if (aborted)
            return;
          aborted = true;
          xhr.abort("timeout");
          var e = new Error("XMLHttpRequest timeout");
          e.code = "ETIMEDOUT";
          errorFunc(e);
        }, options.timeout);
      }
      if (xhr.setRequestHeader) {
        for (key in headers) {
          if (headers.hasOwnProperty(key)) {
            xhr.setRequestHeader(key, headers[key]);
          }
        }
      } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object");
      }
      if ("responseType" in options) {
        xhr.responseType = options.responseType;
      }
      if ("beforeSend" in options && typeof options.beforeSend === "function") {
        options.beforeSend(xhr);
      }
      xhr.send(body || null);
      return xhr;
    }
    function getXml(xhr) {
      if (xhr.responseType === "document") {
        return xhr.responseXML;
      }
      var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
      if (xhr.responseType === "" && !firefoxBugTakenEffect) {
        return xhr.responseXML;
      }
      return null;
    }
    function noop() {
    }
  }
});

// node_modules/.pnpm/global@4.4.0/node_modules/global/window.js
var require_window2 = __commonJS({
  "node_modules/.pnpm/global@4.4.0/node_modules/global/window.js"(exports, module) {
    var win;
    if (typeof window !== "undefined") {
      win = window;
    } else if (typeof global !== "undefined") {
      win = global;
    } else if (typeof self !== "undefined") {
      win = self;
    } else {
      win = {};
    }
    module.exports = win;
  }
});

// node_modules/.pnpm/videojs-vtt.js@0.12.6/node_modules/videojs-vtt.js/lib/vtt.js
var require_vtt = __commonJS({
  "node_modules/.pnpm/videojs-vtt.js@0.12.6/node_modules/videojs-vtt.js/lib/vtt.js"(exports, module) {
    var _objCreate = Object.create || function() {
      function F() {
      }
      return function(o) {
        if (arguments.length !== 1) {
          throw new Error("Object.create shim only accepts one parameter.");
        }
        F.prototype = o;
        return new F();
      };
    }();
    function ParsingError(errorData, message) {
      this.name = "ParsingError";
      this.code = errorData.code;
      this.message = message || errorData.message;
    }
    ParsingError.prototype = _objCreate(Error.prototype);
    ParsingError.prototype.constructor = ParsingError;
    ParsingError.Errors = {
      BadSignature: {
        code: 0,
        message: "Malformed WebVTT signature."
      },
      BadTimeStamp: {
        code: 1,
        message: "Malformed time stamp."
      }
    };
    function parseTimeStamp(input) {
      function computeSeconds(h, m2, s, f) {
        return (h | 0) * 3600 + (m2 | 0) * 60 + (s | 0) + (f | 0) / 1e3;
      }
      var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
      if (!m) {
        return null;
      }
      if (m[3]) {
        return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]);
      } else if (m[1] > 59) {
        return computeSeconds(m[1], m[2], 0, m[4]);
      } else {
        return computeSeconds(0, m[1], m[2], m[4]);
      }
    }
    function Settings() {
      this.values = _objCreate(null);
    }
    Settings.prototype = {
      // Only accept the first assignment to any key.
      set: function(k, v) {
        if (!this.get(k) && v !== "") {
          this.values[k] = v;
        }
      },
      // Return the value for a key, or a default value.
      // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
      // a number of possible default values as properties where 'defaultKey' is
      // the key of the property that will be chosen; otherwise it's assumed to be
      // a single value.
      get: function(k, dflt, defaultKey) {
        if (defaultKey) {
          return this.has(k) ? this.values[k] : dflt[defaultKey];
        }
        return this.has(k) ? this.values[k] : dflt;
      },
      // Check whether we have a value for a key.
      has: function(k) {
        return k in this.values;
      },
      // Accept a setting if its one of the given alternatives.
      alt: function(k, v, a) {
        for (var n = 0; n < a.length; ++n) {
          if (v === a[n]) {
            this.set(k, v);
            break;
          }
        }
      },
      // Accept a setting if its a valid (signed) integer.
      integer: function(k, v) {
        if (/^-?\d+$/.test(v)) {
          this.set(k, parseInt(v, 10));
        }
      },
      // Accept a setting if its a valid percentage.
      percent: function(k, v) {
        var m;
        if (m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
          v = parseFloat(v);
          if (v >= 0 && v <= 100) {
            this.set(k, v);
            return true;
          }
        }
        return false;
      }
    };
    function parseOptions(input, callback, keyValueDelim, groupDelim) {
      var groups = groupDelim ? input.split(groupDelim) : [input];
      for (var i in groups) {
        if (typeof groups[i] !== "string") {
          continue;
        }
        var kv = groups[i].split(keyValueDelim);
        if (kv.length !== 2) {
          continue;
        }
        var k = kv[0];
        var v = kv[1];
        callback(k, v);
      }
    }
    function parseCue(input, cue, regionList) {
      var oInput = input;
      function consumeTimeStamp() {
        var ts = parseTimeStamp(input);
        if (ts === null) {
          throw new ParsingError(
            ParsingError.Errors.BadTimeStamp,
            "Malformed timestamp: " + oInput
          );
        }
        input = input.replace(/^[^\sa-zA-Z-]+/, "");
        return ts;
      }
      function consumeCueSettings(input2, cue2) {
        var settings = new Settings();
        parseOptions(input2, function(k, v) {
          switch (k) {
            case "region":
              for (var i = regionList.length - 1; i >= 0; i--) {
                if (regionList[i].id === v) {
                  settings.set(k, regionList[i].region);
                  break;
                }
              }
              break;
            case "vertical":
              settings.alt(k, v, ["rl", "lr"]);
              break;
            case "line":
              var vals = v.split(","), vals0 = vals[0];
              settings.integer(k, vals0);
              settings.percent(k, vals0) ? settings.set("snapToLines", false) : null;
              settings.alt(k, vals0, ["auto"]);
              if (vals.length === 2) {
                settings.alt("lineAlign", vals[1], ["start", "middle", "end"]);
              }
              break;
            case "position":
              vals = v.split(",");
              settings.percent(k, vals[0]);
              if (vals.length === 2) {
                settings.alt("positionAlign", vals[1], ["start", "middle", "end"]);
              }
              break;
            case "size":
              settings.percent(k, v);
              break;
            case "align":
              settings.alt(k, v, ["start", "middle", "end", "left", "right"]);
              break;
          }
        }, /:/, /\s/);
        cue2.region = settings.get("region", null);
        cue2.vertical = settings.get("vertical", "");
        cue2.line = settings.get("line", "auto");
        cue2.lineAlign = settings.get("lineAlign", "start");
        cue2.snapToLines = settings.get("snapToLines", true);
        cue2.size = settings.get("size", 100);
        cue2.align = settings.get("align", "middle");
        cue2.position = settings.get("position", {
          start: 0,
          left: 0,
          middle: 50,
          end: 100,
          right: 100
        }, cue2.align);
        cue2.positionAlign = settings.get("positionAlign", {
          start: "start",
          left: "start",
          middle: "middle",
          end: "end",
          right: "end"
        }, cue2.align);
      }
      function skipWhitespace() {
        input = input.replace(/^\s+/, "");
      }
      skipWhitespace();
      cue.startTime = consumeTimeStamp();
      skipWhitespace();
      if (input.substr(0, 3) !== "-->") {
        throw new ParsingError(
          ParsingError.Errors.BadTimeStamp,
          "Malformed time stamp (time stamps must be separated by '-->'): " + oInput
        );
      }
      input = input.substr(3);
      skipWhitespace();
      cue.endTime = consumeTimeStamp();
      skipWhitespace();
      consumeCueSettings(input, cue);
    }
    var ESCAPE = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&lrm;": "‎",
      "&rlm;": "‏",
      "&nbsp;": " "
    };
    var TAG_NAME = {
      c: "span",
      i: "i",
      b: "b",
      u: "u",
      ruby: "ruby",
      rt: "rt",
      v: "span",
      lang: "span"
    };
    var TAG_ANNOTATION = {
      v: "title",
      lang: "lang"
    };
    var NEEDS_PARENT = {
      rt: "ruby"
    };
    function parseContent(window2, input) {
      function nextToken() {
        if (!input) {
          return null;
        }
        function consume(result) {
          input = input.substr(result.length);
          return result;
        }
        var m2 = input.match(/^([^<]*)(<[^>]*>?)?/);
        return consume(m2[1] ? m2[1] : m2[2]);
      }
      function unescape1(e) {
        return ESCAPE[e];
      }
      function unescape(s) {
        while (m = s.match(/&(amp|lt|gt|lrm|rlm|nbsp);/)) {
          s = s.replace(m[0], unescape1);
        }
        return s;
      }
      function shouldAdd(current2, element) {
        return !NEEDS_PARENT[element.localName] || NEEDS_PARENT[element.localName] === current2.localName;
      }
      function createElement(type, annotation) {
        var tagName = TAG_NAME[type];
        if (!tagName) {
          return null;
        }
        var element = window2.document.createElement(tagName);
        element.localName = tagName;
        var name = TAG_ANNOTATION[type];
        if (name && annotation) {
          element[name] = annotation.trim();
        }
        return element;
      }
      var rootDiv = window2.document.createElement("div"), current = rootDiv, t, tagStack = [];
      while ((t = nextToken()) !== null) {
        if (t[0] === "<") {
          if (t[1] === "/") {
            if (tagStack.length && tagStack[tagStack.length - 1] === t.substr(2).replace(">", "")) {
              tagStack.pop();
              current = current.parentNode;
            }
            continue;
          }
          var ts = parseTimeStamp(t.substr(1, t.length - 2));
          var node;
          if (ts) {
            node = window2.document.createProcessingInstruction("timestamp", ts);
            current.appendChild(node);
            continue;
          }
          var m = t.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
          if (!m) {
            continue;
          }
          node = createElement(m[1], m[3]);
          if (!node) {
            continue;
          }
          if (!shouldAdd(current, node)) {
            continue;
          }
          if (m[2]) {
            node.className = m[2].substr(1).replace(".", " ");
          }
          tagStack.push(m[1]);
          current.appendChild(node);
          current = node;
          continue;
        }
        current.appendChild(window2.document.createTextNode(unescape(t)));
      }
      return rootDiv;
    }
    var strongRTLRanges = [
      [1470, 1470],
      [1472, 1472],
      [1475, 1475],
      [1478, 1478],
      [1488, 1514],
      [1520, 1524],
      [1544, 1544],
      [1547, 1547],
      [1549, 1549],
      [1563, 1563],
      [1566, 1610],
      [1645, 1647],
      [1649, 1749],
      [1765, 1766],
      [1774, 1775],
      [1786, 1805],
      [1807, 1808],
      [1810, 1839],
      [1869, 1957],
      [1969, 1969],
      [1984, 2026],
      [2036, 2037],
      [2042, 2042],
      [2048, 2069],
      [2074, 2074],
      [2084, 2084],
      [2088, 2088],
      [2096, 2110],
      [2112, 2136],
      [2142, 2142],
      [2208, 2208],
      [2210, 2220],
      [8207, 8207],
      [64285, 64285],
      [64287, 64296],
      [64298, 64310],
      [64312, 64316],
      [64318, 64318],
      [64320, 64321],
      [64323, 64324],
      [64326, 64449],
      [64467, 64829],
      [64848, 64911],
      [64914, 64967],
      [65008, 65020],
      [65136, 65140],
      [65142, 65276],
      [67584, 67589],
      [67592, 67592],
      [67594, 67637],
      [67639, 67640],
      [67644, 67644],
      [67647, 67669],
      [67671, 67679],
      [67840, 67867],
      [67872, 67897],
      [67903, 67903],
      [67968, 68023],
      [68030, 68031],
      [68096, 68096],
      [68112, 68115],
      [68117, 68119],
      [68121, 68147],
      [68160, 68167],
      [68176, 68184],
      [68192, 68223],
      [68352, 68405],
      [68416, 68437],
      [68440, 68466],
      [68472, 68479],
      [68608, 68680],
      [126464, 126467],
      [126469, 126495],
      [126497, 126498],
      [126500, 126500],
      [126503, 126503],
      [126505, 126514],
      [126516, 126519],
      [126521, 126521],
      [126523, 126523],
      [126530, 126530],
      [126535, 126535],
      [126537, 126537],
      [126539, 126539],
      [126541, 126543],
      [126545, 126546],
      [126548, 126548],
      [126551, 126551],
      [126553, 126553],
      [126555, 126555],
      [126557, 126557],
      [126559, 126559],
      [126561, 126562],
      [126564, 126564],
      [126567, 126570],
      [126572, 126578],
      [126580, 126583],
      [126585, 126588],
      [126590, 126590],
      [126592, 126601],
      [126603, 126619],
      [126625, 126627],
      [126629, 126633],
      [126635, 126651],
      [1114109, 1114109]
    ];
    function isStrongRTLChar(charCode) {
      for (var i = 0; i < strongRTLRanges.length; i++) {
        var currentRange = strongRTLRanges[i];
        if (charCode >= currentRange[0] && charCode <= currentRange[1]) {
          return true;
        }
      }
      return false;
    }
    function determineBidi(cueDiv) {
      var nodeStack = [], text = "", charCode;
      if (!cueDiv || !cueDiv.childNodes) {
        return "ltr";
      }
      function pushNodes(nodeStack2, node) {
        for (var i2 = node.childNodes.length - 1; i2 >= 0; i2--) {
          nodeStack2.push(node.childNodes[i2]);
        }
      }
      function nextTextNode(nodeStack2) {
        if (!nodeStack2 || !nodeStack2.length) {
          return null;
        }
        var node = nodeStack2.pop(), text2 = node.textContent || node.innerText;
        if (text2) {
          var m = text2.match(/^.*(\n|\r)/);
          if (m) {
            nodeStack2.length = 0;
            return m[0];
          }
          return text2;
        }
        if (node.tagName === "ruby") {
          return nextTextNode(nodeStack2);
        }
        if (node.childNodes) {
          pushNodes(nodeStack2, node);
          return nextTextNode(nodeStack2);
        }
      }
      pushNodes(nodeStack, cueDiv);
      while (text = nextTextNode(nodeStack)) {
        for (var i = 0; i < text.length; i++) {
          charCode = text.charCodeAt(i);
          if (isStrongRTLChar(charCode)) {
            return "rtl";
          }
        }
      }
      return "ltr";
    }
    function computeLinePos(cue) {
      if (typeof cue.line === "number" && (cue.snapToLines || cue.line >= 0 && cue.line <= 100)) {
        return cue.line;
      }
      if (!cue.track || !cue.track.textTrackList || !cue.track.textTrackList.mediaElement) {
        return -1;
      }
      var track = cue.track, trackList = track.textTrackList, count = 0;
      for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {
        if (trackList[i].mode === "showing") {
          count++;
        }
      }
      return ++count * -1;
    }
    function StyleBox() {
    }
    StyleBox.prototype.applyStyles = function(styles, div) {
      div = div || this.div;
      for (var prop in styles) {
        if (styles.hasOwnProperty(prop)) {
          div.style[prop] = styles[prop];
        }
      }
    };
    StyleBox.prototype.formatStyle = function(val, unit) {
      return val === 0 ? 0 : val + unit;
    };
    function CueStyleBox(window2, cue, styleOptions) {
      var isIE8 = /MSIE\s8\.0/.test(navigator.userAgent);
      var color = "rgba(255, 255, 255, 1)";
      var backgroundColor = "rgba(0, 0, 0, 0.8)";
      if (isIE8) {
        color = "rgb(255, 255, 255)";
        backgroundColor = "rgb(0, 0, 0)";
      }
      StyleBox.call(this);
      this.cue = cue;
      this.cueDiv = parseContent(window2, cue.text);
      var styles = {
        color,
        backgroundColor,
        position: "relative",
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        display: "inline"
      };
      if (!isIE8) {
        styles.writingMode = cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl";
        styles.unicodeBidi = "plaintext";
      }
      this.applyStyles(styles, this.cueDiv);
      this.div = window2.document.createElement("div");
      styles = {
        textAlign: cue.align === "middle" ? "center" : cue.align,
        font: styleOptions.font,
        whiteSpace: "pre-line",
        position: "absolute"
      };
      if (!isIE8) {
        styles.direction = determineBidi(this.cueDiv);
        styles.writingMode = cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl".stylesunicodeBidi = "plaintext";
      }
      this.applyStyles(styles);
      this.div.appendChild(this.cueDiv);
      var textPos = 0;
      switch (cue.positionAlign) {
        case "start":
          textPos = cue.position;
          break;
        case "middle":
          textPos = cue.position - cue.size / 2;
          break;
        case "end":
          textPos = cue.position - cue.size;
          break;
      }
      if (cue.vertical === "") {
        this.applyStyles({
          left: this.formatStyle(textPos, "%"),
          width: this.formatStyle(cue.size, "%")
        });
      } else {
        this.applyStyles({
          top: this.formatStyle(textPos, "%"),
          height: this.formatStyle(cue.size, "%")
        });
      }
      this.move = function(box) {
        this.applyStyles({
          top: this.formatStyle(box.top, "px"),
          bottom: this.formatStyle(box.bottom, "px"),
          left: this.formatStyle(box.left, "px"),
          right: this.formatStyle(box.right, "px"),
          height: this.formatStyle(box.height, "px"),
          width: this.formatStyle(box.width, "px")
        });
      };
    }
    CueStyleBox.prototype = _objCreate(StyleBox.prototype);
    CueStyleBox.prototype.constructor = CueStyleBox;
    function BoxPosition(obj) {
      var isIE8 = /MSIE\s8\.0/.test(navigator.userAgent);
      var lh, height, width, top;
      if (obj.div) {
        height = obj.div.offsetHeight;
        width = obj.div.offsetWidth;
        top = obj.div.offsetTop;
        var rects = (rects = obj.div.childNodes) && (rects = rects[0]) && rects.getClientRects && rects.getClientRects();
        obj = obj.div.getBoundingClientRect();
        lh = rects ? Math.max(rects[0] && rects[0].height || 0, obj.height / rects.length) : 0;
      }
      this.left = obj.left;
      this.right = obj.right;
      this.top = obj.top || top;
      this.height = obj.height || height;
      this.bottom = obj.bottom || top + (obj.height || height);
      this.width = obj.width || width;
      this.lineHeight = lh !== void 0 ? lh : obj.lineHeight;
      if (isIE8 && !this.lineHeight) {
        this.lineHeight = 13;
      }
    }
    BoxPosition.prototype.move = function(axis, toMove) {
      toMove = toMove !== void 0 ? toMove : this.lineHeight;
      switch (axis) {
        case "+x":
          this.left += toMove;
          this.right += toMove;
          break;
        case "-x":
          this.left -= toMove;
          this.right -= toMove;
          break;
        case "+y":
          this.top += toMove;
          this.bottom += toMove;
          break;
        case "-y":
          this.top -= toMove;
          this.bottom -= toMove;
          break;
      }
    };
    BoxPosition.prototype.overlaps = function(b2) {
      return this.left < b2.right && this.right > b2.left && this.top < b2.bottom && this.bottom > b2.top;
    };
    BoxPosition.prototype.overlapsAny = function(boxes) {
      for (var i = 0; i < boxes.length; i++) {
        if (this.overlaps(boxes[i])) {
          return true;
        }
      }
      return false;
    };
    BoxPosition.prototype.within = function(container) {
      return this.top >= container.top && this.bottom <= container.bottom && this.left >= container.left && this.right <= container.right;
    };
    BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {
      switch (axis) {
        case "+x":
          return this.left < container.left;
        case "-x":
          return this.right > container.right;
        case "+y":
          return this.top < container.top;
        case "-y":
          return this.bottom > container.bottom;
      }
    };
    BoxPosition.prototype.intersectPercentage = function(b2) {
      var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)), y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)), intersectArea = x * y;
      return intersectArea / (this.height * this.width);
    };
    BoxPosition.prototype.toCSSCompatValues = function(reference) {
      return {
        top: this.top - reference.top,
        bottom: reference.bottom - this.bottom,
        left: this.left - reference.left,
        right: reference.right - this.right,
        height: this.height,
        width: this.width
      };
    };
    BoxPosition.getSimpleBoxPosition = function(obj) {
      var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
      var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
      var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;
      obj = obj.div ? obj.div.getBoundingClientRect() : obj.tagName ? obj.getBoundingClientRect() : obj;
      var ret = {
        left: obj.left,
        right: obj.right,
        top: obj.top || top,
        height: obj.height || height,
        bottom: obj.bottom || top + (obj.height || height),
        width: obj.width || width
      };
      return ret;
    };
    function moveBoxToLinePosition(window2, styleBox, containerBox, boxPositions) {
      function findBestPosition(b, axis2) {
        var bestPosition2, specifiedPosition = new BoxPosition(b), percentage = 1;
        for (var i = 0; i < axis2.length; i++) {
          while (b.overlapsOppositeAxis(containerBox, axis2[i]) || b.within(containerBox) && b.overlapsAny(boxPositions)) {
            b.move(axis2[i]);
          }
          if (b.within(containerBox)) {
            return b;
          }
          var p = b.intersectPercentage(containerBox);
          if (percentage > p) {
            bestPosition2 = new BoxPosition(b);
            percentage = p;
          }
          b = new BoxPosition(specifiedPosition);
        }
        return bestPosition2 || specifiedPosition;
      }
      var boxPosition = new BoxPosition(styleBox), cue = styleBox.cue, linePos = computeLinePos(cue), axis = [];
      if (cue.snapToLines) {
        var size;
        switch (cue.vertical) {
          case "":
            axis = ["+y", "-y"];
            size = "height";
            break;
          case "rl":
            axis = ["+x", "-x"];
            size = "width";
            break;
          case "lr":
            axis = ["-x", "+x"];
            size = "width";
            break;
        }
        var step = boxPosition.lineHeight, position = step * Math.round(linePos), maxPosition = containerBox[size] + step, initialAxis = axis[0];
        if (Math.abs(position) > maxPosition) {
          position = position < 0 ? -1 : 1;
          position *= Math.ceil(maxPosition / step) * step;
        }
        if (linePos < 0) {
          position += cue.vertical === "" ? containerBox.height : containerBox.width;
          axis = axis.reverse();
        }
        boxPosition.move(initialAxis, position);
      } else {
        var calculatedPercentage = boxPosition.lineHeight / containerBox.height * 100;
        switch (cue.lineAlign) {
          case "middle":
            linePos -= calculatedPercentage / 2;
            break;
          case "end":
            linePos -= calculatedPercentage;
            break;
        }
        switch (cue.vertical) {
          case "":
            styleBox.applyStyles({
              top: styleBox.formatStyle(linePos, "%")
            });
            break;
          case "rl":
            styleBox.applyStyles({
              left: styleBox.formatStyle(linePos, "%")
            });
            break;
          case "lr":
            styleBox.applyStyles({
              right: styleBox.formatStyle(linePos, "%")
            });
            break;
        }
        axis = ["+y", "-x", "+x", "-y"];
        boxPosition = new BoxPosition(styleBox);
      }
      var bestPosition = findBestPosition(boxPosition, axis);
      styleBox.move(bestPosition.toCSSCompatValues(containerBox));
    }
    function WebVTT2() {
    }
    WebVTT2.StringDecoder = function() {
      return {
        decode: function(data) {
          if (!data) {
            return "";
          }
          if (typeof data !== "string") {
            throw new Error("Error - expected string data.");
          }
          return decodeURIComponent(encodeURIComponent(data));
        }
      };
    };
    WebVTT2.convertCueToDOMTree = function(window2, cuetext) {
      if (!window2 || !cuetext) {
        return null;
      }
      return parseContent(window2, cuetext);
    };
    var FONT_SIZE_PERCENT = 0.05;
    var FONT_STYLE = "sans-serif";
    var CUE_BACKGROUND_PADDING = "1.5%";
    WebVTT2.processCues = function(window2, cues, overlay) {
      if (!window2 || !cues || !overlay) {
        return null;
      }
      while (overlay.firstChild) {
        overlay.removeChild(overlay.firstChild);
      }
      var paddedOverlay = window2.document.createElement("div");
      paddedOverlay.style.position = "absolute";
      paddedOverlay.style.left = "0";
      paddedOverlay.style.right = "0";
      paddedOverlay.style.top = "0";
      paddedOverlay.style.bottom = "0";
      paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
      overlay.appendChild(paddedOverlay);
      function shouldCompute(cues2) {
        for (var i2 = 0; i2 < cues2.length; i2++) {
          if (cues2[i2].hasBeenReset || !cues2[i2].displayState) {
            return true;
          }
        }
        return false;
      }
      if (!shouldCompute(cues)) {
        for (var i = 0; i < cues.length; i++) {
          paddedOverlay.appendChild(cues[i].displayState);
        }
        return;
      }
      var boxPositions = [], containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay), fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
      var styleOptions = {
        font: fontSize + "px " + FONT_STYLE
      };
      (function() {
        var styleBox, cue;
        for (var i2 = 0; i2 < cues.length; i2++) {
          cue = cues[i2];
          styleBox = new CueStyleBox(window2, cue, styleOptions);
          paddedOverlay.appendChild(styleBox.div);
          moveBoxToLinePosition(window2, styleBox, containerBox, boxPositions);
          cue.displayState = styleBox.div;
          boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
        }
      })();
    };
    WebVTT2.Parser = function(window2, vttjs, decoder) {
      if (!decoder) {
        decoder = vttjs;
        vttjs = {};
      }
      if (!vttjs) {
        vttjs = {};
      }
      this.window = window2;
      this.vttjs = vttjs;
      this.state = "INITIAL";
      this.buffer = "";
      this.decoder = decoder || new TextDecoder("utf8");
      this.regionList = [];
    };
    WebVTT2.Parser.prototype = {
      // If the error is a ParsingError then report it to the consumer if
      // possible. If it's not a ParsingError then throw it like normal.
      reportOrThrowError: function(e) {
        if (e instanceof ParsingError) {
          this.onparsingerror && this.onparsingerror(e);
        } else {
          throw e;
        }
      },
      parse: function(data) {
        var self2 = this;
        if (data) {
          self2.buffer += self2.decoder.decode(data, { stream: true });
        }
        function collectNextLine() {
          var buffer = self2.buffer;
          var pos = 0;
          while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== "\n") {
            ++pos;
          }
          var line2 = buffer.substr(0, pos);
          if (buffer[pos] === "\r") {
            ++pos;
          }
          if (buffer[pos] === "\n") {
            ++pos;
          }
          self2.buffer = buffer.substr(pos);
          return line2;
        }
        function parseRegion(input) {
          var settings = new Settings();
          parseOptions(input, function(k, v) {
            switch (k) {
              case "id":
                settings.set(k, v);
                break;
              case "width":
                settings.percent(k, v);
                break;
              case "lines":
                settings.integer(k, v);
                break;
              case "regionanchor":
              case "viewportanchor":
                var xy = v.split(",");
                if (xy.length !== 2) {
                  break;
                }
                var anchor = new Settings();
                anchor.percent("x", xy[0]);
                anchor.percent("y", xy[1]);
                if (!anchor.has("x") || !anchor.has("y")) {
                  break;
                }
                settings.set(k + "X", anchor.get("x"));
                settings.set(k + "Y", anchor.get("y"));
                break;
              case "scroll":
                settings.alt(k, v, ["up"]);
                break;
            }
          }, /=/, /\s/);
          if (settings.has("id")) {
            var region = new (self2.vttjs.VTTRegion || self2.window.VTTRegion)();
            region.width = settings.get("width", 100);
            region.lines = settings.get("lines", 3);
            region.regionAnchorX = settings.get("regionanchorX", 0);
            region.regionAnchorY = settings.get("regionanchorY", 100);
            region.viewportAnchorX = settings.get("viewportanchorX", 0);
            region.viewportAnchorY = settings.get("viewportanchorY", 100);
            region.scroll = settings.get("scroll", "");
            self2.onregion && self2.onregion(region);
            self2.regionList.push({
              id: settings.get("id"),
              region
            });
          }
        }
        function parseTimestampMap(input) {
          var settings = new Settings();
          parseOptions(input, function(k, v) {
            switch (k) {
              case "MPEGT":
                settings.integer(k + "S", v);
                break;
              case "LOCA":
                settings.set(k + "L", parseTimeStamp(v));
                break;
            }
          }, /[^\d]:/, /,/);
          self2.ontimestampmap && self2.ontimestampmap({
            "MPEGTS": settings.get("MPEGTS"),
            "LOCAL": settings.get("LOCAL")
          });
        }
        function parseHeader(input) {
          if (input.match(/X-TIMESTAMP-MAP/)) {
            parseOptions(input, function(k, v) {
              switch (k) {
                case "X-TIMESTAMP-MAP":
                  parseTimestampMap(v);
                  break;
              }
            }, /=/);
          } else {
            parseOptions(input, function(k, v) {
              switch (k) {
                case "Region":
                  parseRegion(v);
                  break;
              }
            }, /:/);
          }
        }
        try {
          var line;
          if (self2.state === "INITIAL") {
            if (!/\r\n|\n/.test(self2.buffer)) {
              return this;
            }
            line = collectNextLine();
            var m = line.match(/^WEBVTT([ \t].*)?$/);
            if (!m || !m[0]) {
              throw new ParsingError(ParsingError.Errors.BadSignature);
            }
            self2.state = "HEADER";
          }
          var alreadyCollectedLine = false;
          while (self2.buffer) {
            if (!/\r\n|\n/.test(self2.buffer)) {
              return this;
            }
            if (!alreadyCollectedLine) {
              line = collectNextLine();
            } else {
              alreadyCollectedLine = false;
            }
            switch (self2.state) {
              case "HEADER":
                if (/:/.test(line)) {
                  parseHeader(line);
                } else if (!line) {
                  self2.state = "ID";
                }
                continue;
              case "NOTE":
                if (!line) {
                  self2.state = "ID";
                }
                continue;
              case "ID":
                if (/^NOTE($|[ \t])/.test(line)) {
                  self2.state = "NOTE";
                  break;
                }
                if (!line) {
                  continue;
                }
                self2.cue = new (self2.vttjs.VTTCue || self2.window.VTTCue)(0, 0, "");
                self2.state = "CUE";
                if (line.indexOf("-->") === -1) {
                  self2.cue.id = line;
                  continue;
                }
              case "CUE":
                try {
                  parseCue(line, self2.cue, self2.regionList);
                } catch (e) {
                  self2.reportOrThrowError(e);
                  self2.cue = null;
                  self2.state = "BADCUE";
                  continue;
                }
                self2.state = "CUETEXT";
                continue;
              case "CUETEXT":
                var hasSubstring = line.indexOf("-->") !== -1;
                if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                  self2.oncue && self2.oncue(self2.cue);
                  self2.cue = null;
                  self2.state = "ID";
                  continue;
                }
                if (self2.cue.text) {
                  self2.cue.text += "\n";
                }
                self2.cue.text += line;
                continue;
              case "BADCUE":
                if (!line) {
                  self2.state = "ID";
                }
                continue;
            }
          }
        } catch (e) {
          self2.reportOrThrowError(e);
          if (self2.state === "CUETEXT" && self2.cue && self2.oncue) {
            self2.oncue(self2.cue);
          }
          self2.cue = null;
          self2.state = self2.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
        }
        return this;
      },
      flush: function() {
        var self2 = this;
        try {
          self2.buffer += self2.decoder.decode();
          if (self2.cue || self2.state === "HEADER") {
            self2.buffer += "\n\n";
            self2.parse();
          }
          if (self2.state === "INITIAL") {
            throw new ParsingError(ParsingError.Errors.BadSignature);
          }
        } catch (e) {
          self2.reportOrThrowError(e);
        }
        self2.onflush && self2.onflush();
        return this;
      }
    };
    module.exports = WebVTT2;
  }
});

// node_modules/.pnpm/videojs-vtt.js@0.12.6/node_modules/videojs-vtt.js/lib/vttcue.js
var require_vttcue = __commonJS({
  "node_modules/.pnpm/videojs-vtt.js@0.12.6/node_modules/videojs-vtt.js/lib/vttcue.js"(exports, module) {
    var autoKeyword = "auto";
    var directionSetting = {
      "": true,
      "lr": true,
      "rl": true
    };
    var alignSetting = {
      "start": true,
      "middle": true,
      "end": true,
      "left": true,
      "right": true
    };
    function findDirectionSetting(value) {
      if (typeof value !== "string") {
        return false;
      }
      var dir = directionSetting[value.toLowerCase()];
      return dir ? value.toLowerCase() : false;
    }
    function findAlignSetting(value) {
      if (typeof value !== "string") {
        return false;
      }
      var align = alignSetting[value.toLowerCase()];
      return align ? value.toLowerCase() : false;
    }
    function extend(obj) {
      var i = 1;
      for (; i < arguments.length; i++) {
        var cobj = arguments[i];
        for (var p in cobj) {
          obj[p] = cobj[p];
        }
      }
      return obj;
    }
    function VTTCue(startTime, endTime, text) {
      var cue = this;
      var isIE8 = /MSIE\s8\.0/.test(navigator.userAgent);
      var baseObj = {};
      if (isIE8) {
        cue = document.createElement("custom");
      } else {
        baseObj.enumerable = true;
      }
      cue.hasBeenReset = false;
      var _id = "";
      var _pauseOnExit = false;
      var _startTime = startTime;
      var _endTime = endTime;
      var _text = text;
      var _region = null;
      var _vertical = "";
      var _snapToLines = true;
      var _line = "auto";
      var _lineAlign = "start";
      var _position = 50;
      var _positionAlign = "middle";
      var _size = 50;
      var _align = "middle";
      Object.defineProperty(
        cue,
        "id",
        extend({}, baseObj, {
          get: function() {
            return _id;
          },
          set: function(value) {
            _id = "" + value;
          }
        })
      );
      Object.defineProperty(
        cue,
        "pauseOnExit",
        extend({}, baseObj, {
          get: function() {
            return _pauseOnExit;
          },
          set: function(value) {
            _pauseOnExit = !!value;
          }
        })
      );
      Object.defineProperty(
        cue,
        "startTime",
        extend({}, baseObj, {
          get: function() {
            return _startTime;
          },
          set: function(value) {
            if (typeof value !== "number") {
              throw new TypeError("Start time must be set to a number.");
            }
            _startTime = value;
            this.hasBeenReset = true;
          }
        })
      );
      Object.defineProperty(
        cue,
        "endTime",
        extend({}, baseObj, {
          get: function() {
            return _endTime;
          },
          set: function(value) {
            if (typeof value !== "number") {
              throw new TypeError("End time must be set to a number.");
            }
            _endTime = value;
            this.hasBeenReset = true;
          }
        })
      );
      Object.defineProperty(
        cue,
        "text",
        extend({}, baseObj, {
          get: function() {
            return _text;
          },
          set: function(value) {
            _text = "" + value;
            this.hasBeenReset = true;
          }
        })
      );
      Object.defineProperty(
        cue,
        "region",
        extend({}, baseObj, {
          get: function() {
            return _region;
          },
          set: function(value) {
            _region = value;
            this.hasBeenReset = true;
          }
        })
      );
      Object.defineProperty(
        cue,
        "vertical",
        extend({}, baseObj, {
          get: function() {
            return _vertical;
          },
          set: function(value) {
            var setting = findDirectionSetting(value);
            if (setting === false) {
              throw new SyntaxError("An invalid or illegal string was specified.");
            }
            _vertical = setting;
            this.hasBeenReset = true;
          }
        })
      );
      Object.defineProperty(
        cue,
        "snapToLines",
        extend({}, baseObj, {
          get: function() {
            return _snapToLines;
          },
          set: function(value) {
            _snapToLines = !!value;
            this.hasBeenReset = true;
          }
        })
      );
      Object.defineProperty(
        cue,
        "line",
        extend({}, baseObj, {
          get: function() {
            return _line;
          },
          set: function(value) {
            if (typeof value !== "number" && value !== autoKeyword) {
              throw new SyntaxError("An invalid number or illegal string was specified.");
            }
            _line = value;
            this.hasBeenReset = true;
          }
        })
      );
      Object.defineProperty(
        cue,
        "lineAlign",
        extend({}, baseObj, {
          get: function() {
            return _lineAlign;
          },
          set: function(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              throw new SyntaxError("An invalid or illegal string was specified.");
            }
            _lineAlign = setting;
            this.hasBeenReset = true;
          }
        })
      );
      Object.defineProperty(
        cue,
        "position",
        extend({}, baseObj, {
          get: function() {
            return _position;
          },
          set: function(value) {
            if (value < 0 || value > 100) {
              throw new Error("Position must be between 0 and 100.");
            }
            _position = value;
            this.hasBeenReset = true;
          }
        })
      );
      Object.defineProperty(
        cue,
        "positionAlign",
        extend({}, baseObj, {
          get: function() {
            return _positionAlign;
          },
          set: function(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              throw new SyntaxError("An invalid or illegal string was specified.");
            }
            _positionAlign = setting;
            this.hasBeenReset = true;
          }
        })
      );
      Object.defineProperty(
        cue,
        "size",
        extend({}, baseObj, {
          get: function() {
            return _size;
          },
          set: function(value) {
            if (value < 0 || value > 100) {
              throw new Error("Size must be between 0 and 100.");
            }
            _size = value;
            this.hasBeenReset = true;
          }
        })
      );
      Object.defineProperty(
        cue,
        "align",
        extend({}, baseObj, {
          get: function() {
            return _align;
          },
          set: function(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              throw new SyntaxError("An invalid or illegal string was specified.");
            }
            _align = setting;
            this.hasBeenReset = true;
          }
        })
      );
      cue.displayState = void 0;
      if (isIE8) {
        return cue;
      }
    }
    VTTCue.prototype.getCueAsHTML = function() {
      return WebVTT.convertCueToDOMTree(window, this.text);
    };
    module.exports = VTTCue;
  }
});

// node_modules/.pnpm/videojs-vtt.js@0.12.6/node_modules/videojs-vtt.js/lib/vttregion.js
var require_vttregion = __commonJS({
  "node_modules/.pnpm/videojs-vtt.js@0.12.6/node_modules/videojs-vtt.js/lib/vttregion.js"(exports, module) {
    var scrollSetting = {
      "": true,
      "up": true
    };
    function findScrollSetting(value) {
      if (typeof value !== "string") {
        return false;
      }
      var scroll = scrollSetting[value.toLowerCase()];
      return scroll ? value.toLowerCase() : false;
    }
    function isValidPercentValue(value) {
      return typeof value === "number" && (value >= 0 && value <= 100);
    }
    function VTTRegion() {
      var _width = 100;
      var _lines = 3;
      var _regionAnchorX = 0;
      var _regionAnchorY = 100;
      var _viewportAnchorX = 0;
      var _viewportAnchorY = 100;
      var _scroll = "";
      Object.defineProperties(this, {
        "width": {
          enumerable: true,
          get: function() {
            return _width;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("Width must be between 0 and 100.");
            }
            _width = value;
          }
        },
        "lines": {
          enumerable: true,
          get: function() {
            return _lines;
          },
          set: function(value) {
            if (typeof value !== "number") {
              throw new TypeError("Lines must be set to a number.");
            }
            _lines = value;
          }
        },
        "regionAnchorY": {
          enumerable: true,
          get: function() {
            return _regionAnchorY;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("RegionAnchorX must be between 0 and 100.");
            }
            _regionAnchorY = value;
          }
        },
        "regionAnchorX": {
          enumerable: true,
          get: function() {
            return _regionAnchorX;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("RegionAnchorY must be between 0 and 100.");
            }
            _regionAnchorX = value;
          }
        },
        "viewportAnchorY": {
          enumerable: true,
          get: function() {
            return _viewportAnchorY;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("ViewportAnchorY must be between 0 and 100.");
            }
            _viewportAnchorY = value;
          }
        },
        "viewportAnchorX": {
          enumerable: true,
          get: function() {
            return _viewportAnchorX;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("ViewportAnchorX must be between 0 and 100.");
            }
            _viewportAnchorX = value;
          }
        },
        "scroll": {
          enumerable: true,
          get: function() {
            return _scroll;
          },
          set: function(value) {
            var setting = findScrollSetting(value);
            if (setting === false) {
              throw new SyntaxError("An invalid or illegal string was specified.");
            }
            _scroll = setting;
          }
        }
      });
    }
    module.exports = VTTRegion;
  }
});

// node_modules/.pnpm/videojs-vtt.js@0.12.6/node_modules/videojs-vtt.js/lib/browser-index.js
var require_browser_index = __commonJS({
  "node_modules/.pnpm/videojs-vtt.js@0.12.6/node_modules/videojs-vtt.js/lib/browser-index.js"(exports, module) {
    var window2 = require_window2();
    var vttjs = module.exports = {
      WebVTT: require_vtt(),
      VTTCue: require_vttcue(),
      VTTRegion: require_vttregion()
    };
    window2.vttjs = vttjs;
    window2.WebVTT = vttjs.WebVTT;
    var cueShim = vttjs.VTTCue;
    var regionShim = vttjs.VTTRegion;
    var nativeVTTCue = window2.VTTCue;
    var nativeVTTRegion = window2.VTTRegion;
    vttjs.shim = function() {
      window2.VTTCue = cueShim;
      window2.VTTRegion = regionShim;
    };
    vttjs.restore = function() {
      window2.VTTCue = nativeVTTCue;
      window2.VTTRegion = nativeVTTRegion;
    };
    if (!window2.VTTCue) {
      vttjs.shim();
    }
  }
});

// node_modules/.pnpm/video.js@6.13.0/node_modules/video.js/dist/video.cjs.js
var require_video_cjs = __commonJS({
  "node_modules/.pnpm/video.js@6.13.0/node_modules/video.js/dist/video.cjs.js"(exports, module) {
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var window2 = _interopDefault(require_window());
    var document2 = _interopDefault(require_document());
    var tsml = _interopDefault(require_tsml());
    var safeParseTuple = _interopDefault(require_tuple());
    var xhr = _interopDefault(require_xhr());
    var vtt = _interopDefault(require_browser_index());
    var version = "6.13.0";
    var USER_AGENT = window2.navigator && window2.navigator.userAgent || "";
    var webkitVersionMap = /AppleWebKit\/([\d.]+)/i.exec(USER_AGENT);
    var appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;
    var IS_IPAD = /iPad/i.test(USER_AGENT);
    var IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
    var IS_IPOD = /iPod/i.test(USER_AGENT);
    var IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;
    var IOS_VERSION = function() {
      var match = USER_AGENT.match(/OS (\d+)_/i);
      if (match && match[1]) {
        return match[1];
      }
      return null;
    }();
    var IS_ANDROID = /Android/i.test(USER_AGENT);
    var ANDROID_VERSION = function() {
      var match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
      if (!match) {
        return null;
      }
      var major = match[1] && parseFloat(match[1]);
      var minor = match[2] && parseFloat(match[2]);
      if (major && minor) {
        return parseFloat(match[1] + "." + match[2]);
      } else if (major) {
        return major;
      }
      return null;
    }();
    var IS_OLD_ANDROID = IS_ANDROID && /webkit/i.test(USER_AGENT) && ANDROID_VERSION < 2.3;
    var IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;
    var IS_FIREFOX = /Firefox/i.test(USER_AGENT);
    var IS_EDGE = /Edge/i.test(USER_AGENT);
    var IS_CHROME = !IS_EDGE && (/Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT));
    var CHROME_VERSION = function() {
      var match = USER_AGENT.match(/(Chrome|CriOS)\/(\d+)/);
      if (match && match[2]) {
        return parseFloat(match[2]);
      }
      return null;
    }();
    var IS_IE8 = /MSIE\s8\.0/.test(USER_AGENT);
    var IE_VERSION = function() {
      var result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
      var version2 = result && parseFloat(result[1]);
      if (!version2 && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
        version2 = 11;
      }
      return version2;
    }();
    var IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;
    var IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;
    var TOUCH_ENABLED = isReal() && ("ontouchstart" in window2 || window2.navigator.maxTouchPoints || window2.DocumentTouch && window2.document instanceof window2.DocumentTouch);
    var BACKGROUND_SIZE_SUPPORTED = isReal() && "backgroundSize" in window2.document.createElement("video").style;
    var browser = (Object.freeze || Object)({
      IS_IPAD,
      IS_IPHONE,
      IS_IPOD,
      IS_IOS,
      IOS_VERSION,
      IS_ANDROID,
      ANDROID_VERSION,
      IS_OLD_ANDROID,
      IS_NATIVE_ANDROID,
      IS_FIREFOX,
      IS_EDGE,
      IS_CHROME,
      CHROME_VERSION,
      IS_IE8,
      IE_VERSION,
      IS_SAFARI,
      IS_ANY_SAFARI,
      TOUCH_ENABLED,
      BACKGROUND_SIZE_SUPPORTED
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var classCallCheck = function(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };
    var inherits = function(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    };
    var possibleConstructorReturn = function(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    };
    var taggedTemplateLiteralLoose = function(strings, raw) {
      strings.raw = raw;
      return strings;
    };
    var toString = Object.prototype.toString;
    var keys = function keys2(object) {
      return isObject(object) ? Object.keys(object) : [];
    };
    function each(object, fn) {
      keys(object).forEach(function(key) {
        return fn(object[key], key);
      });
    }
    function reduce(object, fn) {
      var initial = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      return keys(object).reduce(function(accum, key) {
        return fn(accum, object[key], key);
      }, initial);
    }
    function assign(target) {
      for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        sources[_key - 1] = arguments[_key];
      }
      if (Object.assign) {
        return Object.assign.apply(Object, [target].concat(sources));
      }
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        each(source, function(value, key) {
          target[key] = value;
        });
      });
      return target;
    }
    function isObject(value) {
      return !!value && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object";
    }
    function isPlain(value) {
      return isObject(value) && toString.call(value) === "[object Object]" && value.constructor === Object;
    }
    var history = [];
    var LogByTypeFactory = function LogByTypeFactory2(name, log2) {
      return function(type, level, args, stringify) {
        var lvl = log2.levels[level];
        var lvlRegExp = new RegExp("^(" + lvl + ")$");
        if (type !== "log") {
          args.unshift(type.toUpperCase() + ":");
        }
        args.unshift(name + ":");
        if (history) {
          history.push([].concat(args));
        }
        if (!window2.console) {
          return;
        }
        var fn = window2.console[type];
        if (!fn && type === "debug") {
          fn = window2.console.info || window2.console.log;
        }
        if (!fn || !lvl || !lvlRegExp.test(type)) {
          return;
        }
        if (stringify) {
          args = args.map(function(a) {
            if (isObject(a) || Array.isArray(a)) {
              try {
                return JSON.stringify(a);
              } catch (x) {
                return String(a);
              }
            }
            return String(a);
          }).join(" ");
        }
        if (!fn.apply) {
          fn(args);
        } else {
          fn[Array.isArray(args) ? "apply" : "call"](window2.console, args);
        }
      };
    };
    function createLogger$1(name) {
      var level = "info";
      var logByType = void 0;
      var log2 = function log3() {
        var stringify = log3.stringify || IE_VERSION && IE_VERSION < 11;
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        logByType("log", level, args, stringify);
      };
      logByType = LogByTypeFactory(name, log2);
      log2.createLogger = function(subname) {
        return createLogger$1(name + ": " + subname);
      };
      log2.levels = {
        all: "debug|log|warn|error",
        off: "",
        debug: "debug|log|warn|error",
        info: "log|warn|error",
        warn: "warn|error",
        error: "error",
        DEFAULT: level
      };
      log2.level = function(lvl) {
        if (typeof lvl === "string") {
          if (!log2.levels.hasOwnProperty(lvl)) {
            throw new Error('"' + lvl + '" in not a valid log level');
          }
          level = lvl;
        }
        return level;
      };
      log2.history = function() {
        return history ? [].concat(history) : [];
      };
      log2.history.filter = function(fname) {
        return (history || []).filter(function(historyItem) {
          return new RegExp(".*" + fname + ".*").test(historyItem[0]);
        });
      };
      log2.history.clear = function() {
        if (history) {
          history.length = 0;
        }
      };
      log2.history.disable = function() {
        if (history !== null) {
          history.length = 0;
          history = null;
        }
      };
      log2.history.enable = function() {
        if (history === null) {
          history = [];
        }
      };
      log2.error = function() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return logByType("error", level, args);
      };
      log2.warn = function() {
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return logByType("warn", level, args);
      };
      log2.debug = function() {
        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return logByType("debug", level, args);
      };
      return log2;
    }
    var log = createLogger$1("VIDEOJS");
    var createLogger = log.createLogger;
    function computedStyle(el, prop) {
      if (!el || !prop) {
        return "";
      }
      if (typeof window2.getComputedStyle === "function") {
        var cs = window2.getComputedStyle(el);
        return cs ? cs[prop] : "";
      }
      return el.currentStyle[prop] || "";
    }
    var _templateObject = taggedTemplateLiteralLoose(["Setting attributes in the second argument of createEl()\n                has been deprecated. Use the third argument instead.\n                createEl(type, properties, attributes). Attempting to set ", " to ", "."], ["Setting attributes in the second argument of createEl()\n                has been deprecated. Use the third argument instead.\n                createEl(type, properties, attributes). Attempting to set ", " to ", "."]);
    function isNonBlankString(str) {
      return typeof str === "string" && /\S/.test(str);
    }
    function throwIfWhitespace(str) {
      if (/\s/.test(str)) {
        throw new Error("class has illegal whitespace characters");
      }
    }
    function classRegExp(className) {
      return new RegExp("(^|\\s)" + className + "($|\\s)");
    }
    function isReal() {
      return (
        // Both document and window will never be undefined thanks to `global`.
        document2 === window2.document && // In IE < 9, DOM methods return "object" as their type, so all we can
        // confidently check is that it exists.
        typeof document2.createElement !== "undefined"
      );
    }
    function isEl(value) {
      return isObject(value) && value.nodeType === 1;
    }
    function isInFrame() {
      try {
        return window2.parent !== window2.self;
      } catch (x) {
        return true;
      }
    }
    function createQuerier(method) {
      return function(selector, context) {
        if (!isNonBlankString(selector)) {
          return document2[method](null);
        }
        if (isNonBlankString(context)) {
          context = document2.querySelector(context);
        }
        var ctx = isEl(context) ? context : document2;
        return ctx[method] && ctx[method](selector);
      };
    }
    function createEl() {
      var tagName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "div";
      var properties = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var content = arguments[3];
      var el = document2.createElement(tagName);
      Object.getOwnPropertyNames(properties).forEach(function(propName) {
        var val = properties[propName];
        if (propName.indexOf("aria-") !== -1 || propName === "role" || propName === "type") {
          log.warn(tsml(_templateObject, propName, val));
          el.setAttribute(propName, val);
        } else if (propName === "textContent") {
          textContent(el, val);
        } else {
          el[propName] = val;
        }
      });
      Object.getOwnPropertyNames(attributes).forEach(function(attrName) {
        el.setAttribute(attrName, attributes[attrName]);
      });
      if (content) {
        appendContent(el, content);
      }
      return el;
    }
    function textContent(el, text) {
      if (typeof el.textContent === "undefined") {
        el.innerText = text;
      } else {
        el.textContent = text;
      }
      return el;
    }
    function prependTo(child, parent) {
      if (parent.firstChild) {
        parent.insertBefore(child, parent.firstChild);
      } else {
        parent.appendChild(child);
      }
    }
    function hasClass(element, classToCheck) {
      throwIfWhitespace(classToCheck);
      if (element.classList) {
        return element.classList.contains(classToCheck);
      }
      return classRegExp(classToCheck).test(element.className);
    }
    function addClass(element, classToAdd) {
      if (element.classList) {
        element.classList.add(classToAdd);
      } else if (!hasClass(element, classToAdd)) {
        element.className = (element.className + " " + classToAdd).trim();
      }
      return element;
    }
    function removeClass(element, classToRemove) {
      if (element.classList) {
        element.classList.remove(classToRemove);
      } else {
        throwIfWhitespace(classToRemove);
        element.className = element.className.split(/\s+/).filter(function(c) {
          return c !== classToRemove;
        }).join(" ");
      }
      return element;
    }
    function toggleClass(element, classToToggle, predicate) {
      var has = hasClass(element, classToToggle);
      if (typeof predicate === "function") {
        predicate = predicate(element, classToToggle);
      }
      if (typeof predicate !== "boolean") {
        predicate = !has;
      }
      if (predicate === has) {
        return;
      }
      if (predicate) {
        addClass(element, classToToggle);
      } else {
        removeClass(element, classToToggle);
      }
      return element;
    }
    function setAttributes(el, attributes) {
      Object.getOwnPropertyNames(attributes).forEach(function(attrName) {
        var attrValue = attributes[attrName];
        if (attrValue === null || typeof attrValue === "undefined" || attrValue === false) {
          el.removeAttribute(attrName);
        } else {
          el.setAttribute(attrName, attrValue === true ? "" : attrValue);
        }
      });
    }
    function getAttributes(tag) {
      var obj = {};
      var knownBooleans = ",autoplay,controls,playsinline,loop,muted,default,defaultMuted,";
      if (tag && tag.attributes && tag.attributes.length > 0) {
        var attrs = tag.attributes;
        for (var i2 = attrs.length - 1; i2 >= 0; i2--) {
          var attrName = attrs[i2].name;
          var attrVal = attrs[i2].value;
          if (typeof tag[attrName] === "boolean" || knownBooleans.indexOf("," + attrName + ",") !== -1) {
            attrVal = attrVal !== null ? true : false;
          }
          obj[attrName] = attrVal;
        }
      }
      return obj;
    }
    function getAttribute(el, attribute) {
      return el.getAttribute(attribute);
    }
    function setAttribute(el, attribute, value) {
      el.setAttribute(attribute, value);
    }
    function removeAttribute(el, attribute) {
      el.removeAttribute(attribute);
    }
    function blockTextSelection() {
      document2.body.focus();
      document2.onselectstart = function() {
        return false;
      };
    }
    function unblockTextSelection() {
      document2.onselectstart = function() {
        return true;
      };
    }
    function getBoundingClientRect(el) {
      if (el && el.getBoundingClientRect && el.parentNode) {
        var rect = el.getBoundingClientRect();
        var result = {};
        ["bottom", "height", "left", "right", "top", "width"].forEach(function(k) {
          if (rect[k] !== void 0) {
            result[k] = rect[k];
          }
        });
        if (!result.height) {
          result.height = parseFloat(computedStyle(el, "height"));
        }
        if (!result.width) {
          result.width = parseFloat(computedStyle(el, "width"));
        }
        return result;
      }
    }
    function findPosition(el) {
      var box = void 0;
      if (el.getBoundingClientRect && el.parentNode) {
        box = el.getBoundingClientRect();
      }
      if (!box) {
        return {
          left: 0,
          top: 0
        };
      }
      var docEl = document2.documentElement;
      var body = document2.body;
      var clientLeft = docEl.clientLeft || body.clientLeft || 0;
      var scrollLeft = window2.pageXOffset || body.scrollLeft;
      var left = box.left + scrollLeft - clientLeft;
      var clientTop = docEl.clientTop || body.clientTop || 0;
      var scrollTop = window2.pageYOffset || body.scrollTop;
      var top = box.top + scrollTop - clientTop;
      return {
        left: Math.round(left),
        top: Math.round(top)
      };
    }
    function getPointerPosition(el, event2) {
      var position = {};
      var box = findPosition(el);
      var boxW = el.offsetWidth;
      var boxH = el.offsetHeight;
      var boxY = box.top;
      var boxX = box.left;
      var pageY = event2.pageY;
      var pageX = event2.pageX;
      if (event2.changedTouches) {
        pageX = event2.changedTouches[0].pageX;
        pageY = event2.changedTouches[0].pageY;
      }
      position.y = Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));
      position.x = Math.max(0, Math.min(1, (pageX - boxX) / boxW));
      return position;
    }
    function isTextNode(value) {
      return isObject(value) && value.nodeType === 3;
    }
    function emptyEl(el) {
      while (el.firstChild) {
        el.removeChild(el.firstChild);
      }
      return el;
    }
    function normalizeContent(content) {
      if (typeof content === "function") {
        content = content();
      }
      return (Array.isArray(content) ? content : [content]).map(function(value) {
        if (typeof value === "function") {
          value = value();
        }
        if (isEl(value) || isTextNode(value)) {
          return value;
        }
        if (typeof value === "string" && /\S/.test(value)) {
          return document2.createTextNode(value);
        }
      }).filter(function(value) {
        return value;
      });
    }
    function appendContent(el, content) {
      normalizeContent(content).forEach(function(node) {
        return el.appendChild(node);
      });
      return el;
    }
    function insertContent(el, content) {
      return appendContent(emptyEl(el), content);
    }
    function isSingleLeftClick(event2) {
      if (event2.button === void 0 && event2.buttons === void 0) {
        return true;
      }
      if (event2.button === 0 && event2.buttons === void 0) {
        return true;
      }
      if (IE_VERSION === 9) {
        return true;
      }
      if (event2.button !== 0 || event2.buttons !== 1) {
        return false;
      }
      return true;
    }
    var $ = createQuerier("querySelector");
    var $$ = createQuerier("querySelectorAll");
    var Dom = (Object.freeze || Object)({
      isReal,
      isEl,
      isInFrame,
      createEl,
      textContent,
      prependTo,
      hasClass,
      addClass,
      removeClass,
      toggleClass,
      setAttributes,
      getAttributes,
      getAttribute,
      setAttribute,
      removeAttribute,
      blockTextSelection,
      unblockTextSelection,
      getBoundingClientRect,
      findPosition,
      getPointerPosition,
      isTextNode,
      emptyEl,
      normalizeContent,
      appendContent,
      insertContent,
      isSingleLeftClick,
      $,
      $$
    });
    var _guid = 1;
    function newGUID() {
      return _guid++;
    }
    var elData = {};
    var elIdAttr = "vdata" + new Date().getTime();
    function getData(el) {
      var id = el[elIdAttr];
      if (!id) {
        id = el[elIdAttr] = newGUID();
      }
      if (!elData[id]) {
        elData[id] = {};
      }
      return elData[id];
    }
    function hasData(el) {
      var id = el[elIdAttr];
      if (!id) {
        return false;
      }
      return !!Object.getOwnPropertyNames(elData[id]).length;
    }
    function removeData(el) {
      var id = el[elIdAttr];
      if (!id) {
        return;
      }
      delete elData[id];
      try {
        delete el[elIdAttr];
      } catch (e) {
        if (el.removeAttribute) {
          el.removeAttribute(elIdAttr);
        } else {
          el[elIdAttr] = null;
        }
      }
    }
    function _cleanUpEvents(elem, type) {
      var data = getData(elem);
      if (data.handlers[type].length === 0) {
        delete data.handlers[type];
        if (elem.removeEventListener) {
          elem.removeEventListener(type, data.dispatcher, false);
        } else if (elem.detachEvent) {
          elem.detachEvent("on" + type, data.dispatcher);
        }
      }
      if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
        delete data.handlers;
        delete data.dispatcher;
        delete data.disabled;
      }
      if (Object.getOwnPropertyNames(data).length === 0) {
        removeData(elem);
      }
    }
    function _handleMultipleEvents(fn, elem, types, callback) {
      types.forEach(function(type) {
        fn(elem, type, callback);
      });
    }
    function fixEvent(event2) {
      function returnTrue() {
        return true;
      }
      function returnFalse() {
        return false;
      }
      if (!event2 || !event2.isPropagationStopped) {
        var old = event2 || window2.event;
        event2 = {};
        for (var key in old) {
          if (key !== "layerX" && key !== "layerY" && key !== "keyLocation" && key !== "webkitMovementX" && key !== "webkitMovementY") {
            if (!(key === "returnValue" && old.preventDefault)) {
              event2[key] = old[key];
            }
          }
        }
        if (!event2.target) {
          event2.target = event2.srcElement || document2;
        }
        if (!event2.relatedTarget) {
          event2.relatedTarget = event2.fromElement === event2.target ? event2.toElement : event2.fromElement;
        }
        event2.preventDefault = function() {
          if (old.preventDefault) {
            old.preventDefault();
          }
          event2.returnValue = false;
          old.returnValue = false;
          event2.defaultPrevented = true;
        };
        event2.defaultPrevented = false;
        event2.stopPropagation = function() {
          if (old.stopPropagation) {
            old.stopPropagation();
          }
          event2.cancelBubble = true;
          old.cancelBubble = true;
          event2.isPropagationStopped = returnTrue;
        };
        event2.isPropagationStopped = returnFalse;
        event2.stopImmediatePropagation = function() {
          if (old.stopImmediatePropagation) {
            old.stopImmediatePropagation();
          }
          event2.isImmediatePropagationStopped = returnTrue;
          event2.stopPropagation();
        };
        event2.isImmediatePropagationStopped = returnFalse;
        if (event2.clientX !== null && event2.clientX !== void 0) {
          var doc = document2.documentElement;
          var body = document2.body;
          event2.pageX = event2.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event2.pageY = event2.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        event2.which = event2.charCode || event2.keyCode;
        if (event2.button !== null && event2.button !== void 0) {
          event2.button = event2.button & 1 ? 0 : event2.button & 4 ? 1 : event2.button & 2 ? 2 : 0;
        }
      }
      return event2;
    }
    var _supportsPassive = false;
    (function() {
      try {
        var opts = Object.defineProperty({}, "passive", {
          get: function get() {
            _supportsPassive = true;
          }
        });
        window2.addEventListener("test", null, opts);
        window2.removeEventListener("test", null, opts);
      } catch (e) {
      }
    })();
    var passiveEvents = ["touchstart", "touchmove"];
    function on(elem, type, fn) {
      if (Array.isArray(type)) {
        return _handleMultipleEvents(on, elem, type, fn);
      }
      var data = getData(elem);
      if (!data.handlers) {
        data.handlers = {};
      }
      if (!data.handlers[type]) {
        data.handlers[type] = [];
      }
      if (!fn.guid) {
        fn.guid = newGUID();
      }
      data.handlers[type].push(fn);
      if (!data.dispatcher) {
        data.disabled = false;
        data.dispatcher = function(event2, hash) {
          if (data.disabled) {
            return;
          }
          event2 = fixEvent(event2);
          var handlers = data.handlers[event2.type];
          if (handlers) {
            var handlersCopy = handlers.slice(0);
            for (var m = 0, n = handlersCopy.length; m < n; m++) {
              if (event2.isImmediatePropagationStopped()) {
                break;
              } else {
                try {
                  handlersCopy[m].call(elem, event2, hash);
                } catch (e) {
                  log.error(e);
                }
              }
            }
          }
        };
      }
      if (data.handlers[type].length === 1) {
        if (elem.addEventListener) {
          var options = false;
          if (_supportsPassive && passiveEvents.indexOf(type) > -1) {
            options = { passive: true };
          }
          elem.addEventListener(type, data.dispatcher, options);
        } else if (elem.attachEvent) {
          elem.attachEvent("on" + type, data.dispatcher);
        }
      }
    }
    function off(elem, type, fn) {
      if (!hasData(elem)) {
        return;
      }
      var data = getData(elem);
      if (!data.handlers) {
        return;
      }
      if (Array.isArray(type)) {
        return _handleMultipleEvents(off, elem, type, fn);
      }
      var removeType = function removeType2(el, t2) {
        data.handlers[t2] = [];
        _cleanUpEvents(el, t2);
      };
      if (type === void 0) {
        for (var t in data.handlers) {
          if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) {
            removeType(elem, t);
          }
        }
        return;
      }
      var handlers = data.handlers[type];
      if (!handlers) {
        return;
      }
      if (!fn) {
        removeType(elem, type);
        return;
      }
      if (fn.guid) {
        for (var n = 0; n < handlers.length; n++) {
          if (handlers[n].guid === fn.guid) {
            handlers.splice(n--, 1);
          }
        }
      }
      _cleanUpEvents(elem, type);
    }
    function trigger(elem, event2, hash) {
      var elemData = hasData(elem) ? getData(elem) : {};
      var parent = elem.parentNode || elem.ownerDocument;
      if (typeof event2 === "string") {
        event2 = { type: event2, target: elem };
      } else if (!event2.target) {
        event2.target = elem;
      }
      event2 = fixEvent(event2);
      if (elemData.dispatcher) {
        elemData.dispatcher.call(elem, event2, hash);
      }
      if (parent && !event2.isPropagationStopped() && event2.bubbles === true) {
        trigger.call(null, parent, event2, hash);
      } else if (!parent && !event2.defaultPrevented) {
        var targetData = getData(event2.target);
        if (event2.target[event2.type]) {
          targetData.disabled = true;
          if (typeof event2.target[event2.type] === "function") {
            event2.target[event2.type]();
          }
          targetData.disabled = false;
        }
      }
      return !event2.defaultPrevented;
    }
    function one(elem, type, fn) {
      if (Array.isArray(type)) {
        return _handleMultipleEvents(one, elem, type, fn);
      }
      var func = function func2() {
        off(elem, type, func2);
        fn.apply(this, arguments);
      };
      func.guid = fn.guid = fn.guid || newGUID();
      on(elem, type, func);
    }
    var Events = (Object.freeze || Object)({
      fixEvent,
      on,
      off,
      trigger,
      one
    });
    var _windowLoaded = false;
    var videojs$2 = void 0;
    var autoSetup = function autoSetup2() {
      if (!isReal() || videojs$2.options.autoSetup === false) {
        return;
      }
      var vids = document2.getElementsByTagName("video");
      var audios = document2.getElementsByTagName("audio");
      var divs = document2.getElementsByTagName("video-js");
      var mediaEls = [];
      if (vids && vids.length > 0) {
        for (var i2 = 0, e = vids.length; i2 < e; i2++) {
          mediaEls.push(vids[i2]);
        }
      }
      if (audios && audios.length > 0) {
        for (var _i2 = 0, _e = audios.length; _i2 < _e; _i2++) {
          mediaEls.push(audios[_i2]);
        }
      }
      if (divs && divs.length > 0) {
        for (var _i22 = 0, _e2 = divs.length; _i22 < _e2; _i22++) {
          mediaEls.push(divs[_i22]);
        }
      }
      if (mediaEls && mediaEls.length > 0) {
        for (var _i3 = 0, _e3 = mediaEls.length; _i3 < _e3; _i3++) {
          var mediaEl = mediaEls[_i3];
          if (mediaEl && mediaEl.getAttribute) {
            if (mediaEl.player === void 0) {
              var options = mediaEl.getAttribute("data-setup");
              if (options !== null) {
                videojs$2(mediaEl);
              }
            }
          } else {
            autoSetupTimeout(1);
            break;
          }
        }
      } else if (!_windowLoaded) {
        autoSetupTimeout(1);
      }
    };
    function autoSetupTimeout(wait, vjs) {
      if (vjs) {
        videojs$2 = vjs;
      }
      window2.setTimeout(autoSetup, wait);
    }
    if (isReal() && document2.readyState === "complete") {
      _windowLoaded = true;
    } else {
      one(window2, "load", function() {
        _windowLoaded = true;
      });
    }
    var createStyleElement = function createStyleElement2(className) {
      var style2 = document2.createElement("style");
      style2.className = className;
      return style2;
    };
    var setTextContent = function setTextContent2(el, content) {
      if (el.styleSheet) {
        el.styleSheet.cssText = content;
      } else {
        el.textContent = content;
      }
    };
    var bind = function bind2(context, fn, uid) {
      if (!fn.guid) {
        fn.guid = newGUID();
      }
      var bound = function bound2() {
        return fn.apply(context, arguments);
      };
      bound.guid = uid ? uid + "_" + fn.guid : fn.guid;
      return bound;
    };
    var throttle = function throttle2(fn, wait) {
      var last = Date.now();
      var throttled = function throttled2() {
        var now = Date.now();
        if (now - last >= wait) {
          fn.apply(void 0, arguments);
          last = now;
        }
      };
      return throttled;
    };
    var debounce = function debounce2(func, wait, immediate) {
      var context = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : window2;
      var timeout = void 0;
      var cancel = function cancel2() {
        context.clearTimeout(timeout);
        timeout = null;
      };
      var debounced = function debounced2() {
        var self2 = this;
        var args = arguments;
        var _later = function later() {
          timeout = null;
          _later = null;
          if (!immediate) {
            func.apply(self2, args);
          }
        };
        if (!timeout && immediate) {
          func.apply(self2, args);
        }
        context.clearTimeout(timeout);
        timeout = context.setTimeout(_later, wait);
      };
      debounced.cancel = cancel;
      return debounced;
    };
    var EventTarget = function EventTarget2() {
    };
    EventTarget.prototype.allowedEvents_ = {};
    EventTarget.prototype.on = function(type, fn) {
      var ael = this.addEventListener;
      this.addEventListener = function() {
      };
      on(this, type, fn);
      this.addEventListener = ael;
    };
    EventTarget.prototype.addEventListener = EventTarget.prototype.on;
    EventTarget.prototype.off = function(type, fn) {
      off(this, type, fn);
    };
    EventTarget.prototype.removeEventListener = EventTarget.prototype.off;
    EventTarget.prototype.one = function(type, fn) {
      var ael = this.addEventListener;
      this.addEventListener = function() {
      };
      one(this, type, fn);
      this.addEventListener = ael;
    };
    EventTarget.prototype.trigger = function(event2) {
      var type = event2.type || event2;
      if (typeof event2 === "string") {
        event2 = { type };
      }
      event2 = fixEvent(event2);
      if (this.allowedEvents_[type] && this["on" + type]) {
        this["on" + type](event2);
      }
      trigger(this, event2);
    };
    EventTarget.prototype.dispatchEvent = EventTarget.prototype.trigger;
    var isEvented = function isEvented2(object) {
      return object instanceof EventTarget || !!object.eventBusEl_ && ["on", "one", "off", "trigger"].every(function(k) {
        return typeof object[k] === "function";
      });
    };
    var isValidEventType = function isValidEventType2(type) {
      return (
        // The regex here verifies that the `type` contains at least one non-
        // whitespace character.
        typeof type === "string" && /\S/.test(type) || Array.isArray(type) && !!type.length
      );
    };
    var validateTarget = function validateTarget2(target) {
      if (!target.nodeName && !isEvented(target)) {
        throw new Error("Invalid target; must be a DOM node or evented object.");
      }
    };
    var validateEventType = function validateEventType2(type) {
      if (!isValidEventType(type)) {
        throw new Error("Invalid event type; must be a non-empty string or array.");
      }
    };
    var validateListener = function validateListener2(listener) {
      if (typeof listener !== "function") {
        throw new Error("Invalid listener; must be a function.");
      }
    };
    var normalizeListenArgs = function normalizeListenArgs2(self2, args) {
      var isTargetingSelf = args.length < 3 || args[0] === self2 || args[0] === self2.eventBusEl_;
      var target = void 0;
      var type = void 0;
      var listener = void 0;
      if (isTargetingSelf) {
        target = self2.eventBusEl_;
        if (args.length >= 3) {
          args.shift();
        }
        type = args[0];
        listener = args[1];
      } else {
        target = args[0];
        type = args[1];
        listener = args[2];
      }
      validateTarget(target);
      validateEventType(type);
      validateListener(listener);
      listener = bind(self2, listener);
      return { isTargetingSelf, target, type, listener };
    };
    var listen = function listen2(target, method, type, listener) {
      validateTarget(target);
      if (target.nodeName) {
        Events[method](target, type, listener);
      } else {
        target[method](type, listener);
      }
    };
    var EventedMixin = {
      /**
       * Add a listener to an event (or events) on this object or another evented
       * object.
       *
       * @param  {string|Array|Element|Object} targetOrType
       *         If this is a string or array, it represents the event type(s)
       *         that will trigger the listener.
       *
       *         Another evented object can be passed here instead, which will
       *         cause the listener to listen for events on _that_ object.
       *
       *         In either case, the listener's `this` value will be bound to
       *         this object.
       *
       * @param  {string|Array|Function} typeOrListener
       *         If the first argument was a string or array, this should be the
       *         listener function. Otherwise, this is a string or array of event
       *         type(s).
       *
       * @param  {Function} [listener]
       *         If the first argument was another evented object, this will be
       *         the listener function.
       */
      on: function on$$1() {
        var _this = this;
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var _normalizeListenArgs = normalizeListenArgs(this, args), isTargetingSelf = _normalizeListenArgs.isTargetingSelf, target = _normalizeListenArgs.target, type = _normalizeListenArgs.type, listener = _normalizeListenArgs.listener;
        listen(target, "on", type, listener);
        if (!isTargetingSelf) {
          var removeListenerOnDispose = function removeListenerOnDispose2() {
            return _this.off(target, type, listener);
          };
          removeListenerOnDispose.guid = listener.guid;
          var removeRemoverOnTargetDispose = function removeRemoverOnTargetDispose2() {
            return _this.off("dispose", removeListenerOnDispose);
          };
          removeRemoverOnTargetDispose.guid = listener.guid;
          listen(this, "on", "dispose", removeListenerOnDispose);
          listen(target, "on", "dispose", removeRemoverOnTargetDispose);
        }
      },
      /**
       * Add a listener to an event (or events) on this object or another evented
       * object. The listener will only be called once and then removed.
       *
       * @param  {string|Array|Element|Object} targetOrType
       *         If this is a string or array, it represents the event type(s)
       *         that will trigger the listener.
       *
       *         Another evented object can be passed here instead, which will
       *         cause the listener to listen for events on _that_ object.
       *
       *         In either case, the listener's `this` value will be bound to
       *         this object.
       *
       * @param  {string|Array|Function} typeOrListener
       *         If the first argument was a string or array, this should be the
       *         listener function. Otherwise, this is a string or array of event
       *         type(s).
       *
       * @param  {Function} [listener]
       *         If the first argument was another evented object, this will be
       *         the listener function.
       */
      one: function one$$1() {
        var _this2 = this;
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        var _normalizeListenArgs2 = normalizeListenArgs(this, args), isTargetingSelf = _normalizeListenArgs2.isTargetingSelf, target = _normalizeListenArgs2.target, type = _normalizeListenArgs2.type, listener = _normalizeListenArgs2.listener;
        if (isTargetingSelf) {
          listen(target, "one", type, listener);
        } else {
          var wrapper = function wrapper2() {
            for (var _len3 = arguments.length, largs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              largs[_key3] = arguments[_key3];
            }
            _this2.off(target, type, wrapper2);
            listener.apply(null, largs);
          };
          wrapper.guid = listener.guid;
          listen(target, "one", type, wrapper);
        }
      },
      /**
       * Removes listener(s) from event(s) on an evented object.
       *
       * @param  {string|Array|Element|Object} [targetOrType]
       *         If this is a string or array, it represents the event type(s).
       *
       *         Another evented object can be passed here instead, in which case
       *         ALL 3 arguments are _required_.
       *
       * @param  {string|Array|Function} [typeOrListener]
       *         If the first argument was a string or array, this may be the
       *         listener function. Otherwise, this is a string or array of event
       *         type(s).
       *
       * @param  {Function} [listener]
       *         If the first argument was another evented object, this will be
       *         the listener function; otherwise, _all_ listeners bound to the
       *         event type(s) will be removed.
       */
      off: function off$$1(targetOrType, typeOrListener, listener) {
        if (!targetOrType || isValidEventType(targetOrType)) {
          off(this.eventBusEl_, targetOrType, typeOrListener);
        } else {
          var target = targetOrType;
          var type = typeOrListener;
          validateTarget(target);
          validateEventType(type);
          validateListener(listener);
          listener = bind(this, listener);
          this.off("dispose", listener);
          if (target.nodeName) {
            off(target, type, listener);
            off(target, "dispose", listener);
          } else if (isEvented(target)) {
            target.off(type, listener);
            target.off("dispose", listener);
          }
        }
      },
      /**
       * Fire an event on this evented object, causing its listeners to be called.
       *
       * @param   {string|Object} event
       *          An event type or an object with a type property.
       *
       * @param   {Object} [hash]
       *          An additional object to pass along to listeners.
       *
       * @returns {boolean}
       *          Whether or not the default behavior was prevented.
       */
      trigger: function trigger$$1(event2, hash) {
        return trigger(this.eventBusEl_, event2, hash);
      }
    };
    function evented(target) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var eventBusKey = options.eventBusKey;
      if (eventBusKey) {
        if (!target[eventBusKey].nodeName) {
          throw new Error('The eventBusKey "' + eventBusKey + '" does not refer to an element.');
        }
        target.eventBusEl_ = target[eventBusKey];
      } else {
        target.eventBusEl_ = createEl("span", { className: "vjs-event-bus" });
      }
      assign(target, EventedMixin);
      target.on("dispose", function() {
        target.off();
        window2.setTimeout(function() {
          target.eventBusEl_ = null;
        }, 0);
      });
      return target;
    }
    var StatefulMixin = {
      /**
       * A hash containing arbitrary keys and values representing the state of
       * the object.
       *
       * @type {Object}
       */
      state: {},
      /**
       * Set the state of an object by mutating its
       * {@link module:stateful~StatefulMixin.state|state} object in place.
       *
       * @fires   module:stateful~StatefulMixin#statechanged
       * @param   {Object|Function} stateUpdates
       *          A new set of properties to shallow-merge into the plugin state.
       *          Can be a plain object or a function returning a plain object.
       *
       * @returns {Object|undefined}
       *          An object containing changes that occurred. If no changes
       *          occurred, returns `undefined`.
       */
      setState: function setState(stateUpdates) {
        var _this = this;
        if (typeof stateUpdates === "function") {
          stateUpdates = stateUpdates();
        }
        var changes = void 0;
        each(stateUpdates, function(value, key) {
          if (_this.state[key] !== value) {
            changes = changes || {};
            changes[key] = {
              from: _this.state[key],
              to: value
            };
          }
          _this.state[key] = value;
        });
        if (changes && isEvented(this)) {
          this.trigger({
            changes,
            type: "statechanged"
          });
        }
        return changes;
      }
    };
    function stateful(target, defaultState) {
      assign(target, StatefulMixin);
      target.state = assign({}, target.state, defaultState);
      if (typeof target.handleStateChanged === "function" && isEvented(target)) {
        target.on("statechanged", target.handleStateChanged);
      }
      return target;
    }
    function toTitleCase(string) {
      if (typeof string !== "string") {
        return string;
      }
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
    function titleCaseEquals(str1, str2) {
      return toTitleCase(str1) === toTitleCase(str2);
    }
    function mergeOptions() {
      var result = {};
      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        each(source, function(value, key) {
          if (!isPlain(value)) {
            result[key] = value;
            return;
          }
          if (!isPlain(result[key])) {
            result[key] = {};
          }
          result[key] = mergeOptions(result[key], value);
        });
      });
      return result;
    }
    var Component = function() {
      function Component2(player, options, ready) {
        classCallCheck(this, Component2);
        if (!player && this.play) {
          this.player_ = player = this;
        } else {
          this.player_ = player;
        }
        this.options_ = mergeOptions({}, this.options_);
        options = this.options_ = mergeOptions(this.options_, options);
        this.id_ = options.id || options.el && options.el.id;
        if (!this.id_) {
          var id = player && player.id && player.id() || "no_player";
          this.id_ = id + "_component_" + newGUID();
        }
        this.name_ = options.name || null;
        if (options.el) {
          this.el_ = options.el;
        } else if (options.createEl !== false) {
          this.el_ = this.createEl();
        }
        if (options.evented !== false) {
          evented(this, { eventBusKey: this.el_ ? "el_" : null });
        }
        stateful(this, this.constructor.defaultState);
        this.children_ = [];
        this.childIndex_ = {};
        this.childNameIndex_ = {};
        if (options.initChildren !== false) {
          this.initChildren();
        }
        this.ready(ready);
        if (options.reportTouchActivity !== false) {
          this.enableTouchActivity();
        }
      }
      Component2.prototype.dispose = function dispose() {
        this.trigger({ type: "dispose", bubbles: false });
        if (this.children_) {
          for (var i2 = this.children_.length - 1; i2 >= 0; i2--) {
            if (this.children_[i2].dispose) {
              this.children_[i2].dispose();
            }
          }
        }
        this.children_ = null;
        this.childIndex_ = null;
        this.childNameIndex_ = null;
        if (this.el_) {
          if (this.el_.parentNode) {
            this.el_.parentNode.removeChild(this.el_);
          }
          removeData(this.el_);
          this.el_ = null;
        }
        this.player_ = null;
      };
      Component2.prototype.player = function player() {
        return this.player_;
      };
      Component2.prototype.options = function options(obj) {
        log.warn("this.options() has been deprecated and will be moved to the constructor in 6.0");
        if (!obj) {
          return this.options_;
        }
        this.options_ = mergeOptions(this.options_, obj);
        return this.options_;
      };
      Component2.prototype.el = function el() {
        return this.el_;
      };
      Component2.prototype.createEl = function createEl$$1(tagName, properties, attributes) {
        return createEl(tagName, properties, attributes);
      };
      Component2.prototype.localize = function localize(string, tokens) {
        var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : string;
        var code = this.player_.language && this.player_.language();
        var languages = this.player_.languages && this.player_.languages();
        var language = languages && languages[code];
        var primaryCode = code && code.split("-")[0];
        var primaryLang = languages && languages[primaryCode];
        var localizedString = defaultValue;
        if (language && language[string]) {
          localizedString = language[string];
        } else if (primaryLang && primaryLang[string]) {
          localizedString = primaryLang[string];
        }
        if (tokens) {
          localizedString = localizedString.replace(/\{(\d+)\}/g, function(match, index) {
            var value = tokens[index - 1];
            var ret = value;
            if (typeof value === "undefined") {
              ret = match;
            }
            return ret;
          });
        }
        return localizedString;
      };
      Component2.prototype.contentEl = function contentEl() {
        return this.contentEl_ || this.el_;
      };
      Component2.prototype.id = function id() {
        return this.id_;
      };
      Component2.prototype.name = function name() {
        return this.name_;
      };
      Component2.prototype.children = function children() {
        return this.children_;
      };
      Component2.prototype.getChildById = function getChildById(id) {
        return this.childIndex_[id];
      };
      Component2.prototype.getChild = function getChild(name) {
        if (!name) {
          return;
        }
        name = toTitleCase(name);
        return this.childNameIndex_[name];
      };
      Component2.prototype.addChild = function addChild(child) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var index = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.children_.length;
        var component = void 0;
        var componentName = void 0;
        if (typeof child === "string") {
          componentName = toTitleCase(child);
          var componentClassName = options.componentClass || componentName;
          options.name = componentName;
          var ComponentClass = Component2.getComponent(componentClassName);
          if (!ComponentClass) {
            throw new Error("Component " + componentClassName + " does not exist");
          }
          if (typeof ComponentClass !== "function") {
            return null;
          }
          component = new ComponentClass(this.player_ || this, options);
        } else {
          component = child;
        }
        this.children_.splice(index, 0, component);
        if (typeof component.id === "function") {
          this.childIndex_[component.id()] = component;
        }
        componentName = componentName || component.name && toTitleCase(component.name());
        if (componentName) {
          this.childNameIndex_[componentName] = component;
        }
        if (typeof component.el === "function" && component.el()) {
          var childNodes = this.contentEl().children;
          var refNode = childNodes[index] || null;
          this.contentEl().insertBefore(component.el(), refNode);
        }
        return component;
      };
      Component2.prototype.removeChild = function removeChild(component) {
        if (typeof component === "string") {
          component = this.getChild(component);
        }
        if (!component || !this.children_) {
          return;
        }
        var childFound = false;
        for (var i2 = this.children_.length - 1; i2 >= 0; i2--) {
          if (this.children_[i2] === component) {
            childFound = true;
            this.children_.splice(i2, 1);
            break;
          }
        }
        if (!childFound) {
          return;
        }
        this.childIndex_[component.id()] = null;
        this.childNameIndex_[component.name()] = null;
        var compEl = component.el();
        if (compEl && compEl.parentNode === this.contentEl()) {
          this.contentEl().removeChild(component.el());
        }
      };
      Component2.prototype.initChildren = function initChildren() {
        var _this = this;
        var children = this.options_.children;
        if (children) {
          var parentOptions = this.options_;
          var handleAdd = function handleAdd2(child) {
            var name = child.name;
            var opts = child.opts;
            if (parentOptions[name] !== void 0) {
              opts = parentOptions[name];
            }
            if (opts === false) {
              return;
            }
            if (opts === true) {
              opts = {};
            }
            opts.playerOptions = _this.options_.playerOptions;
            var newChild = _this.addChild(name, opts);
            if (newChild) {
              _this[name] = newChild;
            }
          };
          var workingChildren = void 0;
          var Tech2 = Component2.getComponent("Tech");
          if (Array.isArray(children)) {
            workingChildren = children;
          } else {
            workingChildren = Object.keys(children);
          }
          workingChildren.concat(Object.keys(this.options_).filter(function(child) {
            return !workingChildren.some(function(wchild) {
              if (typeof wchild === "string") {
                return child === wchild;
              }
              return child === wchild.name;
            });
          })).map(function(child) {
            var name = void 0;
            var opts = void 0;
            if (typeof child === "string") {
              name = child;
              opts = children[name] || _this.options_[name] || {};
            } else {
              name = child.name;
              opts = child;
            }
            return { name, opts };
          }).filter(function(child) {
            var c = Component2.getComponent(child.opts.componentClass || toTitleCase(child.name));
            return c && !Tech2.isTech(c);
          }).forEach(handleAdd);
        }
      };
      Component2.prototype.buildCSSClass = function buildCSSClass() {
        return "";
      };
      Component2.prototype.ready = function ready(fn) {
        var sync = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!fn) {
          return;
        }
        if (!this.isReady_) {
          this.readyQueue_ = this.readyQueue_ || [];
          this.readyQueue_.push(fn);
          return;
        }
        if (sync) {
          fn.call(this);
        } else {
          this.setTimeout(fn, 1);
        }
      };
      Component2.prototype.triggerReady = function triggerReady() {
        this.isReady_ = true;
        this.setTimeout(function() {
          var readyQueue = this.readyQueue_;
          this.readyQueue_ = [];
          if (readyQueue && readyQueue.length > 0) {
            readyQueue.forEach(function(fn) {
              fn.call(this);
            }, this);
          }
          this.trigger("ready");
        }, 1);
      };
      Component2.prototype.$ = function $$$1(selector, context) {
        return $(selector, context || this.contentEl());
      };
      Component2.prototype.$$ = function $$$$1(selector, context) {
        return $$(selector, context || this.contentEl());
      };
      Component2.prototype.hasClass = function hasClass$$1(classToCheck) {
        return hasClass(this.el_, classToCheck);
      };
      Component2.prototype.addClass = function addClass$$1(classToAdd) {
        addClass(this.el_, classToAdd);
      };
      Component2.prototype.removeClass = function removeClass$$1(classToRemove) {
        removeClass(this.el_, classToRemove);
      };
      Component2.prototype.toggleClass = function toggleClass$$1(classToToggle, predicate) {
        toggleClass(this.el_, classToToggle, predicate);
      };
      Component2.prototype.show = function show() {
        this.removeClass("vjs-hidden");
      };
      Component2.prototype.hide = function hide() {
        this.addClass("vjs-hidden");
      };
      Component2.prototype.lockShowing = function lockShowing() {
        this.addClass("vjs-lock-showing");
      };
      Component2.prototype.unlockShowing = function unlockShowing() {
        this.removeClass("vjs-lock-showing");
      };
      Component2.prototype.getAttribute = function getAttribute$$1(attribute) {
        return getAttribute(this.el_, attribute);
      };
      Component2.prototype.setAttribute = function setAttribute$$1(attribute, value) {
        setAttribute(this.el_, attribute, value);
      };
      Component2.prototype.removeAttribute = function removeAttribute$$1(attribute) {
        removeAttribute(this.el_, attribute);
      };
      Component2.prototype.width = function width(num, skipListeners) {
        return this.dimension("width", num, skipListeners);
      };
      Component2.prototype.height = function height(num, skipListeners) {
        return this.dimension("height", num, skipListeners);
      };
      Component2.prototype.dimensions = function dimensions(width, height) {
        this.width(width, true);
        this.height(height);
      };
      Component2.prototype.dimension = function dimension(widthOrHeight, num, skipListeners) {
        if (num !== void 0) {
          if (num === null || num !== num) {
            num = 0;
          }
          if (("" + num).indexOf("%") !== -1 || ("" + num).indexOf("px") !== -1) {
            this.el_.style[widthOrHeight] = num;
          } else if (num === "auto") {
            this.el_.style[widthOrHeight] = "";
          } else {
            this.el_.style[widthOrHeight] = num + "px";
          }
          if (!skipListeners) {
            this.trigger("componentresize");
          }
          return;
        }
        if (!this.el_) {
          return 0;
        }
        var val = this.el_.style[widthOrHeight];
        var pxIndex = val.indexOf("px");
        if (pxIndex !== -1) {
          return parseInt(val.slice(0, pxIndex), 10);
        }
        return parseInt(this.el_["offset" + toTitleCase(widthOrHeight)], 10);
      };
      Component2.prototype.currentDimension = function currentDimension(widthOrHeight) {
        var computedWidthOrHeight = 0;
        if (widthOrHeight !== "width" && widthOrHeight !== "height") {
          throw new Error("currentDimension only accepts width or height value");
        }
        if (typeof window2.getComputedStyle === "function") {
          var computedStyle2 = window2.getComputedStyle(this.el_);
          computedWidthOrHeight = computedStyle2.getPropertyValue(widthOrHeight) || computedStyle2[widthOrHeight];
        }
        computedWidthOrHeight = parseFloat(computedWidthOrHeight);
        if (computedWidthOrHeight === 0) {
          var rule = "offset" + toTitleCase(widthOrHeight);
          computedWidthOrHeight = this.el_[rule];
        }
        return computedWidthOrHeight;
      };
      Component2.prototype.currentDimensions = function currentDimensions() {
        return {
          width: this.currentDimension("width"),
          height: this.currentDimension("height")
        };
      };
      Component2.prototype.currentWidth = function currentWidth() {
        return this.currentDimension("width");
      };
      Component2.prototype.currentHeight = function currentHeight() {
        return this.currentDimension("height");
      };
      Component2.prototype.focus = function focus() {
        this.el_.focus();
      };
      Component2.prototype.blur = function blur() {
        this.el_.blur();
      };
      Component2.prototype.emitTapEvents = function emitTapEvents() {
        var touchStart = 0;
        var firstTouch = null;
        var tapMovementThreshold = 10;
        var touchTimeThreshold = 200;
        var couldBeTap = void 0;
        this.on("touchstart", function(event2) {
          if (event2.touches.length === 1) {
            firstTouch = {
              pageX: event2.touches[0].pageX,
              pageY: event2.touches[0].pageY
            };
            touchStart = new Date().getTime();
            couldBeTap = true;
          }
        });
        this.on("touchmove", function(event2) {
          if (event2.touches.length > 1) {
            couldBeTap = false;
          } else if (firstTouch) {
            var xdiff = event2.touches[0].pageX - firstTouch.pageX;
            var ydiff = event2.touches[0].pageY - firstTouch.pageY;
            var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
            if (touchDistance > tapMovementThreshold) {
              couldBeTap = false;
            }
          }
        });
        var noTap = function noTap2() {
          couldBeTap = false;
        };
        this.on("touchleave", noTap);
        this.on("touchcancel", noTap);
        this.on("touchend", function(event2) {
          firstTouch = null;
          if (couldBeTap === true) {
            var touchTime = new Date().getTime() - touchStart;
            if (touchTime < touchTimeThreshold) {
              event2.preventDefault();
              this.trigger("tap");
            }
          }
        });
      };
      Component2.prototype.enableTouchActivity = function enableTouchActivity() {
        if (!this.player() || !this.player().reportUserActivity) {
          return;
        }
        var report = bind(this.player(), this.player().reportUserActivity);
        var touchHolding = void 0;
        this.on("touchstart", function() {
          report();
          this.clearInterval(touchHolding);
          touchHolding = this.setInterval(report, 250);
        });
        var touchEnd = function touchEnd2(event2) {
          report();
          this.clearInterval(touchHolding);
        };
        this.on("touchmove", report);
        this.on("touchend", touchEnd);
        this.on("touchcancel", touchEnd);
      };
      Component2.prototype.setTimeout = function setTimeout2(fn, timeout) {
        var _this2 = this;
        var timeoutId, disposeFn;
        fn = bind(this, fn);
        timeoutId = window2.setTimeout(function() {
          _this2.off("dispose", disposeFn);
          fn();
        }, timeout);
        disposeFn = function disposeFn2() {
          return _this2.clearTimeout(timeoutId);
        };
        disposeFn.guid = "vjs-timeout-" + timeoutId;
        this.on("dispose", disposeFn);
        return timeoutId;
      };
      Component2.prototype.clearTimeout = function clearTimeout2(timeoutId) {
        window2.clearTimeout(timeoutId);
        var disposeFn = function disposeFn2() {
        };
        disposeFn.guid = "vjs-timeout-" + timeoutId;
        this.off("dispose", disposeFn);
        return timeoutId;
      };
      Component2.prototype.setInterval = function setInterval(fn, interval) {
        var _this3 = this;
        fn = bind(this, fn);
        var intervalId = window2.setInterval(fn, interval);
        var disposeFn = function disposeFn2() {
          return _this3.clearInterval(intervalId);
        };
        disposeFn.guid = "vjs-interval-" + intervalId;
        this.on("dispose", disposeFn);
        return intervalId;
      };
      Component2.prototype.clearInterval = function clearInterval(intervalId) {
        window2.clearInterval(intervalId);
        var disposeFn = function disposeFn2() {
        };
        disposeFn.guid = "vjs-interval-" + intervalId;
        this.off("dispose", disposeFn);
        return intervalId;
      };
      Component2.prototype.requestAnimationFrame = function requestAnimationFrame(fn) {
        var _this4 = this;
        var id, disposeFn;
        if (this.supportsRaf_) {
          fn = bind(this, fn);
          id = window2.requestAnimationFrame(function() {
            _this4.off("dispose", disposeFn);
            fn();
          });
          disposeFn = function disposeFn2() {
            return _this4.cancelAnimationFrame(id);
          };
          disposeFn.guid = "vjs-raf-" + id;
          this.on("dispose", disposeFn);
          return id;
        }
        return this.setTimeout(fn, 1e3 / 60);
      };
      Component2.prototype.cancelAnimationFrame = function cancelAnimationFrame(id) {
        if (this.supportsRaf_) {
          window2.cancelAnimationFrame(id);
          var disposeFn = function disposeFn2() {
          };
          disposeFn.guid = "vjs-raf-" + id;
          this.off("dispose", disposeFn);
          return id;
        }
        return this.clearTimeout(id);
      };
      Component2.registerComponent = function registerComponent(name, ComponentToRegister) {
        if (typeof name !== "string" || !name) {
          throw new Error('Illegal component name, "' + name + '"; must be a non-empty string.');
        }
        var Tech2 = Component2.getComponent("Tech");
        var isTech = Tech2 && Tech2.isTech(ComponentToRegister);
        var isComp = Component2 === ComponentToRegister || Component2.prototype.isPrototypeOf(ComponentToRegister.prototype);
        if (isTech || !isComp) {
          var reason = void 0;
          if (isTech) {
            reason = "techs must be registered using Tech.registerTech()";
          } else {
            reason = "must be a Component subclass";
          }
          throw new Error('Illegal component, "' + name + '"; ' + reason + ".");
        }
        name = toTitleCase(name);
        if (!Component2.components_) {
          Component2.components_ = {};
        }
        var Player2 = Component2.getComponent("Player");
        if (name === "Player" && Player2 && Player2.players) {
          var players = Player2.players;
          var playerNames = Object.keys(players);
          if (players && playerNames.length > 0 && playerNames.map(function(pname) {
            return players[pname];
          }).every(Boolean)) {
            throw new Error("Can not register Player component after player has been created.");
          }
        }
        Component2.components_[name] = ComponentToRegister;
        return ComponentToRegister;
      };
      Component2.getComponent = function getComponent(name) {
        if (!name) {
          return;
        }
        name = toTitleCase(name);
        if (Component2.components_ && Component2.components_[name]) {
          return Component2.components_[name];
        }
      };
      return Component2;
    }();
    Component.prototype.supportsRaf_ = typeof window2.requestAnimationFrame === "function" && typeof window2.cancelAnimationFrame === "function";
    Component.registerComponent("Component", Component);
    function rangeCheck(fnName, index, maxIndex) {
      if (typeof index !== "number" || index < 0 || index > maxIndex) {
        throw new Error("Failed to execute '" + fnName + "' on 'TimeRanges': The index provided (" + index + ") is non-numeric or out of bounds (0-" + maxIndex + ").");
      }
    }
    function getRange(fnName, valueIndex, ranges, rangeIndex) {
      rangeCheck(fnName, rangeIndex, ranges.length - 1);
      return ranges[rangeIndex][valueIndex];
    }
    function createTimeRangesObj(ranges) {
      if (ranges === void 0 || ranges.length === 0) {
        return {
          length: 0,
          start: function start() {
            throw new Error("This TimeRanges object is empty");
          },
          end: function end() {
            throw new Error("This TimeRanges object is empty");
          }
        };
      }
      return {
        length: ranges.length,
        start: getRange.bind(null, "start", 0, ranges),
        end: getRange.bind(null, "end", 1, ranges)
      };
    }
    function createTimeRanges(start, end) {
      if (Array.isArray(start)) {
        return createTimeRangesObj(start);
      } else if (start === void 0 || end === void 0) {
        return createTimeRangesObj();
      }
      return createTimeRangesObj([[start, end]]);
    }
    function bufferedPercent(buffered, duration) {
      var bufferedDuration = 0;
      var start = void 0;
      var end = void 0;
      if (!duration) {
        return 0;
      }
      if (!buffered || !buffered.length) {
        buffered = createTimeRanges(0, 0);
      }
      for (var i2 = 0; i2 < buffered.length; i2++) {
        start = buffered.start(i2);
        end = buffered.end(i2);
        if (end > duration) {
          end = duration;
        }
        bufferedDuration += end - start;
      }
      return bufferedDuration / duration;
    }
    var FullscreenApi = {};
    var apiMap = [
      ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"],
      // WebKit
      ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"],
      // Old WebKit (Safari 5.1)
      ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"],
      // Mozilla
      ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"],
      // Microsoft
      ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]
    ];
    var specApi = apiMap[0];
    var browserApi = void 0;
    for (i = 0; i < apiMap.length; i++) {
      if (apiMap[i][1] in document2) {
        browserApi = apiMap[i];
        break;
      }
    }
    var i;
    if (browserApi) {
      for (_i = 0; _i < browserApi.length; _i++) {
        FullscreenApi[specApi[_i]] = browserApi[_i];
      }
    }
    var _i;
    function MediaError(value) {
      if (value instanceof MediaError) {
        return value;
      }
      if (typeof value === "number") {
        this.code = value;
      } else if (typeof value === "string") {
        this.message = value;
      } else if (isObject(value)) {
        if (typeof value.code === "number") {
          this.code = value.code;
        }
        assign(this, value);
      }
      if (!this.message) {
        this.message = MediaError.defaultMessages[this.code] || "";
      }
    }
    MediaError.prototype.code = 0;
    MediaError.prototype.message = "";
    MediaError.prototype.status = null;
    MediaError.errorTypes = ["MEDIA_ERR_CUSTOM", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_ERR_ENCRYPTED"];
    MediaError.defaultMessages = {
      1: "You aborted the media playback",
      2: "A network error caused the media download to fail part-way.",
      3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
      4: "The media could not be loaded, either because the server or network failed or because the format is not supported.",
      5: "The media is encrypted and we do not have the keys to decrypt it."
    };
    for (errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
      MediaError[MediaError.errorTypes[errNum]] = errNum;
      MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
    }
    var errNum;
    function isPromise(value) {
      return value !== void 0 && value !== null && typeof value.then === "function";
    }
    function silencePromise(value) {
      if (isPromise(value)) {
        value.then(null, function(e) {
        });
      }
    }
    var trackToJson_ = function trackToJson_2(track2) {
      var ret = ["kind", "label", "language", "id", "inBandMetadataTrackDispatchType", "mode", "src"].reduce(function(acc, prop, i2) {
        if (track2[prop]) {
          acc[prop] = track2[prop];
        }
        return acc;
      }, {
        cues: track2.cues && Array.prototype.map.call(track2.cues, function(cue) {
          return {
            startTime: cue.startTime,
            endTime: cue.endTime,
            text: cue.text,
            id: cue.id
          };
        })
      });
      return ret;
    };
    var textTracksToJson = function textTracksToJson2(tech) {
      var trackEls = tech.$$("track");
      var trackObjs = Array.prototype.map.call(trackEls, function(t) {
        return t.track;
      });
      var tracks = Array.prototype.map.call(trackEls, function(trackEl) {
        var json = trackToJson_(trackEl.track);
        if (trackEl.src) {
          json.src = trackEl.src;
        }
        return json;
      });
      return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function(track2) {
        return trackObjs.indexOf(track2) === -1;
      }).map(trackToJson_));
    };
    var jsonToTextTracks = function jsonToTextTracks2(json, tech) {
      json.forEach(function(track2) {
        var addedTrack = tech.addRemoteTextTrack(track2).track;
        if (!track2.src && track2.cues) {
          track2.cues.forEach(function(cue) {
            return addedTrack.addCue(cue);
          });
        }
      });
      return tech.textTracks();
    };
    var textTrackConverter = { textTracksToJson, jsonToTextTracks, trackToJson_ };
    var MODAL_CLASS_NAME = "vjs-modal-dialog";
    var ESC = 27;
    var ModalDialog = function(_Component) {
      inherits(ModalDialog2, _Component);
      function ModalDialog2(player, options) {
        classCallCheck(this, ModalDialog2);
        var _this = possibleConstructorReturn(this, _Component.call(this, player, options));
        _this.opened_ = _this.hasBeenOpened_ = _this.hasBeenFilled_ = false;
        _this.closeable(!_this.options_.uncloseable);
        _this.content(_this.options_.content);
        _this.contentEl_ = createEl("div", {
          className: MODAL_CLASS_NAME + "-content"
        }, {
          role: "document"
        });
        _this.descEl_ = createEl("p", {
          className: MODAL_CLASS_NAME + "-description vjs-control-text",
          id: _this.el().getAttribute("aria-describedby")
        });
        textContent(_this.descEl_, _this.description());
        _this.el_.appendChild(_this.descEl_);
        _this.el_.appendChild(_this.contentEl_);
        return _this;
      }
      ModalDialog2.prototype.createEl = function createEl$$1() {
        return _Component.prototype.createEl.call(this, "div", {
          className: this.buildCSSClass(),
          tabIndex: -1
        }, {
          "aria-describedby": this.id() + "_description",
          "aria-hidden": "true",
          "aria-label": this.label(),
          "role": "dialog"
        });
      };
      ModalDialog2.prototype.dispose = function dispose() {
        this.contentEl_ = null;
        this.descEl_ = null;
        this.previouslyActiveEl_ = null;
        _Component.prototype.dispose.call(this);
      };
      ModalDialog2.prototype.buildCSSClass = function buildCSSClass() {
        return MODAL_CLASS_NAME + " vjs-hidden " + _Component.prototype.buildCSSClass.call(this);
      };
      ModalDialog2.prototype.handleKeyPress = function handleKeyPress(e) {
        if (e.which === ESC && this.closeable()) {
          this.close();
        }
      };
      ModalDialog2.prototype.label = function label() {
        return this.localize(this.options_.label || "Modal Window");
      };
      ModalDialog2.prototype.description = function description() {
        var desc = this.options_.description || this.localize("This is a modal window.");
        if (this.closeable()) {
          desc += " " + this.localize("This modal can be closed by pressing the Escape key or activating the close button.");
        }
        return desc;
      };
      ModalDialog2.prototype.open = function open() {
        if (!this.opened_) {
          var player = this.player();
          this.trigger("beforemodalopen");
          this.opened_ = true;
          if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {
            this.fill();
          }
          this.wasPlaying_ = !player.paused();
          if (this.options_.pauseOnOpen && this.wasPlaying_) {
            player.pause();
          }
          if (this.closeable()) {
            this.on(this.el_.ownerDocument, "keydown", bind(this, this.handleKeyPress));
          }
          this.hadControls_ = player.controls();
          player.controls(false);
          this.show();
          this.conditionalFocus_();
          this.el().setAttribute("aria-hidden", "false");
          this.trigger("modalopen");
          this.hasBeenOpened_ = true;
        }
      };
      ModalDialog2.prototype.opened = function opened(value) {
        if (typeof value === "boolean") {
          this[value ? "open" : "close"]();
        }
        return this.opened_;
      };
      ModalDialog2.prototype.close = function close() {
        if (!this.opened_) {
          return;
        }
        var player = this.player();
        this.trigger("beforemodalclose");
        this.opened_ = false;
        if (this.wasPlaying_ && this.options_.pauseOnOpen) {
          player.play();
        }
        if (this.closeable()) {
          this.off(this.el_.ownerDocument, "keydown", bind(this, this.handleKeyPress));
        }
        if (this.hadControls_) {
          player.controls(true);
        }
        this.hide();
        this.el().setAttribute("aria-hidden", "true");
        this.trigger("modalclose");
        this.conditionalBlur_();
        if (this.options_.temporary) {
          this.dispose();
        }
      };
      ModalDialog2.prototype.closeable = function closeable(value) {
        if (typeof value === "boolean") {
          var closeable2 = this.closeable_ = !!value;
          var close = this.getChild("closeButton");
          if (closeable2 && !close) {
            var temp = this.contentEl_;
            this.contentEl_ = this.el_;
            close = this.addChild("closeButton", { controlText: "Close Modal Dialog" });
            this.contentEl_ = temp;
            this.on(close, "close", this.close);
          }
          if (!closeable2 && close) {
            this.off(close, "close", this.close);
            this.removeChild(close);
            close.dispose();
          }
        }
        return this.closeable_;
      };
      ModalDialog2.prototype.fill = function fill() {
        this.fillWith(this.content());
      };
      ModalDialog2.prototype.fillWith = function fillWith(content) {
        var contentEl = this.contentEl();
        var parentEl = contentEl.parentNode;
        var nextSiblingEl = contentEl.nextSibling;
        this.trigger("beforemodalfill");
        this.hasBeenFilled_ = true;
        parentEl.removeChild(contentEl);
        this.empty();
        insertContent(contentEl, content);
        this.trigger("modalfill");
        if (nextSiblingEl) {
          parentEl.insertBefore(contentEl, nextSiblingEl);
        } else {
          parentEl.appendChild(contentEl);
        }
        var closeButton = this.getChild("closeButton");
        if (closeButton) {
          parentEl.appendChild(closeButton.el_);
        }
      };
      ModalDialog2.prototype.empty = function empty() {
        this.trigger("beforemodalempty");
        emptyEl(this.contentEl());
        this.trigger("modalempty");
      };
      ModalDialog2.prototype.content = function content(value) {
        if (typeof value !== "undefined") {
          this.content_ = value;
        }
        return this.content_;
      };
      ModalDialog2.prototype.conditionalFocus_ = function conditionalFocus_() {
        var activeEl = document2.activeElement;
        var playerEl = this.player_.el_;
        this.previouslyActiveEl_ = null;
        if (playerEl.contains(activeEl) || playerEl === activeEl) {
          this.previouslyActiveEl_ = activeEl;
          this.focus();
          this.on(document2, "keydown", this.handleKeyDown);
        }
      };
      ModalDialog2.prototype.conditionalBlur_ = function conditionalBlur_() {
        if (this.previouslyActiveEl_) {
          this.previouslyActiveEl_.focus();
          this.previouslyActiveEl_ = null;
        }
        this.off(document2, "keydown", this.handleKeyDown);
      };
      ModalDialog2.prototype.handleKeyDown = function handleKeyDown(event2) {
        if (event2.which !== 9) {
          return;
        }
        var focusableEls = this.focusableEls_();
        var activeEl = this.el_.querySelector(":focus");
        var focusIndex = void 0;
        for (var i2 = 0; i2 < focusableEls.length; i2++) {
          if (activeEl === focusableEls[i2]) {
            focusIndex = i2;
            break;
          }
        }
        if (document2.activeElement === this.el_) {
          focusIndex = 0;
        }
        if (event2.shiftKey && focusIndex === 0) {
          focusableEls[focusableEls.length - 1].focus();
          event2.preventDefault();
        } else if (!event2.shiftKey && focusIndex === focusableEls.length - 1) {
          focusableEls[0].focus();
          event2.preventDefault();
        }
      };
      ModalDialog2.prototype.focusableEls_ = function focusableEls_() {
        var allChildren = this.el_.querySelectorAll("*");
        return Array.prototype.filter.call(allChildren, function(child) {
          return (child instanceof window2.HTMLAnchorElement || child instanceof window2.HTMLAreaElement) && child.hasAttribute("href") || (child instanceof window2.HTMLInputElement || child instanceof window2.HTMLSelectElement || child instanceof window2.HTMLTextAreaElement || child instanceof window2.HTMLButtonElement) && !child.hasAttribute("disabled") || child instanceof window2.HTMLIFrameElement || child instanceof window2.HTMLObjectElement || child instanceof window2.HTMLEmbedElement || child.hasAttribute("tabindex") && child.getAttribute("tabindex") !== -1 || child.hasAttribute("contenteditable");
        });
      };
      return ModalDialog2;
    }(Component);
    ModalDialog.prototype.options_ = {
      pauseOnOpen: true,
      temporary: true
    };
    Component.registerComponent("ModalDialog", ModalDialog);
    var TrackList = function(_EventTarget) {
      inherits(TrackList2, _EventTarget);
      function TrackList2() {
        var tracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        var _ret;
        var list = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        classCallCheck(this, TrackList2);
        var _this = possibleConstructorReturn(this, _EventTarget.call(this));
        if (!list) {
          list = _this;
          if (IS_IE8) {
            list = document2.createElement("custom");
            for (var prop in TrackList2.prototype) {
              if (prop !== "constructor") {
                list[prop] = TrackList2.prototype[prop];
              }
            }
          }
        }
        list.tracks_ = [];
        Object.defineProperty(list, "length", {
          get: function get$$1() {
            return this.tracks_.length;
          }
        });
        for (var i2 = 0; i2 < tracks.length; i2++) {
          list.addTrack(tracks[i2]);
        }
        return _ret = list, possibleConstructorReturn(_this, _ret);
      }
      TrackList2.prototype.addTrack = function addTrack(track2) {
        var index = this.tracks_.length;
        if (!("" + index in this)) {
          Object.defineProperty(this, index, {
            get: function get$$1() {
              return this.tracks_[index];
            }
          });
        }
        if (this.tracks_.indexOf(track2) === -1) {
          this.tracks_.push(track2);
          this.trigger({
            track: track2,
            type: "addtrack"
          });
        }
      };
      TrackList2.prototype.removeTrack = function removeTrack(rtrack) {
        var track2 = void 0;
        for (var i2 = 0, l = this.length; i2 < l; i2++) {
          if (this[i2] === rtrack) {
            track2 = this[i2];
            if (track2.off) {
              track2.off();
            }
            this.tracks_.splice(i2, 1);
            break;
          }
        }
        if (!track2) {
          return;
        }
        this.trigger({
          track: track2,
          type: "removetrack"
        });
      };
      TrackList2.prototype.getTrackById = function getTrackById(id) {
        var result = null;
        for (var i2 = 0, l = this.length; i2 < l; i2++) {
          var track2 = this[i2];
          if (track2.id === id) {
            result = track2;
            break;
          }
        }
        return result;
      };
      return TrackList2;
    }(EventTarget);
    TrackList.prototype.allowedEvents_ = {
      change: "change",
      addtrack: "addtrack",
      removetrack: "removetrack"
    };
    for (event in TrackList.prototype.allowedEvents_) {
      TrackList.prototype["on" + event] = null;
    }
    var event;
    var disableOthers = function disableOthers2(list, track2) {
      for (var i2 = 0; i2 < list.length; i2++) {
        if (!Object.keys(list[i2]).length || track2.id === list[i2].id) {
          continue;
        }
        list[i2].enabled = false;
      }
    };
    var AudioTrackList = function(_TrackList) {
      inherits(AudioTrackList2, _TrackList);
      function AudioTrackList2() {
        var _this, _ret;
        var tracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        classCallCheck(this, AudioTrackList2);
        var list = void 0;
        for (var i2 = tracks.length - 1; i2 >= 0; i2--) {
          if (tracks[i2].enabled) {
            disableOthers(tracks, tracks[i2]);
            break;
          }
        }
        if (IS_IE8) {
          list = document2.createElement("custom");
          for (var prop in TrackList.prototype) {
            if (prop !== "constructor") {
              list[prop] = TrackList.prototype[prop];
            }
          }
          for (var _prop in AudioTrackList2.prototype) {
            if (_prop !== "constructor") {
              list[_prop] = AudioTrackList2.prototype[_prop];
            }
          }
        }
        list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
        list.changing_ = false;
        return _ret = list, possibleConstructorReturn(_this, _ret);
      }
      AudioTrackList2.prototype.addTrack = function addTrack(track2) {
        var _this2 = this;
        if (track2.enabled) {
          disableOthers(this, track2);
        }
        _TrackList.prototype.addTrack.call(this, track2);
        if (!track2.addEventListener) {
          return;
        }
        track2.addEventListener("enabledchange", function() {
          if (_this2.changing_) {
            return;
          }
          _this2.changing_ = true;
          disableOthers(_this2, track2);
          _this2.changing_ = false;
          _this2.trigger("change");
        });
      };
      return AudioTrackList2;
    }(TrackList);
    var disableOthers$1 = function disableOthers2(list, track2) {
      for (var i2 = 0; i2 < list.length; i2++) {
        if (!Object.keys(list[i2]).length || track2.id === list[i2].id) {
          continue;
        }
        list[i2].selected = false;
      }
    };
    var VideoTrackList = function(_TrackList) {
      inherits(VideoTrackList2, _TrackList);
      function VideoTrackList2() {
        var _this, _ret;
        var tracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        classCallCheck(this, VideoTrackList2);
        var list = void 0;
        for (var i2 = tracks.length - 1; i2 >= 0; i2--) {
          if (tracks[i2].selected) {
            disableOthers$1(tracks, tracks[i2]);
            break;
          }
        }
        if (IS_IE8) {
          list = document2.createElement("custom");
          for (var prop in TrackList.prototype) {
            if (prop !== "constructor") {
              list[prop] = TrackList.prototype[prop];
            }
          }
          for (var _prop in VideoTrackList2.prototype) {
            if (_prop !== "constructor") {
              list[_prop] = VideoTrackList2.prototype[_prop];
            }
          }
        }
        list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
        list.changing_ = false;
        Object.defineProperty(list, "selectedIndex", {
          get: function get$$1() {
            for (var _i2 = 0; _i2 < this.length; _i2++) {
              if (this[_i2].selected) {
                return _i2;
              }
            }
            return -1;
          },
          set: function set$$1() {
          }
        });
        return _ret = list, possibleConstructorReturn(_this, _ret);
      }
      VideoTrackList2.prototype.addTrack = function addTrack(track2) {
        var _this2 = this;
        if (track2.selected) {
          disableOthers$1(this, track2);
        }
        _TrackList.prototype.addTrack.call(this, track2);
        if (!track2.addEventListener) {
          return;
        }
        track2.addEventListener("selectedchange", function() {
          if (_this2.changing_) {
            return;
          }
          _this2.changing_ = true;
          disableOthers$1(_this2, track2);
          _this2.changing_ = false;
          _this2.trigger("change");
        });
      };
      return VideoTrackList2;
    }(TrackList);
    var TextTrackList = function(_TrackList) {
      inherits(TextTrackList2, _TrackList);
      function TextTrackList2() {
        var _this, _ret;
        var tracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        classCallCheck(this, TextTrackList2);
        var list = void 0;
        if (IS_IE8) {
          list = document2.createElement("custom");
          for (var prop in TrackList.prototype) {
            if (prop !== "constructor") {
              list[prop] = TrackList.prototype[prop];
            }
          }
          for (var _prop in TextTrackList2.prototype) {
            if (_prop !== "constructor") {
              list[_prop] = TextTrackList2.prototype[_prop];
            }
          }
        }
        list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
        return _ret = list, possibleConstructorReturn(_this, _ret);
      }
      TextTrackList2.prototype.addTrack = function addTrack(track2) {
        _TrackList.prototype.addTrack.call(this, track2);
        track2.addEventListener("modechange", bind(this, function() {
          this.trigger("change");
        }));
        var nonLanguageTextTrackKind = ["metadata", "chapters"];
        if (nonLanguageTextTrackKind.indexOf(track2.kind) === -1) {
          track2.addEventListener("modechange", bind(this, function() {
            this.trigger("selectedlanguagechange");
          }));
        }
      };
      return TextTrackList2;
    }(TrackList);
    var HtmlTrackElementList = function() {
      function HtmlTrackElementList2() {
        var trackElements = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        classCallCheck(this, HtmlTrackElementList2);
        var list = this;
        if (IS_IE8) {
          list = document2.createElement("custom");
          for (var prop in HtmlTrackElementList2.prototype) {
            if (prop !== "constructor") {
              list[prop] = HtmlTrackElementList2.prototype[prop];
            }
          }
        }
        list.trackElements_ = [];
        Object.defineProperty(list, "length", {
          get: function get$$1() {
            return this.trackElements_.length;
          }
        });
        for (var i2 = 0, length = trackElements.length; i2 < length; i2++) {
          list.addTrackElement_(trackElements[i2]);
        }
        if (IS_IE8) {
          return list;
        }
      }
      HtmlTrackElementList2.prototype.addTrackElement_ = function addTrackElement_(trackElement) {
        var index = this.trackElements_.length;
        if (!("" + index in this)) {
          Object.defineProperty(this, index, {
            get: function get$$1() {
              return this.trackElements_[index];
            }
          });
        }
        if (this.trackElements_.indexOf(trackElement) === -1) {
          this.trackElements_.push(trackElement);
        }
      };
      HtmlTrackElementList2.prototype.getTrackElementByTrack_ = function getTrackElementByTrack_(track2) {
        var trackElement_ = void 0;
        for (var i2 = 0, length = this.trackElements_.length; i2 < length; i2++) {
          if (track2 === this.trackElements_[i2].track) {
            trackElement_ = this.trackElements_[i2];
            break;
          }
        }
        return trackElement_;
      };
      HtmlTrackElementList2.prototype.removeTrackElement_ = function removeTrackElement_(trackElement) {
        for (var i2 = 0, length = this.trackElements_.length; i2 < length; i2++) {
          if (trackElement === this.trackElements_[i2]) {
            this.trackElements_.splice(i2, 1);
            break;
          }
        }
      };
      return HtmlTrackElementList2;
    }();
    var TextTrackCueList = function() {
      function TextTrackCueList2(cues) {
        classCallCheck(this, TextTrackCueList2);
        var list = this;
        if (IS_IE8) {
          list = document2.createElement("custom");
          for (var prop in TextTrackCueList2.prototype) {
            if (prop !== "constructor") {
              list[prop] = TextTrackCueList2.prototype[prop];
            }
          }
        }
        TextTrackCueList2.prototype.setCues_.call(list, cues);
        Object.defineProperty(list, "length", {
          get: function get$$1() {
            return this.length_;
          }
        });
        if (IS_IE8) {
          return list;
        }
      }
      TextTrackCueList2.prototype.setCues_ = function setCues_(cues) {
        var oldLength = this.length || 0;
        var i2 = 0;
        var l = cues.length;
        this.cues_ = cues;
        this.length_ = cues.length;
        var defineProp = function defineProp2(index) {
          if (!("" + index in this)) {
            Object.defineProperty(this, "" + index, {
              get: function get$$1() {
                return this.cues_[index];
              }
            });
          }
        };
        if (oldLength < l) {
          i2 = oldLength;
          for (; i2 < l; i2++) {
            defineProp.call(this, i2);
          }
        }
      };
      TextTrackCueList2.prototype.getCueById = function getCueById(id) {
        var result = null;
        for (var i2 = 0, l = this.length; i2 < l; i2++) {
          var cue = this[i2];
          if (cue.id === id) {
            result = cue;
            break;
          }
        }
        return result;
      };
      return TextTrackCueList2;
    }();
    var VideoTrackKind = {
      alternative: "alternative",
      captions: "captions",
      main: "main",
      sign: "sign",
      subtitles: "subtitles",
      commentary: "commentary"
    };
    var AudioTrackKind = {
      "alternative": "alternative",
      "descriptions": "descriptions",
      "main": "main",
      "main-desc": "main-desc",
      "translation": "translation",
      "commentary": "commentary"
    };
    var TextTrackKind = {
      subtitles: "subtitles",
      captions: "captions",
      descriptions: "descriptions",
      chapters: "chapters",
      metadata: "metadata"
    };
    var TextTrackMode = {
      disabled: "disabled",
      hidden: "hidden",
      showing: "showing"
    };
    var Track = function(_EventTarget) {
      inherits(Track2, _EventTarget);
      function Track2() {
        var _ret;
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        classCallCheck(this, Track2);
        var _this = possibleConstructorReturn(this, _EventTarget.call(this));
        var track2 = _this;
        if (IS_IE8) {
          track2 = document2.createElement("custom");
          for (var prop in Track2.prototype) {
            if (prop !== "constructor") {
              track2[prop] = Track2.prototype[prop];
            }
          }
        }
        var trackProps = {
          id: options.id || "vjs_track_" + newGUID(),
          kind: options.kind || "",
          label: options.label || "",
          language: options.language || ""
        };
        var _loop = function _loop2(key2) {
          Object.defineProperty(track2, key2, {
            get: function get$$1() {
              return trackProps[key2];
            },
            set: function set$$1() {
            }
          });
        };
        for (var key in trackProps) {
          _loop(key);
        }
        return _ret = track2, possibleConstructorReturn(_this, _ret);
      }
      return Track2;
    }(EventTarget);
    var parseUrl = function parseUrl2(url) {
      var props = ["protocol", "hostname", "port", "pathname", "search", "hash", "host"];
      var a = document2.createElement("a");
      a.href = url;
      var addToBody = a.host === "" && a.protocol !== "file:";
      var div = void 0;
      if (addToBody) {
        div = document2.createElement("div");
        div.innerHTML = '<a href="' + url + '"></a>';
        a = div.firstChild;
        div.setAttribute("style", "display:none; position:absolute;");
        document2.body.appendChild(div);
      }
      var details = {};
      for (var i2 = 0; i2 < props.length; i2++) {
        details[props[i2]] = a[props[i2]];
      }
      if (details.protocol === "http:") {
        details.host = details.host.replace(/:80$/, "");
      }
      if (details.protocol === "https:") {
        details.host = details.host.replace(/:443$/, "");
      }
      if (!details.protocol) {
        details.protocol = window2.location.protocol;
      }
      if (addToBody) {
        document2.body.removeChild(div);
      }
      return details;
    };
    var getAbsoluteURL = function getAbsoluteURL2(url) {
      if (!url.match(/^https?:\/\//)) {
        var div = document2.createElement("div");
        div.innerHTML = '<a href="' + url + '">x</a>';
        url = div.firstChild.href;
      }
      return url;
    };
    var getFileExtension = function getFileExtension2(path) {
      if (typeof path === "string") {
        var splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/i;
        var pathParts = splitPathRe.exec(path);
        if (pathParts) {
          return pathParts.pop().toLowerCase();
        }
      }
      return "";
    };
    var isCrossOrigin = function isCrossOrigin2(url) {
      var winLoc = window2.location;
      var urlInfo = parseUrl(url);
      var srcProtocol = urlInfo.protocol === ":" ? winLoc.protocol : urlInfo.protocol;
      var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;
      return crossOrigin;
    };
    var Url = (Object.freeze || Object)({
      parseUrl,
      getAbsoluteURL,
      getFileExtension,
      isCrossOrigin
    });
    var parseCues = function parseCues2(srcContent, track2) {
      var parser = new window2.WebVTT.Parser(window2, window2.vttjs, window2.WebVTT.StringDecoder());
      var errors = [];
      parser.oncue = function(cue) {
        track2.addCue(cue);
      };
      parser.onparsingerror = function(error) {
        errors.push(error);
      };
      parser.onflush = function() {
        track2.trigger({
          type: "loadeddata",
          target: track2
        });
      };
      parser.parse(srcContent);
      if (errors.length > 0) {
        if (window2.console && window2.console.groupCollapsed) {
          window2.console.groupCollapsed("Text Track parsing errors for " + track2.src);
        }
        errors.forEach(function(error) {
          return log.error(error);
        });
        if (window2.console && window2.console.groupEnd) {
          window2.console.groupEnd();
        }
      }
      parser.flush();
    };
    var loadTrack = function loadTrack2(src, track2) {
      var opts = {
        uri: src
      };
      var crossOrigin = isCrossOrigin(src);
      if (crossOrigin) {
        opts.cors = crossOrigin;
      }
      xhr(opts, bind(this, function(err, response, responseBody) {
        if (err) {
          return log.error(err, response);
        }
        track2.loaded_ = true;
        if (typeof window2.WebVTT !== "function") {
          if (track2.tech_) {
            var loadHandler = function loadHandler2() {
              return parseCues(responseBody, track2);
            };
            track2.tech_.on("vttjsloaded", loadHandler);
            track2.tech_.on("vttjserror", function() {
              log.error("vttjs failed to load, stopping trying to process " + track2.src);
              track2.tech_.off("vttjsloaded", loadHandler);
            });
          }
        } else {
          parseCues(responseBody, track2);
        }
      }));
    };
    var TextTrack = function(_Track) {
      inherits(TextTrack2, _Track);
      function TextTrack2() {
        var _this, _ret;
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        classCallCheck(this, TextTrack2);
        if (!options.tech) {
          throw new Error("A tech was not provided.");
        }
        var settings = mergeOptions(options, {
          kind: TextTrackKind[options.kind] || "subtitles",
          language: options.language || options.srclang || ""
        });
        var mode = TextTrackMode[settings.mode] || "disabled";
        var default_ = settings["default"];
        if (settings.kind === "metadata" || settings.kind === "chapters") {
          mode = "hidden";
        }
        var tt = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);
        tt.tech_ = settings.tech;
        if (IS_IE8) {
          for (var prop in TextTrack2.prototype) {
            if (prop !== "constructor") {
              tt[prop] = TextTrack2.prototype[prop];
            }
          }
        }
        tt.cues_ = [];
        tt.activeCues_ = [];
        var cues = new TextTrackCueList(tt.cues_);
        var activeCues = new TextTrackCueList(tt.activeCues_);
        var changed = false;
        var timeupdateHandler = bind(tt, function() {
          this.activeCues = this.activeCues;
          if (changed) {
            this.trigger("cuechange");
            changed = false;
          }
        });
        if (mode !== "disabled") {
          tt.tech_.ready(function() {
            tt.tech_.on("timeupdate", timeupdateHandler);
          }, true);
        }
        Object.defineProperty(tt, "default", {
          get: function get$$1() {
            return default_;
          },
          set: function set$$1() {
          }
        });
        Object.defineProperty(tt, "mode", {
          get: function get$$1() {
            return mode;
          },
          set: function set$$1(newMode) {
            var _this2 = this;
            if (!TextTrackMode[newMode]) {
              return;
            }
            mode = newMode;
            if (mode !== "disabled") {
              this.tech_.ready(function() {
                _this2.tech_.on("timeupdate", timeupdateHandler);
              }, true);
            } else {
              this.tech_.off("timeupdate", timeupdateHandler);
            }
            this.trigger("modechange");
          }
        });
        Object.defineProperty(tt, "cues", {
          get: function get$$1() {
            if (!this.loaded_) {
              return null;
            }
            return cues;
          },
          set: function set$$1() {
          }
        });
        Object.defineProperty(tt, "activeCues", {
          get: function get$$1() {
            if (!this.loaded_) {
              return null;
            }
            if (this.cues.length === 0) {
              return activeCues;
            }
            var ct = this.tech_.currentTime();
            var active = [];
            for (var i2 = 0, l = this.cues.length; i2 < l; i2++) {
              var cue = this.cues[i2];
              if (cue.startTime <= ct && cue.endTime >= ct) {
                active.push(cue);
              } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {
                active.push(cue);
              }
            }
            changed = false;
            if (active.length !== this.activeCues_.length) {
              changed = true;
            } else {
              for (var _i2 = 0; _i2 < active.length; _i2++) {
                if (this.activeCues_.indexOf(active[_i2]) === -1) {
                  changed = true;
                }
              }
            }
            this.activeCues_ = active;
            activeCues.setCues_(this.activeCues_);
            return activeCues;
          },
          // /!\ Keep this setter empty (see the timeupdate handler above)
          set: function set$$1() {
          }
        });
        if (settings.src) {
          tt.src = settings.src;
          loadTrack(settings.src, tt);
        } else {
          tt.loaded_ = true;
        }
        return _ret = tt, possibleConstructorReturn(_this, _ret);
      }
      TextTrack2.prototype.addCue = function addCue(originalCue) {
        var cue = originalCue;
        if (window2.vttjs && !(originalCue instanceof window2.vttjs.VTTCue)) {
          cue = new window2.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);
          for (var prop in originalCue) {
            if (!(prop in cue)) {
              cue[prop] = originalCue[prop];
            }
          }
          cue.id = originalCue.id;
          cue.originalCue_ = originalCue;
        }
        var tracks = this.tech_.textTracks();
        for (var i2 = 0; i2 < tracks.length; i2++) {
          if (tracks[i2] !== this) {
            tracks[i2].removeCue(cue);
          }
        }
        this.cues_.push(cue);
        this.cues.setCues_(this.cues_);
      };
      TextTrack2.prototype.removeCue = function removeCue(_removeCue) {
        var i2 = this.cues_.length;
        while (i2--) {
          var cue = this.cues_[i2];
          if (cue === _removeCue || cue.originalCue_ && cue.originalCue_ === _removeCue) {
            this.cues_.splice(i2, 1);
            this.cues.setCues_(this.cues_);
            break;
          }
        }
      };
      return TextTrack2;
    }(Track);
    TextTrack.prototype.allowedEvents_ = {
      cuechange: "cuechange"
    };
    var AudioTrack = function(_Track) {
      inherits(AudioTrack2, _Track);
      function AudioTrack2() {
        var _this, _ret;
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        classCallCheck(this, AudioTrack2);
        var settings = mergeOptions(options, {
          kind: AudioTrackKind[options.kind] || ""
        });
        var track2 = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);
        var enabled = false;
        if (IS_IE8) {
          for (var prop in AudioTrack2.prototype) {
            if (prop !== "constructor") {
              track2[prop] = AudioTrack2.prototype[prop];
            }
          }
        }
        Object.defineProperty(track2, "enabled", {
          get: function get$$1() {
            return enabled;
          },
          set: function set$$1(newEnabled) {
            if (typeof newEnabled !== "boolean" || newEnabled === enabled) {
              return;
            }
            enabled = newEnabled;
            this.trigger("enabledchange");
          }
        });
        if (settings.enabled) {
          track2.enabled = settings.enabled;
        }
        track2.loaded_ = true;
        return _ret = track2, possibleConstructorReturn(_this, _ret);
      }
      return AudioTrack2;
    }(Track);
    var VideoTrack = function(_Track) {
      inherits(VideoTrack2, _Track);
      function VideoTrack2() {
        var _this, _ret;
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        classCallCheck(this, VideoTrack2);
        var settings = mergeOptions(options, {
          kind: VideoTrackKind[options.kind] || ""
        });
        var track2 = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);
        var selected = false;
        if (IS_IE8) {
          for (var prop in VideoTrack2.prototype) {
            if (prop !== "constructor") {
              track2[prop] = VideoTrack2.prototype[prop];
            }
          }
        }
        Object.defineProperty(track2, "selected", {
          get: function get$$1() {
            return selected;
          },
          set: function set$$1(newSelected) {
            if (typeof newSelected !== "boolean" || newSelected === selected) {
              return;
            }
            selected = newSelected;
            this.trigger("selectedchange");
          }
        });
        if (settings.selected) {
          track2.selected = settings.selected;
        }
        return _ret = track2, possibleConstructorReturn(_this, _ret);
      }
      return VideoTrack2;
    }(Track);
    var NONE = 0;
    var LOADING = 1;
    var LOADED = 2;
    var ERROR = 3;
    var HTMLTrackElement = function(_EventTarget) {
      inherits(HTMLTrackElement2, _EventTarget);
      function HTMLTrackElement2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        classCallCheck(this, HTMLTrackElement2);
        var _this = possibleConstructorReturn(this, _EventTarget.call(this));
        var readyState = void 0;
        var trackElement = _this;
        if (IS_IE8) {
          trackElement = document2.createElement("custom");
          for (var prop in HTMLTrackElement2.prototype) {
            if (prop !== "constructor") {
              trackElement[prop] = HTMLTrackElement2.prototype[prop];
            }
          }
        }
        var track2 = new TextTrack(options);
        trackElement.kind = track2.kind;
        trackElement.src = track2.src;
        trackElement.srclang = track2.language;
        trackElement.label = track2.label;
        trackElement["default"] = track2["default"];
        Object.defineProperty(trackElement, "readyState", {
          get: function get$$1() {
            return readyState;
          }
        });
        Object.defineProperty(trackElement, "track", {
          get: function get$$1() {
            return track2;
          }
        });
        readyState = NONE;
        track2.addEventListener("loadeddata", function() {
          readyState = LOADED;
          trackElement.trigger({
            type: "load",
            target: trackElement
          });
        });
        if (IS_IE8) {
          var _ret;
          return _ret = trackElement, possibleConstructorReturn(_this, _ret);
        }
        return _this;
      }
      return HTMLTrackElement2;
    }(EventTarget);
    HTMLTrackElement.prototype.allowedEvents_ = {
      load: "load"
    };
    HTMLTrackElement.NONE = NONE;
    HTMLTrackElement.LOADING = LOADING;
    HTMLTrackElement.LOADED = LOADED;
    HTMLTrackElement.ERROR = ERROR;
    var NORMAL = {
      audio: {
        ListClass: AudioTrackList,
        TrackClass: AudioTrack,
        capitalName: "Audio"
      },
      video: {
        ListClass: VideoTrackList,
        TrackClass: VideoTrack,
        capitalName: "Video"
      },
      text: {
        ListClass: TextTrackList,
        TrackClass: TextTrack,
        capitalName: "Text"
      }
    };
    Object.keys(NORMAL).forEach(function(type) {
      NORMAL[type].getterName = type + "Tracks";
      NORMAL[type].privateName = type + "Tracks_";
    });
    var REMOTE = {
      remoteText: {
        ListClass: TextTrackList,
        TrackClass: TextTrack,
        capitalName: "RemoteText",
        getterName: "remoteTextTracks",
        privateName: "remoteTextTracks_"
      },
      remoteTextEl: {
        ListClass: HtmlTrackElementList,
        TrackClass: HTMLTrackElement,
        capitalName: "RemoteTextTrackEls",
        getterName: "remoteTextTrackEls",
        privateName: "remoteTextTrackEls_"
      }
    };
    var ALL = mergeOptions(NORMAL, REMOTE);
    REMOTE.names = Object.keys(REMOTE);
    NORMAL.names = Object.keys(NORMAL);
    ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);
    function createTrackHelper(self2, kind, label, language) {
      var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
      var tracks = self2.textTracks();
      options.kind = kind;
      if (label) {
        options.label = label;
      }
      if (language) {
        options.language = language;
      }
      options.tech = self2;
      var track2 = new ALL.text.TrackClass(options);
      tracks.addTrack(track2);
      return track2;
    }
    var Tech = function(_Component) {
      inherits(Tech2, _Component);
      function Tech2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var ready = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        };
        classCallCheck(this, Tech2);
        options.reportTouchActivity = false;
        var _this = possibleConstructorReturn(this, _Component.call(this, null, options, ready));
        _this.hasStarted_ = false;
        _this.on("playing", function() {
          this.hasStarted_ = true;
        });
        _this.on("loadstart", function() {
          this.hasStarted_ = false;
        });
        ALL.names.forEach(function(name) {
          var props = ALL[name];
          if (options && options[props.getterName]) {
            _this[props.privateName] = options[props.getterName];
          }
        });
        if (!_this.featuresProgressEvents) {
          _this.manualProgressOn();
        }
        if (!_this.featuresTimeupdateEvents) {
          _this.manualTimeUpdatesOn();
        }
        ["Text", "Audio", "Video"].forEach(function(track2) {
          if (options["native" + track2 + "Tracks"] === false) {
            _this["featuresNative" + track2 + "Tracks"] = false;
          }
        });
        if (options.nativeCaptions === false || options.nativeTextTracks === false) {
          _this.featuresNativeTextTracks = false;
        } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {
          _this.featuresNativeTextTracks = true;
        }
        if (!_this.featuresNativeTextTracks) {
          _this.emulateTextTracks();
        }
        _this.autoRemoteTextTracks_ = new ALL.text.ListClass();
        _this.initTrackListeners();
        if (!options.nativeControlsForTouch) {
          _this.emitTapEvents();
        }
        if (_this.constructor) {
          _this.name_ = _this.constructor.name || "Unknown Tech";
        }
        return _this;
      }
      Tech2.prototype.triggerSourceset = function triggerSourceset(src) {
        var _this2 = this;
        if (!this.isReady_) {
          this.one("ready", function() {
            return _this2.setTimeout(function() {
              return _this2.triggerSourceset(src);
            }, 1);
          });
        }
        this.trigger({
          src,
          type: "sourceset"
        });
      };
      Tech2.prototype.manualProgressOn = function manualProgressOn() {
        this.on("durationchange", this.onDurationChange);
        this.manualProgress = true;
        this.one("ready", this.trackProgress);
      };
      Tech2.prototype.manualProgressOff = function manualProgressOff() {
        this.manualProgress = false;
        this.stopTrackingProgress();
        this.off("durationchange", this.onDurationChange);
      };
      Tech2.prototype.trackProgress = function trackProgress(event2) {
        this.stopTrackingProgress();
        this.progressInterval = this.setInterval(bind(this, function() {
          var numBufferedPercent = this.bufferedPercent();
          if (this.bufferedPercent_ !== numBufferedPercent) {
            this.trigger("progress");
          }
          this.bufferedPercent_ = numBufferedPercent;
          if (numBufferedPercent === 1) {
            this.stopTrackingProgress();
          }
        }), 500);
      };
      Tech2.prototype.onDurationChange = function onDurationChange(event2) {
        this.duration_ = this.duration();
      };
      Tech2.prototype.buffered = function buffered() {
        return createTimeRanges(0, 0);
      };
      Tech2.prototype.bufferedPercent = function bufferedPercent$$1() {
        return bufferedPercent(this.buffered(), this.duration_);
      };
      Tech2.prototype.stopTrackingProgress = function stopTrackingProgress() {
        this.clearInterval(this.progressInterval);
      };
      Tech2.prototype.manualTimeUpdatesOn = function manualTimeUpdatesOn() {
        this.manualTimeUpdates = true;
        this.on("play", this.trackCurrentTime);
        this.on("pause", this.stopTrackingCurrentTime);
      };
      Tech2.prototype.manualTimeUpdatesOff = function manualTimeUpdatesOff() {
        this.manualTimeUpdates = false;
        this.stopTrackingCurrentTime();
        this.off("play", this.trackCurrentTime);
        this.off("pause", this.stopTrackingCurrentTime);
      };
      Tech2.prototype.trackCurrentTime = function trackCurrentTime() {
        if (this.currentTimeInterval) {
          this.stopTrackingCurrentTime();
        }
        this.currentTimeInterval = this.setInterval(function() {
          this.trigger({ type: "timeupdate", target: this, manuallyTriggered: true });
        }, 250);
      };
      Tech2.prototype.stopTrackingCurrentTime = function stopTrackingCurrentTime() {
        this.clearInterval(this.currentTimeInterval);
        this.trigger({ type: "timeupdate", target: this, manuallyTriggered: true });
      };
      Tech2.prototype.dispose = function dispose() {
        this.clearTracks(NORMAL.names);
        if (this.manualProgress) {
          this.manualProgressOff();
        }
        if (this.manualTimeUpdates) {
          this.manualTimeUpdatesOff();
        }
        _Component.prototype.dispose.call(this);
      };
      Tech2.prototype.clearTracks = function clearTracks(types) {
        var _this3 = this;
        types = [].concat(types);
        types.forEach(function(type) {
          var list = _this3[type + "Tracks"]() || [];
          var i2 = list.length;
          while (i2--) {
            var track2 = list[i2];
            if (type === "text") {
              _this3.removeRemoteTextTrack(track2);
            }
            list.removeTrack(track2);
          }
        });
      };
      Tech2.prototype.cleanupAutoTextTracks = function cleanupAutoTextTracks() {
        var list = this.autoRemoteTextTracks_ || [];
        var i2 = list.length;
        while (i2--) {
          var track2 = list[i2];
          this.removeRemoteTextTrack(track2);
        }
      };
      Tech2.prototype.reset = function reset() {
      };
      Tech2.prototype.error = function error(err) {
        if (err !== void 0) {
          this.error_ = new MediaError(err);
          this.trigger("error");
        }
        return this.error_;
      };
      Tech2.prototype.played = function played() {
        if (this.hasStarted_) {
          return createTimeRanges(0, 0);
        }
        return createTimeRanges();
      };
      Tech2.prototype.setCurrentTime = function setCurrentTime() {
        if (this.manualTimeUpdates) {
          this.trigger({ type: "timeupdate", target: this, manuallyTriggered: true });
        }
      };
      Tech2.prototype.initTrackListeners = function initTrackListeners() {
        var _this4 = this;
        NORMAL.names.forEach(function(name) {
          var props = NORMAL[name];
          var trackListChanges = function trackListChanges2() {
            _this4.trigger(name + "trackchange");
          };
          var tracks = _this4[props.getterName]();
          tracks.addEventListener("removetrack", trackListChanges);
          tracks.addEventListener("addtrack", trackListChanges);
          _this4.on("dispose", function() {
            tracks.removeEventListener("removetrack", trackListChanges);
            tracks.removeEventListener("addtrack", trackListChanges);
          });
        });
      };
      Tech2.prototype.addWebVttScript_ = function addWebVttScript_() {
        var _this5 = this;
        if (window2.WebVTT) {
          return;
        }
        if (document2.body.contains(this.el())) {
          if (!this.options_["vtt.js"] && isPlain(vtt) && Object.keys(vtt).length > 0) {
            this.trigger("vttjsloaded");
            return;
          }
          var script = document2.createElement("script");
          script.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.12.4/vtt.min.js";
          script.onload = function() {
            _this5.trigger("vttjsloaded");
          };
          script.onerror = function() {
            _this5.trigger("vttjserror");
          };
          this.on("dispose", function() {
            script.onload = null;
            script.onerror = null;
          });
          window2.WebVTT = true;
          this.el().parentNode.appendChild(script);
        } else {
          this.ready(this.addWebVttScript_);
        }
      };
      Tech2.prototype.emulateTextTracks = function emulateTextTracks() {
        var _this6 = this;
        var tracks = this.textTracks();
        var remoteTracks = this.remoteTextTracks();
        var handleAddTrack = function handleAddTrack2(e) {
          return tracks.addTrack(e.track);
        };
        var handleRemoveTrack = function handleRemoveTrack2(e) {
          return tracks.removeTrack(e.track);
        };
        remoteTracks.on("addtrack", handleAddTrack);
        remoteTracks.on("removetrack", handleRemoveTrack);
        this.addWebVttScript_();
        var updateDisplay = function updateDisplay2() {
          return _this6.trigger("texttrackchange");
        };
        var textTracksChanges = function textTracksChanges2() {
          updateDisplay();
          for (var i2 = 0; i2 < tracks.length; i2++) {
            var track2 = tracks[i2];
            track2.removeEventListener("cuechange", updateDisplay);
            if (track2.mode === "showing") {
              track2.addEventListener("cuechange", updateDisplay);
            }
          }
        };
        textTracksChanges();
        tracks.addEventListener("change", textTracksChanges);
        tracks.addEventListener("addtrack", textTracksChanges);
        tracks.addEventListener("removetrack", textTracksChanges);
        this.on("dispose", function() {
          remoteTracks.off("addtrack", handleAddTrack);
          remoteTracks.off("removetrack", handleRemoveTrack);
          tracks.removeEventListener("change", textTracksChanges);
          tracks.removeEventListener("addtrack", textTracksChanges);
          tracks.removeEventListener("removetrack", textTracksChanges);
          for (var i2 = 0; i2 < tracks.length; i2++) {
            var track2 = tracks[i2];
            track2.removeEventListener("cuechange", updateDisplay);
          }
        });
      };
      Tech2.prototype.addTextTrack = function addTextTrack(kind, label, language) {
        if (!kind) {
          throw new Error("TextTrack kind is required but was not provided");
        }
        return createTrackHelper(this, kind, label, language);
      };
      Tech2.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {
        var track2 = mergeOptions(options, {
          tech: this
        });
        return new REMOTE.remoteTextEl.TrackClass(track2);
      };
      Tech2.prototype.addRemoteTextTrack = function addRemoteTextTrack() {
        var _this7 = this;
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var manualCleanup = arguments[1];
        var htmlTrackElement = this.createRemoteTextTrack(options);
        if (manualCleanup !== true && manualCleanup !== false) {
          log.warn('Calling addRemoteTextTrack without explicitly setting the "manualCleanup" parameter to `true` is deprecated and default to `false` in future version of video.js');
          manualCleanup = true;
        }
        this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
        this.remoteTextTracks().addTrack(htmlTrackElement.track);
        if (manualCleanup !== true) {
          this.ready(function() {
            return _this7.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);
          });
        }
        return htmlTrackElement;
      };
      Tech2.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track2) {
        var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track2);
        this.remoteTextTrackEls().removeTrackElement_(trackElement);
        this.remoteTextTracks().removeTrack(track2);
        this.autoRemoteTextTracks_.removeTrack(track2);
      };
      Tech2.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
        return {};
      };
      Tech2.prototype.setPoster = function setPoster() {
      };
      Tech2.prototype.playsinline = function playsinline() {
      };
      Tech2.prototype.setPlaysinline = function setPlaysinline() {
      };
      Tech2.prototype.canPlayType = function canPlayType2() {
        return "";
      };
      Tech2.canPlayType = function canPlayType2() {
        return "";
      };
      Tech2.canPlaySource = function canPlaySource(srcObj, options) {
        return Tech2.canPlayType(srcObj.type);
      };
      Tech2.isTech = function isTech(component) {
        return component.prototype instanceof Tech2 || component instanceof Tech2 || component === Tech2;
      };
      Tech2.registerTech = function registerTech(name, tech) {
        if (!Tech2.techs_) {
          Tech2.techs_ = {};
        }
        if (!Tech2.isTech(tech)) {
          throw new Error("Tech " + name + " must be a Tech");
        }
        if (!Tech2.canPlayType) {
          throw new Error("Techs must have a static canPlayType method on them");
        }
        if (!Tech2.canPlaySource) {
          throw new Error("Techs must have a static canPlaySource method on them");
        }
        name = toTitleCase(name);
        Tech2.techs_[name] = tech;
        if (name !== "Tech") {
          Tech2.defaultTechOrder_.push(name);
        }
        return tech;
      };
      Tech2.getTech = function getTech(name) {
        if (!name) {
          return;
        }
        name = toTitleCase(name);
        if (Tech2.techs_ && Tech2.techs_[name]) {
          return Tech2.techs_[name];
        }
        if (window2 && window2.videojs && window2.videojs[name]) {
          log.warn("The " + name + " tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)");
          return window2.videojs[name];
        }
      };
      return Tech2;
    }(Component);
    ALL.names.forEach(function(name) {
      var props = ALL[name];
      Tech.prototype[props.getterName] = function() {
        this[props.privateName] = this[props.privateName] || new props.ListClass();
        return this[props.privateName];
      };
    });
    Tech.prototype.featuresVolumeControl = true;
    Tech.prototype.featuresMuteControl = true;
    Tech.prototype.featuresFullscreenResize = false;
    Tech.prototype.featuresPlaybackRate = false;
    Tech.prototype.featuresProgressEvents = false;
    Tech.prototype.featuresSourceset = false;
    Tech.prototype.featuresTimeupdateEvents = false;
    Tech.prototype.featuresNativeTextTracks = false;
    Tech.withSourceHandlers = function(_Tech) {
      _Tech.registerSourceHandler = function(handler, index) {
        var handlers = _Tech.sourceHandlers;
        if (!handlers) {
          handlers = _Tech.sourceHandlers = [];
        }
        if (index === void 0) {
          index = handlers.length;
        }
        handlers.splice(index, 0, handler);
      };
      _Tech.canPlayType = function(type) {
        var handlers = _Tech.sourceHandlers || [];
        var can = void 0;
        for (var i2 = 0; i2 < handlers.length; i2++) {
          can = handlers[i2].canPlayType(type);
          if (can) {
            return can;
          }
        }
        return "";
      };
      _Tech.selectSourceHandler = function(source, options) {
        var handlers = _Tech.sourceHandlers || [];
        var can = void 0;
        for (var i2 = 0; i2 < handlers.length; i2++) {
          can = handlers[i2].canHandleSource(source, options);
          if (can) {
            return handlers[i2];
          }
        }
        return null;
      };
      _Tech.canPlaySource = function(srcObj, options) {
        var sh = _Tech.selectSourceHandler(srcObj, options);
        if (sh) {
          return sh.canHandleSource(srcObj, options);
        }
        return "";
      };
      var deferrable = ["seekable", "seeking", "duration"];
      deferrable.forEach(function(fnName) {
        var originalFn = this[fnName];
        if (typeof originalFn !== "function") {
          return;
        }
        this[fnName] = function() {
          if (this.sourceHandler_ && this.sourceHandler_[fnName]) {
            return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
          }
          return originalFn.apply(this, arguments);
        };
      }, _Tech.prototype);
      _Tech.prototype.setSource = function(source) {
        var sh = _Tech.selectSourceHandler(source, this.options_);
        if (!sh) {
          if (_Tech.nativeSourceHandler) {
            sh = _Tech.nativeSourceHandler;
          } else {
            log.error("No source hander found for the current source.");
          }
        }
        this.disposeSourceHandler();
        this.off("dispose", this.disposeSourceHandler);
        if (sh !== _Tech.nativeSourceHandler) {
          this.currentSource_ = source;
        }
        this.sourceHandler_ = sh.handleSource(source, this, this.options_);
        this.on("dispose", this.disposeSourceHandler);
      };
      _Tech.prototype.disposeSourceHandler = function() {
        if (this.currentSource_) {
          this.clearTracks(["audio", "video"]);
          this.currentSource_ = null;
        }
        this.cleanupAutoTextTracks();
        if (this.sourceHandler_) {
          if (this.sourceHandler_.dispose) {
            this.sourceHandler_.dispose();
          }
          this.sourceHandler_ = null;
        }
      };
    };
    Component.registerComponent("Tech", Tech);
    Tech.registerTech("Tech", Tech);
    Tech.defaultTechOrder_ = [];
    var middlewares = {};
    var middlewareInstances = {};
    var TERMINATOR = {};
    function use(type, middleware) {
      middlewares[type] = middlewares[type] || [];
      middlewares[type].push(middleware);
    }
    function setSource(player, src, next) {
      player.setTimeout(function() {
        return setSourceHelper(src, middlewares[src.type], next, player);
      }, 1);
    }
    function setTech(middleware, tech) {
      middleware.forEach(function(mw) {
        return mw.setTech && mw.setTech(tech);
      });
    }
    function get$1(middleware, tech, method) {
      return middleware.reduceRight(middlewareIterator(method), tech[method]());
    }
    function set$1(middleware, tech, method, arg) {
      return tech[method](middleware.reduce(middlewareIterator(method), arg));
    }
    function mediate(middleware, tech, method) {
      var arg = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      var callMethod = "call" + toTitleCase(method);
      var middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);
      var terminated = middlewareValue === TERMINATOR;
      var returnValue = terminated ? null : tech[method](middlewareValue);
      executeRight(middleware, method, returnValue, terminated);
      return returnValue;
    }
    var allowedGetters = {
      buffered: 1,
      currentTime: 1,
      duration: 1,
      seekable: 1,
      played: 1,
      paused: 1
    };
    var allowedSetters = {
      setCurrentTime: 1
    };
    var allowedMediators = {
      play: 1,
      pause: 1
    };
    function middlewareIterator(method) {
      return function(value, mw) {
        if (value === TERMINATOR) {
          return TERMINATOR;
        }
        if (mw[method]) {
          return mw[method](value);
        }
        return value;
      };
    }
    function executeRight(mws, method, value, terminated) {
      for (var i2 = mws.length - 1; i2 >= 0; i2--) {
        var mw = mws[i2];
        if (mw[method]) {
          mw[method](terminated, value);
        }
      }
    }
    function clearCacheForPlayer(player) {
      middlewareInstances[player.id()] = null;
    }
    function getOrCreateFactory(player, mwFactory) {
      var mws = middlewareInstances[player.id()];
      var mw = null;
      if (mws === void 0 || mws === null) {
        mw = mwFactory(player);
        middlewareInstances[player.id()] = [[mwFactory, mw]];
        return mw;
      }
      for (var i2 = 0; i2 < mws.length; i2++) {
        var _mws$i = mws[i2], mwf = _mws$i[0], mwi = _mws$i[1];
        if (mwf !== mwFactory) {
          continue;
        }
        mw = mwi;
      }
      if (mw === null) {
        mw = mwFactory(player);
        mws.push([mwFactory, mw]);
      }
      return mw;
    }
    function setSourceHelper() {
      var src = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var middleware = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var next = arguments[2];
      var player = arguments[3];
      var acc = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
      var lastRun = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
      var mwFactory = middleware[0], mwrest = middleware.slice(1);
      if (typeof mwFactory === "string") {
        setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);
      } else if (mwFactory) {
        var mw = getOrCreateFactory(player, mwFactory);
        if (!mw.setSource) {
          acc.push(mw);
          return setSourceHelper(src, mwrest, next, player, acc, lastRun);
        }
        mw.setSource(assign({}, src), function(err, _src) {
          if (err) {
            return setSourceHelper(src, mwrest, next, player, acc, lastRun);
          }
          acc.push(mw);
          setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);
        });
      } else if (mwrest.length) {
        setSourceHelper(src, mwrest, next, player, acc, lastRun);
      } else if (lastRun) {
        next(src, acc);
      } else {
        setSourceHelper(src, middlewares["*"], next, player, acc, true);
      }
    }
    var MimetypesKind = {
      opus: "video/ogg",
      ogv: "video/ogg",
      mp4: "video/mp4",
      mov: "video/mp4",
      m4v: "video/mp4",
      mkv: "video/x-matroska",
      mp3: "audio/mpeg",
      aac: "audio/aac",
      oga: "audio/ogg",
      m3u8: "application/x-mpegURL"
    };
    var getMimetype = function getMimetype2() {
      var src = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var ext = getFileExtension(src);
      var mimetype = MimetypesKind[ext.toLowerCase()];
      return mimetype || "";
    };
    var findMimetype = function findMimetype2(player, src) {
      if (!src) {
        return "";
      }
      if (player.cache_.source.src === src && player.cache_.source.type) {
        return player.cache_.source.type;
      }
      var matchingSources = player.cache_.sources.filter(function(s2) {
        return s2.src === src;
      });
      if (matchingSources.length) {
        return matchingSources[0].type;
      }
      var sources = player.$$("source");
      for (var i2 = 0; i2 < sources.length; i2++) {
        var s = sources[i2];
        if (s.type && s.src && s.src === src) {
          return s.type;
        }
      }
      return getMimetype(src);
    };
    var filterSource = function filterSource2(src) {
      if (Array.isArray(src)) {
        var newsrc = [];
        src.forEach(function(srcobj) {
          srcobj = filterSource2(srcobj);
          if (Array.isArray(srcobj)) {
            newsrc = newsrc.concat(srcobj);
          } else if (isObject(srcobj)) {
            newsrc.push(srcobj);
          }
        });
        src = newsrc;
      } else if (typeof src === "string" && src.trim()) {
        src = [fixSource({ src })];
      } else if (isObject(src) && typeof src.src === "string" && src.src && src.src.trim()) {
        src = [fixSource(src)];
      } else {
        src = [];
      }
      return src;
    };
    function fixSource(src) {
      var mimetype = getMimetype(src.src);
      if (!src.type && mimetype) {
        src.type = mimetype;
      }
      return src;
    }
    var MediaLoader = function(_Component) {
      inherits(MediaLoader2, _Component);
      function MediaLoader2(player, options, ready) {
        classCallCheck(this, MediaLoader2);
        var options_ = mergeOptions({ createEl: false }, options);
        var _this = possibleConstructorReturn(this, _Component.call(this, player, options_, ready));
        if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {
          for (var i2 = 0, j = options.playerOptions.techOrder; i2 < j.length; i2++) {
            var techName = toTitleCase(j[i2]);
            var tech = Tech.getTech(techName);
            if (!techName) {
              tech = Component.getComponent(techName);
            }
            if (tech && tech.isSupported()) {
              player.loadTech_(techName);
              break;
            }
          }
        } else {
          player.src(options.playerOptions.sources);
        }
        return _this;
      }
      return MediaLoader2;
    }(Component);
    Component.registerComponent("MediaLoader", MediaLoader);
    var ClickableComponent = function(_Component) {
      inherits(ClickableComponent2, _Component);
      function ClickableComponent2(player, options) {
        classCallCheck(this, ClickableComponent2);
        var _this = possibleConstructorReturn(this, _Component.call(this, player, options));
        _this.emitTapEvents();
        _this.enable();
        return _this;
      }
      ClickableComponent2.prototype.createEl = function createEl$$1() {
        var tag = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "div";
        var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        props = assign({
          innerHTML: '<span aria-hidden="true" class="vjs-icon-placeholder"></span>',
          className: this.buildCSSClass(),
          tabIndex: 0
        }, props);
        if (tag === "button") {
          log.error("Creating a ClickableComponent with an HTML element of " + tag + " is not supported; use a Button instead.");
        }
        attributes = assign({
          role: "button"
        }, attributes);
        this.tabIndex_ = props.tabIndex;
        var el = _Component.prototype.createEl.call(this, tag, props, attributes);
        this.createControlTextEl(el);
        return el;
      };
      ClickableComponent2.prototype.dispose = function dispose() {
        this.controlTextEl_ = null;
        _Component.prototype.dispose.call(this);
      };
      ClickableComponent2.prototype.createControlTextEl = function createControlTextEl(el) {
        this.controlTextEl_ = createEl("span", {
          className: "vjs-control-text"
        }, {
          // let the screen reader user know that the text of the element may change
          "aria-live": "polite"
        });
        if (el) {
          el.appendChild(this.controlTextEl_);
        }
        this.controlText(this.controlText_, el);
        return this.controlTextEl_;
      };
      ClickableComponent2.prototype.controlText = function controlText(text) {
        var el = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.el();
        if (text === void 0) {
          return this.controlText_ || "Need Text";
        }
        var localizedText = this.localize(text);
        this.controlText_ = text;
        textContent(this.controlTextEl_, localizedText);
        if (!this.nonIconControl) {
          el.setAttribute("title", localizedText);
        }
      };
      ClickableComponent2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-control vjs-button " + _Component.prototype.buildCSSClass.call(this);
      };
      ClickableComponent2.prototype.enable = function enable() {
        if (!this.enabled_) {
          this.enabled_ = true;
          this.removeClass("vjs-disabled");
          this.el_.setAttribute("aria-disabled", "false");
          if (typeof this.tabIndex_ !== "undefined") {
            this.el_.setAttribute("tabIndex", this.tabIndex_);
          }
          this.on(["tap", "click"], this.handleClick);
          this.on("focus", this.handleFocus);
          this.on("blur", this.handleBlur);
        }
      };
      ClickableComponent2.prototype.disable = function disable() {
        this.enabled_ = false;
        this.addClass("vjs-disabled");
        this.el_.setAttribute("aria-disabled", "true");
        if (typeof this.tabIndex_ !== "undefined") {
          this.el_.removeAttribute("tabIndex");
        }
        this.off(["tap", "click"], this.handleClick);
        this.off("focus", this.handleFocus);
        this.off("blur", this.handleBlur);
      };
      ClickableComponent2.prototype.handleClick = function handleClick(event2) {
      };
      ClickableComponent2.prototype.handleFocus = function handleFocus(event2) {
        on(document2, "keydown", bind(this, this.handleKeyPress));
      };
      ClickableComponent2.prototype.handleKeyPress = function handleKeyPress(event2) {
        if (event2.which === 32 || event2.which === 13) {
          event2.preventDefault();
          this.trigger("click");
        } else if (_Component.prototype.handleKeyPress) {
          _Component.prototype.handleKeyPress.call(this, event2);
        }
      };
      ClickableComponent2.prototype.handleBlur = function handleBlur(event2) {
        off(document2, "keydown", bind(this, this.handleKeyPress));
      };
      return ClickableComponent2;
    }(Component);
    Component.registerComponent("ClickableComponent", ClickableComponent);
    var PosterImage = function(_ClickableComponent) {
      inherits(PosterImage2, _ClickableComponent);
      function PosterImage2(player, options) {
        classCallCheck(this, PosterImage2);
        var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));
        _this.update();
        player.on("posterchange", bind(_this, _this.update));
        return _this;
      }
      PosterImage2.prototype.dispose = function dispose() {
        this.player().off("posterchange", this.update);
        _ClickableComponent.prototype.dispose.call(this);
      };
      PosterImage2.prototype.createEl = function createEl$$1() {
        var el = createEl("div", {
          className: "vjs-poster",
          // Don't want poster to be tabbable.
          tabIndex: -1
        });
        if (!BACKGROUND_SIZE_SUPPORTED) {
          this.fallbackImg_ = createEl("img");
          el.appendChild(this.fallbackImg_);
        }
        return el;
      };
      PosterImage2.prototype.update = function update(event2) {
        var url = this.player().poster();
        this.setSrc(url);
        if (url) {
          this.show();
        } else {
          this.hide();
        }
      };
      PosterImage2.prototype.setSrc = function setSrc(url) {
        if (this.fallbackImg_) {
          this.fallbackImg_.src = url;
        } else {
          var backgroundImage = "";
          if (url) {
            backgroundImage = 'url("' + url + '")';
          }
          this.el_.style.backgroundImage = backgroundImage;
        }
      };
      PosterImage2.prototype.handleClick = function handleClick(event2) {
        if (!this.player_.controls()) {
          return;
        }
        if (this.player_.paused()) {
          silencePromise(this.player_.play());
        } else {
          this.player_.pause();
        }
      };
      return PosterImage2;
    }(ClickableComponent);
    Component.registerComponent("PosterImage", PosterImage);
    var darkGray = "#222";
    var lightGray = "#ccc";
    var fontMap = {
      monospace: "monospace",
      sansSerif: "sans-serif",
      serif: "serif",
      monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
      monospaceSerif: '"Courier New", monospace',
      proportionalSansSerif: "sans-serif",
      proportionalSerif: "serif",
      casual: '"Comic Sans MS", Impact, fantasy',
      script: '"Monotype Corsiva", cursive',
      smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
    };
    function constructColor(color, opacity) {
      var hex = void 0;
      if (color.length === 4) {
        hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
      } else if (color.length === 7) {
        hex = color.slice(1);
      } else {
        throw new Error("Invalid color code provided, " + color + "; must be formatted as e.g. #f0e or #f604e2.");
      }
      return "rgba(" + parseInt(hex.slice(0, 2), 16) + "," + parseInt(hex.slice(2, 4), 16) + "," + parseInt(hex.slice(4, 6), 16) + "," + opacity + ")";
    }
    function tryUpdateStyle(el, style2, rule) {
      try {
        el.style[style2] = rule;
      } catch (e) {
        return;
      }
    }
    var TextTrackDisplay = function(_Component) {
      inherits(TextTrackDisplay2, _Component);
      function TextTrackDisplay2(player, options, ready) {
        classCallCheck(this, TextTrackDisplay2);
        var _this = possibleConstructorReturn(this, _Component.call(this, player, options, ready));
        var updateDisplayHandler = bind(_this, _this.updateDisplay);
        player.on("loadstart", bind(_this, _this.toggleDisplay));
        player.on("texttrackchange", updateDisplayHandler);
        player.on("loadstart", bind(_this, _this.preselectTrack));
        player.ready(bind(_this, function() {
          if (player.tech_ && player.tech_.featuresNativeTextTracks) {
            this.hide();
            return;
          }
          player.on("fullscreenchange", updateDisplayHandler);
          player.on("playerresize", updateDisplayHandler);
          if (window2.addEventListener) {
            window2.addEventListener("orientationchange", updateDisplayHandler);
          }
          player.on("dispose", function() {
            return window2.removeEventListener("orientationchange", updateDisplayHandler);
          });
          var tracks = this.options_.playerOptions.tracks || [];
          for (var i2 = 0; i2 < tracks.length; i2++) {
            this.player_.addRemoteTextTrack(tracks[i2], true);
          }
          this.preselectTrack();
        }));
        return _this;
      }
      TextTrackDisplay2.prototype.preselectTrack = function preselectTrack() {
        var modes = { captions: 1, subtitles: 1 };
        var trackList = this.player_.textTracks();
        var userPref = this.player_.cache_.selectedLanguage;
        var firstDesc = void 0;
        var firstCaptions = void 0;
        var preferredTrack = void 0;
        for (var i2 = 0; i2 < trackList.length; i2++) {
          var track2 = trackList[i2];
          if (userPref && userPref.enabled && userPref.language === track2.language) {
            if (track2.kind === userPref.kind) {
              preferredTrack = track2;
            } else if (!preferredTrack) {
              preferredTrack = track2;
            }
          } else if (userPref && !userPref.enabled) {
            preferredTrack = null;
            firstDesc = null;
            firstCaptions = null;
          } else if (track2["default"]) {
            if (track2.kind === "descriptions" && !firstDesc) {
              firstDesc = track2;
            } else if (track2.kind in modes && !firstCaptions) {
              firstCaptions = track2;
            }
          }
        }
        if (preferredTrack) {
          preferredTrack.mode = "showing";
        } else if (firstCaptions) {
          firstCaptions.mode = "showing";
        } else if (firstDesc) {
          firstDesc.mode = "showing";
        }
      };
      TextTrackDisplay2.prototype.toggleDisplay = function toggleDisplay() {
        if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {
          this.hide();
        } else {
          this.show();
        }
      };
      TextTrackDisplay2.prototype.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-text-track-display"
        }, {
          "aria-live": "off",
          "aria-atomic": "true"
        });
      };
      TextTrackDisplay2.prototype.clearDisplay = function clearDisplay() {
        if (typeof window2.WebVTT === "function") {
          window2.WebVTT.processCues(window2, [], this.el_);
        }
      };
      TextTrackDisplay2.prototype.updateDisplay = function updateDisplay() {
        var tracks = this.player_.textTracks();
        this.clearDisplay();
        var descriptionsTrack = null;
        var captionsSubtitlesTrack = null;
        var i2 = tracks.length;
        while (i2--) {
          var track2 = tracks[i2];
          if (track2.mode === "showing") {
            if (track2.kind === "descriptions") {
              descriptionsTrack = track2;
            } else {
              captionsSubtitlesTrack = track2;
            }
          }
        }
        if (captionsSubtitlesTrack) {
          if (this.getAttribute("aria-live") !== "off") {
            this.setAttribute("aria-live", "off");
          }
          this.updateForTrack(captionsSubtitlesTrack);
        } else if (descriptionsTrack) {
          if (this.getAttribute("aria-live") !== "assertive") {
            this.setAttribute("aria-live", "assertive");
          }
          this.updateForTrack(descriptionsTrack);
        }
      };
      TextTrackDisplay2.prototype.updateForTrack = function updateForTrack(track2) {
        if (typeof window2.WebVTT !== "function" || !track2.activeCues) {
          return;
        }
        var cues = [];
        for (var _i2 = 0; _i2 < track2.activeCues.length; _i2++) {
          cues.push(track2.activeCues[_i2]);
        }
        window2.WebVTT.processCues(window2, cues, this.el_);
        if (!this.player_.textTrackSettings) {
          return;
        }
        var overrides = this.player_.textTrackSettings.getValues();
        var i2 = cues.length;
        while (i2--) {
          var cue = cues[i2];
          if (!cue) {
            continue;
          }
          var cueDiv = cue.displayState;
          if (overrides.color) {
            cueDiv.firstChild.style.color = overrides.color;
          }
          if (overrides.textOpacity) {
            tryUpdateStyle(cueDiv.firstChild, "color", constructColor(overrides.color || "#fff", overrides.textOpacity));
          }
          if (overrides.backgroundColor) {
            cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
          }
          if (overrides.backgroundOpacity) {
            tryUpdateStyle(cueDiv.firstChild, "backgroundColor", constructColor(overrides.backgroundColor || "#000", overrides.backgroundOpacity));
          }
          if (overrides.windowColor) {
            if (overrides.windowOpacity) {
              tryUpdateStyle(cueDiv, "backgroundColor", constructColor(overrides.windowColor, overrides.windowOpacity));
            } else {
              cueDiv.style.backgroundColor = overrides.windowColor;
            }
          }
          if (overrides.edgeStyle) {
            if (overrides.edgeStyle === "dropshadow") {
              cueDiv.firstChild.style.textShadow = "2px 2px 3px " + darkGray + ", 2px 2px 4px " + darkGray + ", 2px 2px 5px " + darkGray;
            } else if (overrides.edgeStyle === "raised") {
              cueDiv.firstChild.style.textShadow = "1px 1px " + darkGray + ", 2px 2px " + darkGray + ", 3px 3px " + darkGray;
            } else if (overrides.edgeStyle === "depressed") {
              cueDiv.firstChild.style.textShadow = "1px 1px " + lightGray + ", 0 1px " + lightGray + ", -1px -1px " + darkGray + ", 0 -1px " + darkGray;
            } else if (overrides.edgeStyle === "uniform") {
              cueDiv.firstChild.style.textShadow = "0 0 4px " + darkGray + ", 0 0 4px " + darkGray + ", 0 0 4px " + darkGray + ", 0 0 4px " + darkGray;
            }
          }
          if (overrides.fontPercent && overrides.fontPercent !== 1) {
            var fontSize = window2.parseFloat(cueDiv.style.fontSize);
            cueDiv.style.fontSize = fontSize * overrides.fontPercent + "px";
            cueDiv.style.height = "auto";
            cueDiv.style.top = "auto";
            cueDiv.style.bottom = "2px";
          }
          if (overrides.fontFamily && overrides.fontFamily !== "default") {
            if (overrides.fontFamily === "small-caps") {
              cueDiv.firstChild.style.fontVariant = "small-caps";
            } else {
              cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
            }
          }
        }
      };
      return TextTrackDisplay2;
    }(Component);
    Component.registerComponent("TextTrackDisplay", TextTrackDisplay);
    var LoadingSpinner = function(_Component) {
      inherits(LoadingSpinner2, _Component);
      function LoadingSpinner2() {
        classCallCheck(this, LoadingSpinner2);
        return possibleConstructorReturn(this, _Component.apply(this, arguments));
      }
      LoadingSpinner2.prototype.createEl = function createEl$$1() {
        var isAudio = this.player_.isAudio();
        var playerType = this.localize(isAudio ? "Audio Player" : "Video Player");
        var controlText = createEl("span", {
          className: "vjs-control-text",
          innerHTML: this.localize("{1} is loading.", [playerType])
        });
        var el = _Component.prototype.createEl.call(this, "div", {
          className: "vjs-loading-spinner",
          dir: "ltr"
        });
        el.appendChild(controlText);
        return el;
      };
      return LoadingSpinner2;
    }(Component);
    Component.registerComponent("LoadingSpinner", LoadingSpinner);
    var Button = function(_ClickableComponent) {
      inherits(Button2, _ClickableComponent);
      function Button2() {
        classCallCheck(this, Button2);
        return possibleConstructorReturn(this, _ClickableComponent.apply(this, arguments));
      }
      Button2.prototype.createEl = function createEl2(tag) {
        var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        tag = "button";
        props = assign({
          innerHTML: '<span aria-hidden="true" class="vjs-icon-placeholder"></span>',
          className: this.buildCSSClass()
        }, props);
        attributes = assign({
          // Necessary since the default button type is "submit"
          type: "button"
        }, attributes);
        var el = Component.prototype.createEl.call(this, tag, props, attributes);
        this.createControlTextEl(el);
        return el;
      };
      Button2.prototype.addChild = function addChild(child) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var className = this.constructor.name;
        log.warn("Adding an actionable (user controllable) child to a Button (" + className + ") is not supported; use a ClickableComponent instead.");
        return Component.prototype.addChild.call(this, child, options);
      };
      Button2.prototype.enable = function enable() {
        _ClickableComponent.prototype.enable.call(this);
        this.el_.removeAttribute("disabled");
      };
      Button2.prototype.disable = function disable() {
        _ClickableComponent.prototype.disable.call(this);
        this.el_.setAttribute("disabled", "disabled");
      };
      Button2.prototype.handleKeyPress = function handleKeyPress(event2) {
        if (event2.which === 32 || event2.which === 13) {
          return;
        }
        _ClickableComponent.prototype.handleKeyPress.call(this, event2);
      };
      return Button2;
    }(ClickableComponent);
    Component.registerComponent("Button", Button);
    var BigPlayButton = function(_Button) {
      inherits(BigPlayButton2, _Button);
      function BigPlayButton2(player, options) {
        classCallCheck(this, BigPlayButton2);
        var _this = possibleConstructorReturn(this, _Button.call(this, player, options));
        _this.mouseused_ = false;
        _this.on("mousedown", _this.handleMouseDown);
        return _this;
      }
      BigPlayButton2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-big-play-button";
      };
      BigPlayButton2.prototype.handleClick = function handleClick(event2) {
        var playPromise = this.player_.play();
        if (this.mouseused_ && event2.clientX && event2.clientY) {
          silencePromise(playPromise);
          return;
        }
        var cb = this.player_.getChild("controlBar");
        var playToggle = cb && cb.getChild("playToggle");
        if (!playToggle) {
          this.player_.focus();
          return;
        }
        var playFocus = function playFocus2() {
          return playToggle.focus();
        };
        if (isPromise(playPromise)) {
          playPromise.then(playFocus, function() {
          });
        } else {
          this.setTimeout(playFocus, 1);
        }
      };
      BigPlayButton2.prototype.handleKeyPress = function handleKeyPress(event2) {
        this.mouseused_ = false;
        _Button.prototype.handleKeyPress.call(this, event2);
      };
      BigPlayButton2.prototype.handleMouseDown = function handleMouseDown(event2) {
        this.mouseused_ = true;
      };
      return BigPlayButton2;
    }(Button);
    BigPlayButton.prototype.controlText_ = "Play Video";
    Component.registerComponent("BigPlayButton", BigPlayButton);
    var CloseButton = function(_Button) {
      inherits(CloseButton2, _Button);
      function CloseButton2(player, options) {
        classCallCheck(this, CloseButton2);
        var _this = possibleConstructorReturn(this, _Button.call(this, player, options));
        _this.controlText(options && options.controlText || _this.localize("Close"));
        return _this;
      }
      CloseButton2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-close-button " + _Button.prototype.buildCSSClass.call(this);
      };
      CloseButton2.prototype.handleClick = function handleClick(event2) {
        this.trigger({ type: "close", bubbles: false });
      };
      return CloseButton2;
    }(Button);
    Component.registerComponent("CloseButton", CloseButton);
    var PlayToggle = function(_Button) {
      inherits(PlayToggle2, _Button);
      function PlayToggle2(player, options) {
        classCallCheck(this, PlayToggle2);
        var _this = possibleConstructorReturn(this, _Button.call(this, player, options));
        _this.on(player, "play", _this.handlePlay);
        _this.on(player, "pause", _this.handlePause);
        _this.on(player, "ended", _this.handleEnded);
        return _this;
      }
      PlayToggle2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-play-control " + _Button.prototype.buildCSSClass.call(this);
      };
      PlayToggle2.prototype.handleClick = function handleClick(event2) {
        if (this.player_.paused()) {
          this.player_.play();
        } else {
          this.player_.pause();
        }
      };
      PlayToggle2.prototype.handleSeeked = function handleSeeked(event2) {
        this.removeClass("vjs-ended");
        if (this.player_.paused()) {
          this.handlePause(event2);
        } else {
          this.handlePlay(event2);
        }
      };
      PlayToggle2.prototype.handlePlay = function handlePlay(event2) {
        this.removeClass("vjs-ended");
        this.removeClass("vjs-paused");
        this.addClass("vjs-playing");
        this.controlText("Pause");
      };
      PlayToggle2.prototype.handlePause = function handlePause(event2) {
        this.removeClass("vjs-playing");
        this.addClass("vjs-paused");
        this.controlText("Play");
      };
      PlayToggle2.prototype.handleEnded = function handleEnded(event2) {
        this.removeClass("vjs-playing");
        this.addClass("vjs-ended");
        this.controlText("Replay");
        this.one(this.player_, "seeked", this.handleSeeked);
      };
      return PlayToggle2;
    }(Button);
    PlayToggle.prototype.controlText_ = "Play";
    Component.registerComponent("PlayToggle", PlayToggle);
    var defaultImplementation = function defaultImplementation2(seconds, guide) {
      seconds = seconds < 0 ? 0 : seconds;
      var s = Math.floor(seconds % 60);
      var m = Math.floor(seconds / 60 % 60);
      var h = Math.floor(seconds / 3600);
      var gm = Math.floor(guide / 60 % 60);
      var gh = Math.floor(guide / 3600);
      if (isNaN(seconds) || seconds === Infinity) {
        h = m = s = "-";
      }
      h = h > 0 || gh > 0 ? h + ":" : "";
      m = ((h || gm >= 10) && m < 10 ? "0" + m : m) + ":";
      s = s < 10 ? "0" + s : s;
      return h + m + s;
    };
    var implementation = defaultImplementation;
    function setFormatTime(customImplementation) {
      implementation = customImplementation;
    }
    function resetFormatTime() {
      implementation = defaultImplementation;
    }
    var formatTime = function(seconds) {
      var guide = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : seconds;
      return implementation(seconds, guide);
    };
    var TimeDisplay = function(_Component) {
      inherits(TimeDisplay2, _Component);
      function TimeDisplay2(player, options) {
        classCallCheck(this, TimeDisplay2);
        var _this = possibleConstructorReturn(this, _Component.call(this, player, options));
        _this.throttledUpdateContent = throttle(bind(_this, _this.updateContent), 25);
        _this.on(player, "timeupdate", _this.throttledUpdateContent);
        return _this;
      }
      TimeDisplay2.prototype.createEl = function createEl$$1(plainName) {
        var className = this.buildCSSClass();
        var el = _Component.prototype.createEl.call(this, "div", {
          className: className + " vjs-time-control vjs-control",
          innerHTML: '<span class="vjs-control-text">' + this.localize(this.labelText_) + " </span>"
        });
        this.contentEl_ = createEl("span", {
          className: className + "-display"
        }, {
          // tell screen readers not to automatically read the time as it changes
          "aria-live": "off"
        });
        this.updateTextNode_();
        el.appendChild(this.contentEl_);
        return el;
      };
      TimeDisplay2.prototype.dispose = function dispose() {
        this.contentEl_ = null;
        this.textNode_ = null;
        _Component.prototype.dispose.call(this);
      };
      TimeDisplay2.prototype.updateTextNode_ = function updateTextNode_() {
        if (!this.contentEl_) {
          return;
        }
        while (this.contentEl_.firstChild) {
          this.contentEl_.removeChild(this.contentEl_.firstChild);
        }
        this.textNode_ = document2.createTextNode(this.formattedTime_ || this.formatTime_(0));
        this.contentEl_.appendChild(this.textNode_);
      };
      TimeDisplay2.prototype.formatTime_ = function formatTime_(time) {
        return formatTime(time);
      };
      TimeDisplay2.prototype.updateFormattedTime_ = function updateFormattedTime_(time) {
        var formattedTime = this.formatTime_(time);
        if (formattedTime === this.formattedTime_) {
          return;
        }
        this.formattedTime_ = formattedTime;
        this.requestAnimationFrame(this.updateTextNode_);
      };
      TimeDisplay2.prototype.updateContent = function updateContent(event2) {
      };
      return TimeDisplay2;
    }(Component);
    TimeDisplay.prototype.labelText_ = "Time";
    TimeDisplay.prototype.controlText_ = "Time";
    Component.registerComponent("TimeDisplay", TimeDisplay);
    var CurrentTimeDisplay = function(_TimeDisplay) {
      inherits(CurrentTimeDisplay2, _TimeDisplay);
      function CurrentTimeDisplay2(player, options) {
        classCallCheck(this, CurrentTimeDisplay2);
        var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));
        _this.on(player, "ended", _this.handleEnded);
        return _this;
      }
      CurrentTimeDisplay2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-current-time";
      };
      CurrentTimeDisplay2.prototype.updateContent = function updateContent(event2) {
        var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
        this.updateFormattedTime_(time);
      };
      CurrentTimeDisplay2.prototype.handleEnded = function handleEnded(event2) {
        if (!this.player_.duration()) {
          return;
        }
        this.updateFormattedTime_(this.player_.duration());
      };
      return CurrentTimeDisplay2;
    }(TimeDisplay);
    CurrentTimeDisplay.prototype.labelText_ = "Current Time";
    CurrentTimeDisplay.prototype.controlText_ = "Current Time";
    Component.registerComponent("CurrentTimeDisplay", CurrentTimeDisplay);
    var DurationDisplay = function(_TimeDisplay) {
      inherits(DurationDisplay2, _TimeDisplay);
      function DurationDisplay2(player, options) {
        classCallCheck(this, DurationDisplay2);
        var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));
        _this.on(player, "durationchange", _this.updateContent);
        _this.on(player, "loadedmetadata", _this.throttledUpdateContent);
        return _this;
      }
      DurationDisplay2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-duration";
      };
      DurationDisplay2.prototype.updateContent = function updateContent(event2) {
        var duration = this.player_.duration();
        if (duration && this.duration_ !== duration) {
          this.duration_ = duration;
          this.updateFormattedTime_(duration);
        }
      };
      return DurationDisplay2;
    }(TimeDisplay);
    DurationDisplay.prototype.labelText_ = "Duration";
    DurationDisplay.prototype.controlText_ = "Duration";
    Component.registerComponent("DurationDisplay", DurationDisplay);
    var TimeDivider = function(_Component) {
      inherits(TimeDivider2, _Component);
      function TimeDivider2() {
        classCallCheck(this, TimeDivider2);
        return possibleConstructorReturn(this, _Component.apply(this, arguments));
      }
      TimeDivider2.prototype.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-time-control vjs-time-divider",
          innerHTML: "<div><span>/</span></div>"
        });
      };
      return TimeDivider2;
    }(Component);
    Component.registerComponent("TimeDivider", TimeDivider);
    var RemainingTimeDisplay = function(_TimeDisplay) {
      inherits(RemainingTimeDisplay2, _TimeDisplay);
      function RemainingTimeDisplay2(player, options) {
        classCallCheck(this, RemainingTimeDisplay2);
        var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));
        _this.on(player, "durationchange", _this.throttledUpdateContent);
        _this.on(player, "ended", _this.handleEnded);
        return _this;
      }
      RemainingTimeDisplay2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-remaining-time";
      };
      RemainingTimeDisplay2.prototype.formatTime_ = function formatTime_(time) {
        return "-" + _TimeDisplay.prototype.formatTime_.call(this, time);
      };
      RemainingTimeDisplay2.prototype.updateContent = function updateContent(event2) {
        if (!this.player_.duration()) {
          return;
        }
        if (this.player_.remainingTimeDisplay) {
          this.updateFormattedTime_(this.player_.remainingTimeDisplay());
        } else {
          this.updateFormattedTime_(this.player_.remainingTime());
        }
      };
      RemainingTimeDisplay2.prototype.handleEnded = function handleEnded(event2) {
        if (!this.player_.duration()) {
          return;
        }
        this.updateFormattedTime_(0);
      };
      return RemainingTimeDisplay2;
    }(TimeDisplay);
    RemainingTimeDisplay.prototype.labelText_ = "Remaining Time";
    RemainingTimeDisplay.prototype.controlText_ = "Remaining Time";
    Component.registerComponent("RemainingTimeDisplay", RemainingTimeDisplay);
    var LiveDisplay = function(_Component) {
      inherits(LiveDisplay2, _Component);
      function LiveDisplay2(player, options) {
        classCallCheck(this, LiveDisplay2);
        var _this = possibleConstructorReturn(this, _Component.call(this, player, options));
        _this.updateShowing();
        _this.on(_this.player(), "durationchange", _this.updateShowing);
        return _this;
      }
      LiveDisplay2.prototype.createEl = function createEl$$1() {
        var el = _Component.prototype.createEl.call(this, "div", {
          className: "vjs-live-control vjs-control"
        });
        this.contentEl_ = createEl("div", {
          className: "vjs-live-display",
          innerHTML: '<span class="vjs-control-text">' + this.localize("Stream Type") + " </span>" + this.localize("LIVE")
        }, {
          "aria-live": "off"
        });
        el.appendChild(this.contentEl_);
        return el;
      };
      LiveDisplay2.prototype.dispose = function dispose() {
        this.contentEl_ = null;
        _Component.prototype.dispose.call(this);
      };
      LiveDisplay2.prototype.updateShowing = function updateShowing(event2) {
        if (this.player().duration() === Infinity) {
          this.show();
        } else {
          this.hide();
        }
      };
      return LiveDisplay2;
    }(Component);
    Component.registerComponent("LiveDisplay", LiveDisplay);
    var Slider = function(_Component) {
      inherits(Slider2, _Component);
      function Slider2(player, options) {
        classCallCheck(this, Slider2);
        var _this = possibleConstructorReturn(this, _Component.call(this, player, options));
        _this.bar = _this.getChild(_this.options_.barName);
        _this.vertical(!!_this.options_.vertical);
        _this.enable();
        return _this;
      }
      Slider2.prototype.enabled = function enabled() {
        return this.enabled_;
      };
      Slider2.prototype.enable = function enable() {
        if (this.enabled()) {
          return;
        }
        this.on("mousedown", this.handleMouseDown);
        this.on("touchstart", this.handleMouseDown);
        this.on("focus", this.handleFocus);
        this.on("blur", this.handleBlur);
        this.on("click", this.handleClick);
        this.on(this.player_, "controlsvisible", this.update);
        if (this.playerEvent) {
          this.on(this.player_, this.playerEvent, this.update);
        }
        this.removeClass("disabled");
        this.setAttribute("tabindex", 0);
        this.enabled_ = true;
      };
      Slider2.prototype.disable = function disable() {
        if (!this.enabled()) {
          return;
        }
        var doc = this.bar.el_.ownerDocument;
        this.off("mousedown", this.handleMouseDown);
        this.off("touchstart", this.handleMouseDown);
        this.off("focus", this.handleFocus);
        this.off("blur", this.handleBlur);
        this.off("click", this.handleClick);
        this.off(this.player_, "controlsvisible", this.update);
        this.off(doc, "mousemove", this.handleMouseMove);
        this.off(doc, "mouseup", this.handleMouseUp);
        this.off(doc, "touchmove", this.handleMouseMove);
        this.off(doc, "touchend", this.handleMouseUp);
        this.removeAttribute("tabindex");
        this.addClass("disabled");
        if (this.playerEvent) {
          this.off(this.player_, this.playerEvent, this.update);
        }
        this.enabled_ = false;
      };
      Slider2.prototype.createEl = function createEl$$1(type) {
        var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        props.className = props.className + " vjs-slider";
        props = assign({
          tabIndex: 0
        }, props);
        attributes = assign({
          "role": "slider",
          "aria-valuenow": 0,
          "aria-valuemin": 0,
          "aria-valuemax": 100,
          "tabIndex": 0
        }, attributes);
        return _Component.prototype.createEl.call(this, type, props, attributes);
      };
      Slider2.prototype.handleMouseDown = function handleMouseDown(event2) {
        var doc = this.bar.el_.ownerDocument;
        if (event2.type === "mousedown") {
          event2.preventDefault();
        }
        if (event2.type === "touchstart" && !IS_CHROME) {
          event2.preventDefault();
        }
        blockTextSelection();
        this.addClass("vjs-sliding");
        this.trigger("slideractive");
        this.on(doc, "mousemove", this.handleMouseMove);
        this.on(doc, "mouseup", this.handleMouseUp);
        this.on(doc, "touchmove", this.handleMouseMove);
        this.on(doc, "touchend", this.handleMouseUp);
        this.handleMouseMove(event2);
      };
      Slider2.prototype.handleMouseMove = function handleMouseMove(event2) {
      };
      Slider2.prototype.handleMouseUp = function handleMouseUp() {
        var doc = this.bar.el_.ownerDocument;
        unblockTextSelection();
        this.removeClass("vjs-sliding");
        this.trigger("sliderinactive");
        this.off(doc, "mousemove", this.handleMouseMove);
        this.off(doc, "mouseup", this.handleMouseUp);
        this.off(doc, "touchmove", this.handleMouseMove);
        this.off(doc, "touchend", this.handleMouseUp);
        this.update();
      };
      Slider2.prototype.update = function update() {
        if (!this.el_) {
          return;
        }
        var progress = this.getPercent();
        var bar = this.bar;
        if (!bar) {
          return;
        }
        if (typeof progress !== "number" || progress !== progress || progress < 0 || progress === Infinity) {
          progress = 0;
        }
        var percentage = (progress * 100).toFixed(2) + "%";
        var style2 = bar.el().style;
        if (this.vertical()) {
          style2.height = percentage;
        } else {
          style2.width = percentage;
        }
        return progress;
      };
      Slider2.prototype.calculateDistance = function calculateDistance(event2) {
        var position = getPointerPosition(this.el_, event2);
        if (this.vertical()) {
          return position.y;
        }
        return position.x;
      };
      Slider2.prototype.handleFocus = function handleFocus() {
        this.on(this.bar.el_.ownerDocument, "keydown", this.handleKeyPress);
      };
      Slider2.prototype.handleKeyPress = function handleKeyPress(event2) {
        if (event2.which === 37 || event2.which === 40) {
          event2.preventDefault();
          this.stepBack();
        } else if (event2.which === 38 || event2.which === 39) {
          event2.preventDefault();
          this.stepForward();
        }
      };
      Slider2.prototype.handleBlur = function handleBlur() {
        this.off(this.bar.el_.ownerDocument, "keydown", this.handleKeyPress);
      };
      Slider2.prototype.handleClick = function handleClick(event2) {
        event2.stopImmediatePropagation();
        event2.preventDefault();
      };
      Slider2.prototype.vertical = function vertical(bool) {
        if (bool === void 0) {
          return this.vertical_ || false;
        }
        this.vertical_ = !!bool;
        if (this.vertical_) {
          this.addClass("vjs-slider-vertical");
        } else {
          this.addClass("vjs-slider-horizontal");
        }
      };
      return Slider2;
    }(Component);
    Component.registerComponent("Slider", Slider);
    var LoadProgressBar = function(_Component) {
      inherits(LoadProgressBar2, _Component);
      function LoadProgressBar2(player, options) {
        classCallCheck(this, LoadProgressBar2);
        var _this = possibleConstructorReturn(this, _Component.call(this, player, options));
        _this.partEls_ = [];
        _this.on(player, "progress", _this.update);
        return _this;
      }
      LoadProgressBar2.prototype.createEl = function createEl$$1() {
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-load-progress",
          innerHTML: '<span class="vjs-control-text"><span>' + this.localize("Loaded") + "</span>: 0%</span>"
        });
      };
      LoadProgressBar2.prototype.dispose = function dispose() {
        this.partEls_ = null;
        _Component.prototype.dispose.call(this);
      };
      LoadProgressBar2.prototype.update = function update(event2) {
        var buffered = this.player_.buffered();
        var duration = this.player_.duration();
        var bufferedEnd = this.player_.bufferedEnd();
        var children = this.partEls_;
        var percentify = function percentify2(time, end2) {
          var percent = time / end2 || 0;
          return (percent >= 1 ? 1 : percent) * 100 + "%";
        };
        this.el_.style.width = percentify(bufferedEnd, duration);
        for (var i2 = 0; i2 < buffered.length; i2++) {
          var start = buffered.start(i2);
          var end = buffered.end(i2);
          var part = children[i2];
          if (!part) {
            part = this.el_.appendChild(createEl());
            children[i2] = part;
          }
          part.style.left = percentify(start, bufferedEnd);
          part.style.width = percentify(end - start, bufferedEnd);
        }
        for (var _i2 = children.length; _i2 > buffered.length; _i2--) {
          this.el_.removeChild(children[_i2 - 1]);
        }
        children.length = buffered.length;
      };
      return LoadProgressBar2;
    }(Component);
    Component.registerComponent("LoadProgressBar", LoadProgressBar);
    var TimeTooltip = function(_Component) {
      inherits(TimeTooltip2, _Component);
      function TimeTooltip2() {
        classCallCheck(this, TimeTooltip2);
        return possibleConstructorReturn(this, _Component.apply(this, arguments));
      }
      TimeTooltip2.prototype.createEl = function createEl$$1() {
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-time-tooltip"
        });
      };
      TimeTooltip2.prototype.update = function update(seekBarRect, seekBarPoint, content) {
        var tooltipRect = getBoundingClientRect(this.el_);
        var playerRect = getBoundingClientRect(this.player_.el());
        var seekBarPointPx = seekBarRect.width * seekBarPoint;
        if (!playerRect || !tooltipRect) {
          return;
        }
        var spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;
        var spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);
        var pullTooltipBy = tooltipRect.width / 2;
        if (spaceLeftOfPoint < pullTooltipBy) {
          pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
        } else if (spaceRightOfPoint < pullTooltipBy) {
          pullTooltipBy = spaceRightOfPoint;
        }
        if (pullTooltipBy < 0) {
          pullTooltipBy = 0;
        } else if (pullTooltipBy > tooltipRect.width) {
          pullTooltipBy = tooltipRect.width;
        }
        this.el_.style.right = "-" + pullTooltipBy + "px";
        textContent(this.el_, content);
      };
      return TimeTooltip2;
    }(Component);
    Component.registerComponent("TimeTooltip", TimeTooltip);
    var PlayProgressBar = function(_Component) {
      inherits(PlayProgressBar2, _Component);
      function PlayProgressBar2() {
        classCallCheck(this, PlayProgressBar2);
        return possibleConstructorReturn(this, _Component.apply(this, arguments));
      }
      PlayProgressBar2.prototype.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-play-progress vjs-slider-bar",
          innerHTML: '<span class="vjs-control-text"><span>' + this.localize("Progress") + "</span>: 0%</span>"
        });
      };
      PlayProgressBar2.prototype.update = function update(seekBarRect, seekBarPoint) {
        var _this2 = this;
        if (this.rafId_) {
          this.cancelAnimationFrame(this.rafId_);
        }
        this.rafId_ = this.requestAnimationFrame(function() {
          var time = _this2.player_.scrubbing() ? _this2.player_.getCache().currentTime : _this2.player_.currentTime();
          var content = formatTime(time, _this2.player_.duration());
          var timeTooltip = _this2.getChild("timeTooltip");
          if (timeTooltip) {
            timeTooltip.update(seekBarRect, seekBarPoint, content);
          }
        });
      };
      return PlayProgressBar2;
    }(Component);
    PlayProgressBar.prototype.options_ = {
      children: []
    };
    if ((!IE_VERSION || IE_VERSION > 8) && !IS_IOS && !IS_ANDROID) {
      PlayProgressBar.prototype.options_.children.push("timeTooltip");
    }
    Component.registerComponent("PlayProgressBar", PlayProgressBar);
    var MouseTimeDisplay = function(_Component) {
      inherits(MouseTimeDisplay2, _Component);
      function MouseTimeDisplay2(player, options) {
        classCallCheck(this, MouseTimeDisplay2);
        var _this = possibleConstructorReturn(this, _Component.call(this, player, options));
        _this.update = throttle(bind(_this, _this.update), 25);
        return _this;
      }
      MouseTimeDisplay2.prototype.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-mouse-display"
        });
      };
      MouseTimeDisplay2.prototype.update = function update(seekBarRect, seekBarPoint) {
        var _this2 = this;
        if (this.rafId_) {
          this.cancelAnimationFrame(this.rafId_);
        }
        this.rafId_ = this.requestAnimationFrame(function() {
          var duration = _this2.player_.duration();
          var content = formatTime(seekBarPoint * duration, duration);
          _this2.el_.style.left = seekBarRect.width * seekBarPoint + "px";
          _this2.getChild("timeTooltip").update(seekBarRect, seekBarPoint, content);
        });
      };
      return MouseTimeDisplay2;
    }(Component);
    MouseTimeDisplay.prototype.options_ = {
      children: ["timeTooltip"]
    };
    Component.registerComponent("MouseTimeDisplay", MouseTimeDisplay);
    var STEP_SECONDS = 5;
    var UPDATE_REFRESH_INTERVAL = 30;
    var SeekBar = function(_Slider) {
      inherits(SeekBar2, _Slider);
      function SeekBar2(player, options) {
        classCallCheck(this, SeekBar2);
        var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));
        _this.setEventHandlers_();
        return _this;
      }
      SeekBar2.prototype.setEventHandlers_ = function setEventHandlers_() {
        var _this2 = this;
        this.update = throttle(bind(this, this.update), UPDATE_REFRESH_INTERVAL);
        this.on(this.player_, "timeupdate", this.update);
        this.on(this.player_, "ended", this.handleEnded);
        this.updateInterval = null;
        this.on(this.player_, ["playing"], function() {
          _this2.clearInterval(_this2.updateInterval);
          _this2.updateInterval = _this2.setInterval(function() {
            _this2.requestAnimationFrame(function() {
              _this2.update();
            });
          }, UPDATE_REFRESH_INTERVAL);
        });
        this.on(this.player_, ["ended", "pause", "waiting"], function() {
          _this2.clearInterval(_this2.updateInterval);
        });
        this.on(this.player_, ["timeupdate", "ended"], this.update);
      };
      SeekBar2.prototype.createEl = function createEl$$1() {
        return _Slider.prototype.createEl.call(this, "div", {
          className: "vjs-progress-holder"
        }, {
          "aria-label": this.localize("Progress Bar")
        });
      };
      SeekBar2.prototype.update_ = function update_(currentTime, percent) {
        var duration = this.player_.duration();
        this.el_.setAttribute("aria-valuenow", (percent * 100).toFixed(2));
        this.el_.setAttribute("aria-valuetext", this.localize("progress bar timing: currentTime={1} duration={2}", [formatTime(currentTime, duration), formatTime(duration, duration)], "{1} of {2}"));
        this.bar.update(getBoundingClientRect(this.el_), percent);
      };
      SeekBar2.prototype.update = function update(event2) {
        var percent = _Slider.prototype.update.call(this);
        this.update_(this.getCurrentTime_(), percent);
        return percent;
      };
      SeekBar2.prototype.getCurrentTime_ = function getCurrentTime_() {
        return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
      };
      SeekBar2.prototype.handleEnded = function handleEnded(event2) {
        this.update_(this.player_.duration(), 1);
      };
      SeekBar2.prototype.getPercent = function getPercent() {
        var percent = this.getCurrentTime_() / this.player_.duration();
        return percent >= 1 ? 1 : percent;
      };
      SeekBar2.prototype.handleMouseDown = function handleMouseDown(event2) {
        if (!isSingleLeftClick(event2)) {
          return;
        }
        event2.stopPropagation();
        this.player_.scrubbing(true);
        this.videoWasPlaying = !this.player_.paused();
        this.player_.pause();
        _Slider.prototype.handleMouseDown.call(this, event2);
      };
      SeekBar2.prototype.handleMouseMove = function handleMouseMove(event2) {
        if (!isSingleLeftClick(event2)) {
          return;
        }
        var newTime = this.calculateDistance(event2) * this.player_.duration();
        if (newTime === this.player_.duration()) {
          newTime = newTime - 0.1;
        }
        this.player_.currentTime(newTime);
      };
      SeekBar2.prototype.enable = function enable() {
        _Slider.prototype.enable.call(this);
        var mouseTimeDisplay = this.getChild("mouseTimeDisplay");
        if (!mouseTimeDisplay) {
          return;
        }
        mouseTimeDisplay.show();
      };
      SeekBar2.prototype.disable = function disable() {
        _Slider.prototype.disable.call(this);
        var mouseTimeDisplay = this.getChild("mouseTimeDisplay");
        if (!mouseTimeDisplay) {
          return;
        }
        mouseTimeDisplay.hide();
      };
      SeekBar2.prototype.handleMouseUp = function handleMouseUp(event2) {
        _Slider.prototype.handleMouseUp.call(this, event2);
        if (event2) {
          event2.stopPropagation();
        }
        this.player_.scrubbing(false);
        this.player_.trigger({ type: "timeupdate", target: this, manuallyTriggered: true });
        if (this.videoWasPlaying) {
          silencePromise(this.player_.play());
        }
      };
      SeekBar2.prototype.stepForward = function stepForward() {
        this.player_.currentTime(this.player_.currentTime() + STEP_SECONDS);
      };
      SeekBar2.prototype.stepBack = function stepBack() {
        this.player_.currentTime(this.player_.currentTime() - STEP_SECONDS);
      };
      SeekBar2.prototype.handleAction = function handleAction(event2) {
        if (this.player_.paused()) {
          this.player_.play();
        } else {
          this.player_.pause();
        }
      };
      SeekBar2.prototype.handleKeyPress = function handleKeyPress(event2) {
        if (event2.which === 32 || event2.which === 13) {
          event2.preventDefault();
          this.handleAction(event2);
        } else if (_Slider.prototype.handleKeyPress) {
          _Slider.prototype.handleKeyPress.call(this, event2);
        }
      };
      return SeekBar2;
    }(Slider);
    SeekBar.prototype.options_ = {
      children: ["loadProgressBar", "playProgressBar"],
      barName: "playProgressBar"
    };
    if ((!IE_VERSION || IE_VERSION > 8) && !IS_IOS && !IS_ANDROID) {
      SeekBar.prototype.options_.children.splice(1, 0, "mouseTimeDisplay");
    }
    SeekBar.prototype.playerEvent = "timeupdate";
    Component.registerComponent("SeekBar", SeekBar);
    var ProgressControl = function(_Component) {
      inherits(ProgressControl2, _Component);
      function ProgressControl2(player, options) {
        classCallCheck(this, ProgressControl2);
        var _this = possibleConstructorReturn(this, _Component.call(this, player, options));
        _this.handleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);
        _this.throttledHandleMouseSeek = throttle(bind(_this, _this.handleMouseSeek), 25);
        _this.enable();
        return _this;
      }
      ProgressControl2.prototype.createEl = function createEl$$1() {
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-progress-control vjs-control"
        });
      };
      ProgressControl2.prototype.handleMouseMove = function handleMouseMove(event2) {
        var seekBar = this.getChild("seekBar");
        if (seekBar) {
          var mouseTimeDisplay = seekBar.getChild("mouseTimeDisplay");
          var seekBarEl = seekBar.el();
          var seekBarRect = getBoundingClientRect(seekBarEl);
          var seekBarPoint = getPointerPosition(seekBarEl, event2).x;
          if (seekBarPoint > 1) {
            seekBarPoint = 1;
          } else if (seekBarPoint < 0) {
            seekBarPoint = 0;
          }
          if (mouseTimeDisplay) {
            mouseTimeDisplay.update(seekBarRect, seekBarPoint);
          }
        }
      };
      ProgressControl2.prototype.handleMouseSeek = function handleMouseSeek(event2) {
        var seekBar = this.getChild("seekBar");
        if (seekBar) {
          seekBar.handleMouseMove(event2);
        }
      };
      ProgressControl2.prototype.enabled = function enabled() {
        return this.enabled_;
      };
      ProgressControl2.prototype.disable = function disable() {
        this.children().forEach(function(child) {
          return child.disable && child.disable();
        });
        if (!this.enabled()) {
          return;
        }
        this.off(["mousedown", "touchstart"], this.handleMouseDown);
        this.off(this.el_, "mousemove", this.handleMouseMove);
        this.handleMouseUp();
        this.addClass("disabled");
        this.enabled_ = false;
      };
      ProgressControl2.prototype.enable = function enable() {
        this.children().forEach(function(child) {
          return child.enable && child.enable();
        });
        if (this.enabled()) {
          return;
        }
        this.on(["mousedown", "touchstart"], this.handleMouseDown);
        this.on(this.el_, "mousemove", this.handleMouseMove);
        this.removeClass("disabled");
        this.enabled_ = true;
      };
      ProgressControl2.prototype.handleMouseDown = function handleMouseDown(event2) {
        var doc = this.el_.ownerDocument;
        var seekBar = this.getChild("seekBar");
        if (seekBar) {
          seekBar.handleMouseDown(event2);
        }
        this.on(doc, "mousemove", this.throttledHandleMouseSeek);
        this.on(doc, "touchmove", this.throttledHandleMouseSeek);
        this.on(doc, "mouseup", this.handleMouseUp);
        this.on(doc, "touchend", this.handleMouseUp);
      };
      ProgressControl2.prototype.handleMouseUp = function handleMouseUp(event2) {
        var doc = this.el_.ownerDocument;
        var seekBar = this.getChild("seekBar");
        if (seekBar) {
          seekBar.handleMouseUp(event2);
        }
        this.off(doc, "mousemove", this.throttledHandleMouseSeek);
        this.off(doc, "touchmove", this.throttledHandleMouseSeek);
        this.off(doc, "mouseup", this.handleMouseUp);
        this.off(doc, "touchend", this.handleMouseUp);
      };
      return ProgressControl2;
    }(Component);
    ProgressControl.prototype.options_ = {
      children: ["seekBar"]
    };
    Component.registerComponent("ProgressControl", ProgressControl);
    var FullscreenToggle = function(_Button) {
      inherits(FullscreenToggle2, _Button);
      function FullscreenToggle2(player, options) {
        classCallCheck(this, FullscreenToggle2);
        var _this = possibleConstructorReturn(this, _Button.call(this, player, options));
        _this.on(player, "fullscreenchange", _this.handleFullscreenChange);
        if (document2[FullscreenApi.fullscreenEnabled] === false) {
          _this.disable();
        }
        return _this;
      }
      FullscreenToggle2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-fullscreen-control " + _Button.prototype.buildCSSClass.call(this);
      };
      FullscreenToggle2.prototype.handleFullscreenChange = function handleFullscreenChange(event2) {
        if (this.player_.isFullscreen()) {
          this.controlText("Non-Fullscreen");
        } else {
          this.controlText("Fullscreen");
        }
      };
      FullscreenToggle2.prototype.handleClick = function handleClick(event2) {
        if (!this.player_.isFullscreen()) {
          this.player_.requestFullscreen();
        } else {
          this.player_.exitFullscreen();
        }
      };
      return FullscreenToggle2;
    }(Button);
    FullscreenToggle.prototype.controlText_ = "Fullscreen";
    Component.registerComponent("FullscreenToggle", FullscreenToggle);
    var checkVolumeSupport = function checkVolumeSupport2(self2, player) {
      if (player.tech_ && !player.tech_.featuresVolumeControl) {
        self2.addClass("vjs-hidden");
      }
      self2.on(player, "loadstart", function() {
        if (!player.tech_.featuresVolumeControl) {
          self2.addClass("vjs-hidden");
        } else {
          self2.removeClass("vjs-hidden");
        }
      });
    };
    var VolumeLevel = function(_Component) {
      inherits(VolumeLevel2, _Component);
      function VolumeLevel2() {
        classCallCheck(this, VolumeLevel2);
        return possibleConstructorReturn(this, _Component.apply(this, arguments));
      }
      VolumeLevel2.prototype.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-volume-level",
          innerHTML: '<span class="vjs-control-text"></span>'
        });
      };
      return VolumeLevel2;
    }(Component);
    Component.registerComponent("VolumeLevel", VolumeLevel);
    var VolumeBar = function(_Slider) {
      inherits(VolumeBar2, _Slider);
      function VolumeBar2(player, options) {
        classCallCheck(this, VolumeBar2);
        var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));
        _this.on("slideractive", _this.updateLastVolume_);
        _this.on(player, "volumechange", _this.updateARIAAttributes);
        player.ready(function() {
          return _this.updateARIAAttributes();
        });
        return _this;
      }
      VolumeBar2.prototype.createEl = function createEl$$1() {
        return _Slider.prototype.createEl.call(this, "div", {
          className: "vjs-volume-bar vjs-slider-bar"
        }, {
          "aria-label": this.localize("Volume Level"),
          "aria-live": "polite"
        });
      };
      VolumeBar2.prototype.handleMouseDown = function handleMouseDown(event2) {
        if (!isSingleLeftClick(event2)) {
          return;
        }
        _Slider.prototype.handleMouseDown.call(this, event2);
      };
      VolumeBar2.prototype.handleMouseMove = function handleMouseMove(event2) {
        if (!isSingleLeftClick(event2)) {
          return;
        }
        this.checkMuted();
        this.player_.volume(this.calculateDistance(event2));
      };
      VolumeBar2.prototype.checkMuted = function checkMuted() {
        if (this.player_.muted()) {
          this.player_.muted(false);
        }
      };
      VolumeBar2.prototype.getPercent = function getPercent() {
        if (this.player_.muted()) {
          return 0;
        }
        return this.player_.volume();
      };
      VolumeBar2.prototype.stepForward = function stepForward() {
        this.checkMuted();
        this.player_.volume(this.player_.volume() + 0.1);
      };
      VolumeBar2.prototype.stepBack = function stepBack() {
        this.checkMuted();
        this.player_.volume(this.player_.volume() - 0.1);
      };
      VolumeBar2.prototype.updateARIAAttributes = function updateARIAAttributes(event2) {
        var ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();
        this.el_.setAttribute("aria-valuenow", ariaValue);
        this.el_.setAttribute("aria-valuetext", ariaValue + "%");
      };
      VolumeBar2.prototype.volumeAsPercentage_ = function volumeAsPercentage_() {
        return Math.round(this.player_.volume() * 100);
      };
      VolumeBar2.prototype.updateLastVolume_ = function updateLastVolume_() {
        var _this2 = this;
        var volumeBeforeDrag = this.player_.volume();
        this.one("sliderinactive", function() {
          if (_this2.player_.volume() === 0) {
            _this2.player_.lastVolume_(volumeBeforeDrag);
          }
        });
      };
      return VolumeBar2;
    }(Slider);
    VolumeBar.prototype.options_ = {
      children: ["volumeLevel"],
      barName: "volumeLevel"
    };
    VolumeBar.prototype.playerEvent = "volumechange";
    Component.registerComponent("VolumeBar", VolumeBar);
    var VolumeControl = function(_Component) {
      inherits(VolumeControl2, _Component);
      function VolumeControl2(player) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        classCallCheck(this, VolumeControl2);
        options.vertical = options.vertical || false;
        if (typeof options.volumeBar === "undefined" || isPlain(options.volumeBar)) {
          options.volumeBar = options.volumeBar || {};
          options.volumeBar.vertical = options.vertical;
        }
        var _this = possibleConstructorReturn(this, _Component.call(this, player, options));
        checkVolumeSupport(_this, player);
        _this.throttledHandleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);
        _this.on("mousedown", _this.handleMouseDown);
        _this.on("touchstart", _this.handleMouseDown);
        _this.on(_this.volumeBar, ["focus", "slideractive"], function() {
          _this.volumeBar.addClass("vjs-slider-active");
          _this.addClass("vjs-slider-active");
          _this.trigger("slideractive");
        });
        _this.on(_this.volumeBar, ["blur", "sliderinactive"], function() {
          _this.volumeBar.removeClass("vjs-slider-active");
          _this.removeClass("vjs-slider-active");
          _this.trigger("sliderinactive");
        });
        return _this;
      }
      VolumeControl2.prototype.createEl = function createEl2() {
        var orientationClass = "vjs-volume-horizontal";
        if (this.options_.vertical) {
          orientationClass = "vjs-volume-vertical";
        }
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-volume-control vjs-control " + orientationClass
        });
      };
      VolumeControl2.prototype.handleMouseDown = function handleMouseDown(event2) {
        var doc = this.el_.ownerDocument;
        this.on(doc, "mousemove", this.throttledHandleMouseMove);
        this.on(doc, "touchmove", this.throttledHandleMouseMove);
        this.on(doc, "mouseup", this.handleMouseUp);
        this.on(doc, "touchend", this.handleMouseUp);
      };
      VolumeControl2.prototype.handleMouseUp = function handleMouseUp(event2) {
        var doc = this.el_.ownerDocument;
        this.off(doc, "mousemove", this.throttledHandleMouseMove);
        this.off(doc, "touchmove", this.throttledHandleMouseMove);
        this.off(doc, "mouseup", this.handleMouseUp);
        this.off(doc, "touchend", this.handleMouseUp);
      };
      VolumeControl2.prototype.handleMouseMove = function handleMouseMove(event2) {
        this.volumeBar.handleMouseMove(event2);
      };
      return VolumeControl2;
    }(Component);
    VolumeControl.prototype.options_ = {
      children: ["volumeBar"]
    };
    Component.registerComponent("VolumeControl", VolumeControl);
    var checkMuteSupport = function checkMuteSupport2(self2, player) {
      if (player.tech_ && !player.tech_.featuresMuteControl) {
        self2.addClass("vjs-hidden");
      }
      self2.on(player, "loadstart", function() {
        if (!player.tech_.featuresMuteControl) {
          self2.addClass("vjs-hidden");
        } else {
          self2.removeClass("vjs-hidden");
        }
      });
    };
    var MuteToggle = function(_Button) {
      inherits(MuteToggle2, _Button);
      function MuteToggle2(player, options) {
        classCallCheck(this, MuteToggle2);
        var _this = possibleConstructorReturn(this, _Button.call(this, player, options));
        checkMuteSupport(_this, player);
        _this.on(player, ["loadstart", "volumechange"], _this.update);
        return _this;
      }
      MuteToggle2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-mute-control " + _Button.prototype.buildCSSClass.call(this);
      };
      MuteToggle2.prototype.handleClick = function handleClick(event2) {
        var vol = this.player_.volume();
        var lastVolume = this.player_.lastVolume_();
        if (vol === 0) {
          var volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;
          this.player_.volume(volumeToSet);
          this.player_.muted(false);
        } else {
          this.player_.muted(this.player_.muted() ? false : true);
        }
      };
      MuteToggle2.prototype.update = function update(event2) {
        this.updateIcon_();
        this.updateControlText_();
      };
      MuteToggle2.prototype.updateIcon_ = function updateIcon_() {
        var vol = this.player_.volume();
        var level = 3;
        if (IS_IOS) {
          this.player_.muted(this.player_.tech_.el_.muted);
        }
        if (vol === 0 || this.player_.muted()) {
          level = 0;
        } else if (vol < 0.33) {
          level = 1;
        } else if (vol < 0.67) {
          level = 2;
        }
        for (var i2 = 0; i2 < 4; i2++) {
          removeClass(this.el_, "vjs-vol-" + i2);
        }
        addClass(this.el_, "vjs-vol-" + level);
      };
      MuteToggle2.prototype.updateControlText_ = function updateControlText_() {
        var soundOff = this.player_.muted() || this.player_.volume() === 0;
        var text = soundOff ? "Unmute" : "Mute";
        if (this.controlText() !== text) {
          this.controlText(text);
        }
      };
      return MuteToggle2;
    }(Button);
    MuteToggle.prototype.controlText_ = "Mute";
    Component.registerComponent("MuteToggle", MuteToggle);
    var VolumePanel = function(_Component) {
      inherits(VolumePanel2, _Component);
      function VolumePanel2(player) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        classCallCheck(this, VolumePanel2);
        if (typeof options.inline !== "undefined") {
          options.inline = options.inline;
        } else {
          options.inline = true;
        }
        if (typeof options.volumeControl === "undefined" || isPlain(options.volumeControl)) {
          options.volumeControl = options.volumeControl || {};
          options.volumeControl.vertical = !options.inline;
        }
        var _this = possibleConstructorReturn(this, _Component.call(this, player, options));
        _this.on(player, ["loadstart"], _this.volumePanelState_);
        _this.on(_this.volumeControl, ["slideractive"], _this.sliderActive_);
        _this.on(_this.volumeControl, ["sliderinactive"], _this.sliderInactive_);
        return _this;
      }
      VolumePanel2.prototype.sliderActive_ = function sliderActive_() {
        this.addClass("vjs-slider-active");
      };
      VolumePanel2.prototype.sliderInactive_ = function sliderInactive_() {
        this.removeClass("vjs-slider-active");
      };
      VolumePanel2.prototype.volumePanelState_ = function volumePanelState_() {
        if (this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden")) {
          this.addClass("vjs-hidden");
        }
        if (this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden")) {
          this.addClass("vjs-mute-toggle-only");
        }
      };
      VolumePanel2.prototype.createEl = function createEl2() {
        var orientationClass = "vjs-volume-panel-horizontal";
        if (!this.options_.inline) {
          orientationClass = "vjs-volume-panel-vertical";
        }
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-volume-panel vjs-control " + orientationClass
        });
      };
      return VolumePanel2;
    }(Component);
    VolumePanel.prototype.options_ = {
      children: ["muteToggle", "volumeControl"]
    };
    Component.registerComponent("VolumePanel", VolumePanel);
    var Menu = function(_Component) {
      inherits(Menu2, _Component);
      function Menu2(player, options) {
        classCallCheck(this, Menu2);
        var _this = possibleConstructorReturn(this, _Component.call(this, player, options));
        if (options) {
          _this.menuButton_ = options.menuButton;
        }
        _this.focusedChild_ = -1;
        _this.on("keydown", _this.handleKeyPress);
        return _this;
      }
      Menu2.prototype.addItem = function addItem(component) {
        this.addChild(component);
        component.on("click", bind(this, function(event2) {
          if (this.menuButton_) {
            this.menuButton_.unpressButton();
            if (component.name() !== "CaptionSettingsMenuItem") {
              this.menuButton_.focus();
            }
          }
        }));
      };
      Menu2.prototype.createEl = function createEl$$1() {
        var contentElType = this.options_.contentElType || "ul";
        this.contentEl_ = createEl(contentElType, {
          className: "vjs-menu-content"
        });
        this.contentEl_.setAttribute("role", "menu");
        var el = _Component.prototype.createEl.call(this, "div", {
          append: this.contentEl_,
          className: "vjs-menu"
        });
        el.appendChild(this.contentEl_);
        on(el, "click", function(event2) {
          event2.preventDefault();
          event2.stopImmediatePropagation();
        });
        return el;
      };
      Menu2.prototype.dispose = function dispose() {
        this.contentEl_ = null;
        _Component.prototype.dispose.call(this);
      };
      Menu2.prototype.handleKeyPress = function handleKeyPress(event2) {
        if (event2.which === 37 || event2.which === 40) {
          event2.preventDefault();
          this.stepForward();
        } else if (event2.which === 38 || event2.which === 39) {
          event2.preventDefault();
          this.stepBack();
        }
      };
      Menu2.prototype.stepForward = function stepForward() {
        var stepChild = 0;
        if (this.focusedChild_ !== void 0) {
          stepChild = this.focusedChild_ + 1;
        }
        this.focus(stepChild);
      };
      Menu2.prototype.stepBack = function stepBack() {
        var stepChild = 0;
        if (this.focusedChild_ !== void 0) {
          stepChild = this.focusedChild_ - 1;
        }
        this.focus(stepChild);
      };
      Menu2.prototype.focus = function focus() {
        var item = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        var children = this.children().slice();
        var haveTitle = children.length && children[0].className && /vjs-menu-title/.test(children[0].className);
        if (haveTitle) {
          children.shift();
        }
        if (children.length > 0) {
          if (item < 0) {
            item = 0;
          } else if (item >= children.length) {
            item = children.length - 1;
          }
          this.focusedChild_ = item;
          children[item].el_.focus();
        }
      };
      return Menu2;
    }(Component);
    Component.registerComponent("Menu", Menu);
    var MenuButton = function(_Component) {
      inherits(MenuButton2, _Component);
      function MenuButton2(player) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        classCallCheck(this, MenuButton2);
        var _this = possibleConstructorReturn(this, _Component.call(this, player, options));
        _this.menuButton_ = new Button(player, options);
        _this.menuButton_.controlText(_this.controlText_);
        _this.menuButton_.el_.setAttribute("aria-haspopup", "true");
        var buttonClass = Button.prototype.buildCSSClass();
        _this.menuButton_.el_.className = _this.buildCSSClass() + " " + buttonClass;
        _this.menuButton_.removeClass("vjs-control");
        _this.addChild(_this.menuButton_);
        _this.update();
        _this.enabled_ = true;
        _this.on(_this.menuButton_, "tap", _this.handleClick);
        _this.on(_this.menuButton_, "click", _this.handleClick);
        _this.on(_this.menuButton_, "focus", _this.handleFocus);
        _this.on(_this.menuButton_, "blur", _this.handleBlur);
        _this.on("keydown", _this.handleSubmenuKeyPress);
        return _this;
      }
      MenuButton2.prototype.update = function update() {
        var menu = this.createMenu();
        if (this.menu) {
          this.menu.dispose();
          this.removeChild(this.menu);
        }
        this.menu = menu;
        this.addChild(menu);
        this.buttonPressed_ = false;
        this.menuButton_.el_.setAttribute("aria-expanded", "false");
        if (this.items && this.items.length <= this.hideThreshold_) {
          this.hide();
        } else {
          this.show();
        }
      };
      MenuButton2.prototype.createMenu = function createMenu() {
        var menu = new Menu(this.player_, { menuButton: this });
        this.hideThreshold_ = 0;
        if (this.options_.title) {
          var title = createEl("li", {
            className: "vjs-menu-title",
            innerHTML: toTitleCase(this.options_.title),
            tabIndex: -1
          });
          this.hideThreshold_ += 1;
          menu.children_.unshift(title);
          prependTo(title, menu.contentEl());
        }
        this.items = this.createItems();
        if (this.items) {
          for (var i2 = 0; i2 < this.items.length; i2++) {
            menu.addItem(this.items[i2]);
          }
        }
        return menu;
      };
      MenuButton2.prototype.createItems = function createItems() {
      };
      MenuButton2.prototype.createEl = function createEl$$1() {
        return _Component.prototype.createEl.call(this, "div", {
          className: this.buildWrapperCSSClass()
        }, {});
      };
      MenuButton2.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
        var menuButtonClass = "vjs-menu-button";
        if (this.options_.inline === true) {
          menuButtonClass += "-inline";
        } else {
          menuButtonClass += "-popup";
        }
        var buttonClass = Button.prototype.buildCSSClass();
        return "vjs-menu-button " + menuButtonClass + " " + buttonClass + " " + _Component.prototype.buildCSSClass.call(this);
      };
      MenuButton2.prototype.buildCSSClass = function buildCSSClass() {
        var menuButtonClass = "vjs-menu-button";
        if (this.options_.inline === true) {
          menuButtonClass += "-inline";
        } else {
          menuButtonClass += "-popup";
        }
        return "vjs-menu-button " + menuButtonClass + " " + _Component.prototype.buildCSSClass.call(this);
      };
      MenuButton2.prototype.controlText = function controlText(text) {
        var el = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.menuButton_.el();
        return this.menuButton_.controlText(text, el);
      };
      MenuButton2.prototype.handleClick = function handleClick(event2) {
        this.one(this.menu.contentEl(), "mouseleave", bind(this, function(e) {
          this.unpressButton();
          this.el_.blur();
        }));
        if (this.buttonPressed_) {
          this.unpressButton();
        } else {
          this.pressButton();
        }
      };
      MenuButton2.prototype.focus = function focus() {
        this.menuButton_.focus();
      };
      MenuButton2.prototype.blur = function blur() {
        this.menuButton_.blur();
      };
      MenuButton2.prototype.handleFocus = function handleFocus() {
        on(document2, "keydown", bind(this, this.handleKeyPress));
      };
      MenuButton2.prototype.handleBlur = function handleBlur() {
        off(document2, "keydown", bind(this, this.handleKeyPress));
      };
      MenuButton2.prototype.handleKeyPress = function handleKeyPress(event2) {
        if (event2.which === 27 || event2.which === 9) {
          if (this.buttonPressed_) {
            this.unpressButton();
          }
          if (event2.which !== 9) {
            event2.preventDefault();
            this.menuButton_.el_.focus();
          }
        } else if (event2.which === 38 || event2.which === 40) {
          if (!this.buttonPressed_) {
            this.pressButton();
            event2.preventDefault();
          }
        }
      };
      MenuButton2.prototype.handleSubmenuKeyPress = function handleSubmenuKeyPress(event2) {
        if (event2.which === 27 || event2.which === 9) {
          if (this.buttonPressed_) {
            this.unpressButton();
          }
          if (event2.which !== 9) {
            event2.preventDefault();
            this.menuButton_.el_.focus();
          }
        }
      };
      MenuButton2.prototype.pressButton = function pressButton() {
        if (this.enabled_) {
          this.buttonPressed_ = true;
          this.menu.lockShowing();
          this.menuButton_.el_.setAttribute("aria-expanded", "true");
          if (IS_IOS && isInFrame()) {
            return;
          }
          this.menu.focus();
        }
      };
      MenuButton2.prototype.unpressButton = function unpressButton() {
        if (this.enabled_) {
          this.buttonPressed_ = false;
          this.menu.unlockShowing();
          this.menuButton_.el_.setAttribute("aria-expanded", "false");
        }
      };
      MenuButton2.prototype.disable = function disable() {
        this.unpressButton();
        this.enabled_ = false;
        this.addClass("vjs-disabled");
        this.menuButton_.disable();
      };
      MenuButton2.prototype.enable = function enable() {
        this.enabled_ = true;
        this.removeClass("vjs-disabled");
        this.menuButton_.enable();
      };
      return MenuButton2;
    }(Component);
    Component.registerComponent("MenuButton", MenuButton);
    var TrackButton = function(_MenuButton) {
      inherits(TrackButton2, _MenuButton);
      function TrackButton2(player, options) {
        classCallCheck(this, TrackButton2);
        var tracks = options.tracks;
        var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));
        if (_this.items.length <= 1) {
          _this.hide();
        }
        if (!tracks) {
          return possibleConstructorReturn(_this);
        }
        var updateHandler = bind(_this, _this.update);
        tracks.addEventListener("removetrack", updateHandler);
        tracks.addEventListener("addtrack", updateHandler);
        _this.player_.on("ready", updateHandler);
        _this.player_.on("dispose", function() {
          tracks.removeEventListener("removetrack", updateHandler);
          tracks.removeEventListener("addtrack", updateHandler);
        });
        return _this;
      }
      return TrackButton2;
    }(MenuButton);
    Component.registerComponent("TrackButton", TrackButton);
    var MenuItem = function(_ClickableComponent) {
      inherits(MenuItem2, _ClickableComponent);
      function MenuItem2(player, options) {
        classCallCheck(this, MenuItem2);
        var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));
        _this.selectable = options.selectable;
        _this.isSelected_ = options.selected || false;
        _this.multiSelectable = options.multiSelectable;
        _this.selected(_this.isSelected_);
        if (_this.selectable) {
          if (_this.multiSelectable) {
            _this.el_.setAttribute("role", "menuitemcheckbox");
          } else {
            _this.el_.setAttribute("role", "menuitemradio");
          }
        } else {
          _this.el_.setAttribute("role", "menuitem");
        }
        return _this;
      }
      MenuItem2.prototype.createEl = function createEl2(type, props, attrs) {
        this.nonIconControl = true;
        return _ClickableComponent.prototype.createEl.call(this, "li", assign({
          className: "vjs-menu-item",
          innerHTML: '<span class="vjs-menu-item-text">' + this.localize(this.options_.label) + "</span>",
          tabIndex: -1
        }, props), attrs);
      };
      MenuItem2.prototype.handleClick = function handleClick(event2) {
        this.selected(true);
      };
      MenuItem2.prototype.selected = function selected(_selected) {
        if (this.selectable) {
          if (_selected) {
            this.addClass("vjs-selected");
            this.el_.setAttribute("aria-checked", "true");
            this.controlText(", selected");
            this.isSelected_ = true;
          } else {
            this.removeClass("vjs-selected");
            this.el_.setAttribute("aria-checked", "false");
            this.controlText("");
            this.isSelected_ = false;
          }
        }
      };
      return MenuItem2;
    }(ClickableComponent);
    Component.registerComponent("MenuItem", MenuItem);
    var TextTrackMenuItem = function(_MenuItem) {
      inherits(TextTrackMenuItem2, _MenuItem);
      function TextTrackMenuItem2(player, options) {
        classCallCheck(this, TextTrackMenuItem2);
        var track2 = options.track;
        var tracks = player.textTracks();
        options.label = track2.label || track2.language || "Unknown";
        options.selected = track2.mode === "showing";
        var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));
        _this.track = track2;
        var changeHandler = function changeHandler2() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this.handleTracksChange.apply(_this, args);
        };
        var selectedLanguageChangeHandler = function selectedLanguageChangeHandler2() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          _this.handleSelectedLanguageChange.apply(_this, args);
        };
        player.on(["loadstart", "texttrackchange"], changeHandler);
        tracks.addEventListener("change", changeHandler);
        tracks.addEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
        _this.on("dispose", function() {
          player.off(["loadstart", "texttrackchange"], changeHandler);
          tracks.removeEventListener("change", changeHandler);
          tracks.removeEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
        });
        if (tracks.onchange === void 0) {
          var event2 = void 0;
          _this.on(["tap", "click"], function() {
            if (_typeof(window2.Event) !== "object") {
              try {
                event2 = new window2.Event("change");
              } catch (err) {
              }
            }
            if (!event2) {
              event2 = document2.createEvent("Event");
              event2.initEvent("change", true, true);
            }
            tracks.dispatchEvent(event2);
          });
        }
        _this.handleTracksChange();
        return _this;
      }
      TextTrackMenuItem2.prototype.handleClick = function handleClick(event2) {
        var kind = this.track.kind;
        var kinds = this.track.kinds;
        var tracks = this.player_.textTracks();
        if (!kinds) {
          kinds = [kind];
        }
        _MenuItem.prototype.handleClick.call(this, event2);
        if (!tracks) {
          return;
        }
        for (var i2 = 0; i2 < tracks.length; i2++) {
          var track2 = tracks[i2];
          if (track2 === this.track && kinds.indexOf(track2.kind) > -1) {
            if (track2.mode !== "showing") {
              track2.mode = "showing";
            }
          } else if (track2.mode !== "disabled") {
            track2.mode = "disabled";
          }
        }
      };
      TextTrackMenuItem2.prototype.handleTracksChange = function handleTracksChange(event2) {
        var shouldBeSelected = this.track.mode === "showing";
        if (shouldBeSelected !== this.isSelected_) {
          this.selected(shouldBeSelected);
        }
      };
      TextTrackMenuItem2.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event2) {
        if (this.track.mode === "showing") {
          var selectedLanguage = this.player_.cache_.selectedLanguage;
          if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {
            return;
          }
          this.player_.cache_.selectedLanguage = {
            enabled: true,
            language: this.track.language,
            kind: this.track.kind
          };
        }
      };
      TextTrackMenuItem2.prototype.dispose = function dispose() {
        this.track = null;
        _MenuItem.prototype.dispose.call(this);
      };
      return TextTrackMenuItem2;
    }(MenuItem);
    Component.registerComponent("TextTrackMenuItem", TextTrackMenuItem);
    var OffTextTrackMenuItem = function(_TextTrackMenuItem) {
      inherits(OffTextTrackMenuItem2, _TextTrackMenuItem);
      function OffTextTrackMenuItem2(player, options) {
        classCallCheck(this, OffTextTrackMenuItem2);
        options.track = {
          player,
          kind: options.kind,
          kinds: options.kinds,
          "default": false,
          mode: "disabled"
        };
        if (!options.kinds) {
          options.kinds = [options.kind];
        }
        if (options.label) {
          options.track.label = options.label;
        } else {
          options.track.label = options.kinds.join(" and ") + " off";
        }
        options.selectable = true;
        options.multiSelectable = false;
        return possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));
      }
      OffTextTrackMenuItem2.prototype.handleTracksChange = function handleTracksChange(event2) {
        var tracks = this.player().textTracks();
        var shouldBeSelected = true;
        for (var i2 = 0, l = tracks.length; i2 < l; i2++) {
          var track2 = tracks[i2];
          if (this.options_.kinds.indexOf(track2.kind) > -1 && track2.mode === "showing") {
            shouldBeSelected = false;
            break;
          }
        }
        if (shouldBeSelected !== this.isSelected_) {
          this.selected(shouldBeSelected);
        }
      };
      OffTextTrackMenuItem2.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event2) {
        var tracks = this.player().textTracks();
        var allHidden = true;
        for (var i2 = 0, l = tracks.length; i2 < l; i2++) {
          var track2 = tracks[i2];
          if (["captions", "descriptions", "subtitles"].indexOf(track2.kind) > -1 && track2.mode === "showing") {
            allHidden = false;
            break;
          }
        }
        if (allHidden) {
          this.player_.cache_.selectedLanguage = {
            enabled: false
          };
        }
      };
      return OffTextTrackMenuItem2;
    }(TextTrackMenuItem);
    Component.registerComponent("OffTextTrackMenuItem", OffTextTrackMenuItem);
    var TextTrackButton = function(_TrackButton) {
      inherits(TextTrackButton2, _TrackButton);
      function TextTrackButton2(player) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        classCallCheck(this, TextTrackButton2);
        options.tracks = player.textTracks();
        return possibleConstructorReturn(this, _TrackButton.call(this, player, options));
      }
      TextTrackButton2.prototype.createItems = function createItems() {
        var items = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        var TrackMenuItem = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : TextTrackMenuItem;
        var label = void 0;
        if (this.label_) {
          label = this.label_ + " off";
        }
        items.push(new OffTextTrackMenuItem(this.player_, {
          kinds: this.kinds_,
          kind: this.kind_,
          label
        }));
        this.hideThreshold_ += 1;
        var tracks = this.player_.textTracks();
        if (!Array.isArray(this.kinds_)) {
          this.kinds_ = [this.kind_];
        }
        for (var i2 = 0; i2 < tracks.length; i2++) {
          var track2 = tracks[i2];
          if (this.kinds_.indexOf(track2.kind) > -1) {
            var item = new TrackMenuItem(this.player_, {
              track: track2,
              // MenuItem is selectable
              selectable: true,
              // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
              multiSelectable: false
            });
            item.addClass("vjs-" + track2.kind + "-menu-item");
            items.push(item);
          }
        }
        return items;
      };
      return TextTrackButton2;
    }(TrackButton);
    Component.registerComponent("TextTrackButton", TextTrackButton);
    var ChaptersTrackMenuItem = function(_MenuItem) {
      inherits(ChaptersTrackMenuItem2, _MenuItem);
      function ChaptersTrackMenuItem2(player, options) {
        classCallCheck(this, ChaptersTrackMenuItem2);
        var track2 = options.track;
        var cue = options.cue;
        var currentTime = player.currentTime();
        options.selectable = true;
        options.multiSelectable = false;
        options.label = cue.text;
        options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;
        var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));
        _this.track = track2;
        _this.cue = cue;
        track2.addEventListener("cuechange", bind(_this, _this.update));
        return _this;
      }
      ChaptersTrackMenuItem2.prototype.handleClick = function handleClick(event2) {
        _MenuItem.prototype.handleClick.call(this);
        this.player_.currentTime(this.cue.startTime);
        this.update(this.cue.startTime);
      };
      ChaptersTrackMenuItem2.prototype.update = function update(event2) {
        var cue = this.cue;
        var currentTime = this.player_.currentTime();
        this.selected(cue.startTime <= currentTime && currentTime < cue.endTime);
      };
      return ChaptersTrackMenuItem2;
    }(MenuItem);
    Component.registerComponent("ChaptersTrackMenuItem", ChaptersTrackMenuItem);
    var ChaptersButton = function(_TextTrackButton) {
      inherits(ChaptersButton2, _TextTrackButton);
      function ChaptersButton2(player, options, ready) {
        classCallCheck(this, ChaptersButton2);
        return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
      }
      ChaptersButton2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-chapters-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
      };
      ChaptersButton2.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
        return "vjs-chapters-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
      };
      ChaptersButton2.prototype.update = function update(event2) {
        if (!this.track_ || event2 && (event2.type === "addtrack" || event2.type === "removetrack")) {
          this.setTrack(this.findChaptersTrack());
        }
        _TextTrackButton.prototype.update.call(this);
      };
      ChaptersButton2.prototype.setTrack = function setTrack(track2) {
        if (this.track_ === track2) {
          return;
        }
        if (!this.updateHandler_) {
          this.updateHandler_ = this.update.bind(this);
        }
        if (this.track_) {
          var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
          if (remoteTextTrackEl) {
            remoteTextTrackEl.removeEventListener("load", this.updateHandler_);
          }
          this.track_ = null;
        }
        this.track_ = track2;
        if (this.track_) {
          this.track_.mode = "hidden";
          var _remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
          if (_remoteTextTrackEl) {
            _remoteTextTrackEl.addEventListener("load", this.updateHandler_);
          }
        }
      };
      ChaptersButton2.prototype.findChaptersTrack = function findChaptersTrack() {
        var tracks = this.player_.textTracks() || [];
        for (var i2 = tracks.length - 1; i2 >= 0; i2--) {
          var track2 = tracks[i2];
          if (track2.kind === this.kind_) {
            return track2;
          }
        }
      };
      ChaptersButton2.prototype.getMenuCaption = function getMenuCaption() {
        if (this.track_ && this.track_.label) {
          return this.track_.label;
        }
        return this.localize(toTitleCase(this.kind_));
      };
      ChaptersButton2.prototype.createMenu = function createMenu() {
        this.options_.title = this.getMenuCaption();
        return _TextTrackButton.prototype.createMenu.call(this);
      };
      ChaptersButton2.prototype.createItems = function createItems() {
        var items = [];
        if (!this.track_) {
          return items;
        }
        var cues = this.track_.cues;
        if (!cues) {
          return items;
        }
        for (var i2 = 0, l = cues.length; i2 < l; i2++) {
          var cue = cues[i2];
          var mi = new ChaptersTrackMenuItem(this.player_, { track: this.track_, cue });
          items.push(mi);
        }
        return items;
      };
      return ChaptersButton2;
    }(TextTrackButton);
    ChaptersButton.prototype.kind_ = "chapters";
    ChaptersButton.prototype.controlText_ = "Chapters";
    Component.registerComponent("ChaptersButton", ChaptersButton);
    var DescriptionsButton = function(_TextTrackButton) {
      inherits(DescriptionsButton2, _TextTrackButton);
      function DescriptionsButton2(player, options, ready) {
        classCallCheck(this, DescriptionsButton2);
        var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
        var tracks = player.textTracks();
        var changeHandler = bind(_this, _this.handleTracksChange);
        tracks.addEventListener("change", changeHandler);
        _this.on("dispose", function() {
          tracks.removeEventListener("change", changeHandler);
        });
        return _this;
      }
      DescriptionsButton2.prototype.handleTracksChange = function handleTracksChange(event2) {
        var tracks = this.player().textTracks();
        var disabled = false;
        for (var i2 = 0, l = tracks.length; i2 < l; i2++) {
          var track2 = tracks[i2];
          if (track2.kind !== this.kind_ && track2.mode === "showing") {
            disabled = true;
            break;
          }
        }
        if (disabled) {
          this.disable();
        } else {
          this.enable();
        }
      };
      DescriptionsButton2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-descriptions-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
      };
      DescriptionsButton2.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
        return "vjs-descriptions-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
      };
      return DescriptionsButton2;
    }(TextTrackButton);
    DescriptionsButton.prototype.kind_ = "descriptions";
    DescriptionsButton.prototype.controlText_ = "Descriptions";
    Component.registerComponent("DescriptionsButton", DescriptionsButton);
    var SubtitlesButton = function(_TextTrackButton) {
      inherits(SubtitlesButton2, _TextTrackButton);
      function SubtitlesButton2(player, options, ready) {
        classCallCheck(this, SubtitlesButton2);
        return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
      }
      SubtitlesButton2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-subtitles-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
      };
      SubtitlesButton2.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
        return "vjs-subtitles-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
      };
      return SubtitlesButton2;
    }(TextTrackButton);
    SubtitlesButton.prototype.kind_ = "subtitles";
    SubtitlesButton.prototype.controlText_ = "Subtitles";
    Component.registerComponent("SubtitlesButton", SubtitlesButton);
    var CaptionSettingsMenuItem = function(_TextTrackMenuItem) {
      inherits(CaptionSettingsMenuItem2, _TextTrackMenuItem);
      function CaptionSettingsMenuItem2(player, options) {
        classCallCheck(this, CaptionSettingsMenuItem2);
        options.track = {
          player,
          kind: options.kind,
          label: options.kind + " settings",
          selectable: false,
          "default": false,
          mode: "disabled"
        };
        options.selectable = false;
        options.name = "CaptionSettingsMenuItem";
        var _this = possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));
        _this.addClass("vjs-texttrack-settings");
        _this.controlText(", opens " + options.kind + " settings dialog");
        return _this;
      }
      CaptionSettingsMenuItem2.prototype.handleClick = function handleClick(event2) {
        this.player().getChild("textTrackSettings").open();
      };
      return CaptionSettingsMenuItem2;
    }(TextTrackMenuItem);
    Component.registerComponent("CaptionSettingsMenuItem", CaptionSettingsMenuItem);
    var CaptionsButton = function(_TextTrackButton) {
      inherits(CaptionsButton2, _TextTrackButton);
      function CaptionsButton2(player, options, ready) {
        classCallCheck(this, CaptionsButton2);
        return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
      }
      CaptionsButton2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-captions-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
      };
      CaptionsButton2.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
        return "vjs-captions-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
      };
      CaptionsButton2.prototype.createItems = function createItems() {
        var items = [];
        if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
          items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.kind_ }));
          this.hideThreshold_ += 1;
        }
        return _TextTrackButton.prototype.createItems.call(this, items);
      };
      return CaptionsButton2;
    }(TextTrackButton);
    CaptionsButton.prototype.kind_ = "captions";
    CaptionsButton.prototype.controlText_ = "Captions";
    Component.registerComponent("CaptionsButton", CaptionsButton);
    var SubsCapsMenuItem = function(_TextTrackMenuItem) {
      inherits(SubsCapsMenuItem2, _TextTrackMenuItem);
      function SubsCapsMenuItem2() {
        classCallCheck(this, SubsCapsMenuItem2);
        return possibleConstructorReturn(this, _TextTrackMenuItem.apply(this, arguments));
      }
      SubsCapsMenuItem2.prototype.createEl = function createEl2(type, props, attrs) {
        var innerHTML = '<span class="vjs-menu-item-text">' + this.localize(this.options_.label);
        if (this.options_.track.kind === "captions") {
          innerHTML += '\n        <span aria-hidden="true" class="vjs-icon-placeholder"></span>\n        <span class="vjs-control-text"> ' + this.localize("Captions") + "</span>\n      ";
        }
        innerHTML += "</span>";
        var el = _TextTrackMenuItem.prototype.createEl.call(this, type, assign({
          innerHTML
        }, props), attrs);
        return el;
      };
      return SubsCapsMenuItem2;
    }(TextTrackMenuItem);
    Component.registerComponent("SubsCapsMenuItem", SubsCapsMenuItem);
    var SubsCapsButton = function(_TextTrackButton) {
      inherits(SubsCapsButton2, _TextTrackButton);
      function SubsCapsButton2(player) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        classCallCheck(this, SubsCapsButton2);
        var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options));
        _this.label_ = "subtitles";
        if (["en", "en-us", "en-ca", "fr-ca"].indexOf(_this.player_.language_) > -1) {
          _this.label_ = "captions";
        }
        _this.menuButton_.controlText(toTitleCase(_this.label_));
        return _this;
      }
      SubsCapsButton2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-subs-caps-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
      };
      SubsCapsButton2.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
        return "vjs-subs-caps-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
      };
      SubsCapsButton2.prototype.createItems = function createItems() {
        var items = [];
        if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
          items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.label_ }));
          this.hideThreshold_ += 1;
        }
        items = _TextTrackButton.prototype.createItems.call(this, items, SubsCapsMenuItem);
        return items;
      };
      return SubsCapsButton2;
    }(TextTrackButton);
    SubsCapsButton.prototype.kinds_ = ["captions", "subtitles"];
    SubsCapsButton.prototype.controlText_ = "Subtitles";
    Component.registerComponent("SubsCapsButton", SubsCapsButton);
    var AudioTrackMenuItem = function(_MenuItem) {
      inherits(AudioTrackMenuItem2, _MenuItem);
      function AudioTrackMenuItem2(player, options) {
        classCallCheck(this, AudioTrackMenuItem2);
        var track2 = options.track;
        var tracks = player.audioTracks();
        options.label = track2.label || track2.language || "Unknown";
        options.selected = track2.enabled;
        var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));
        _this.track = track2;
        _this.addClass("vjs-" + track2.kind + "-menu-item");
        var changeHandler = function changeHandler2() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this.handleTracksChange.apply(_this, args);
        };
        tracks.addEventListener("change", changeHandler);
        _this.on("dispose", function() {
          tracks.removeEventListener("change", changeHandler);
        });
        return _this;
      }
      AudioTrackMenuItem2.prototype.createEl = function createEl2(type, props, attrs) {
        var innerHTML = '<span class="vjs-menu-item-text">' + this.localize(this.options_.label);
        if (this.options_.track.kind === "main-desc") {
          innerHTML += '\n        <span aria-hidden="true" class="vjs-icon-placeholder"></span>\n        <span class="vjs-control-text"> ' + this.localize("Descriptions") + "</span>\n      ";
        }
        innerHTML += "</span>";
        var el = _MenuItem.prototype.createEl.call(this, type, assign({
          innerHTML
        }, props), attrs);
        return el;
      };
      AudioTrackMenuItem2.prototype.handleClick = function handleClick(event2) {
        var tracks = this.player_.audioTracks();
        _MenuItem.prototype.handleClick.call(this, event2);
        for (var i2 = 0; i2 < tracks.length; i2++) {
          var track2 = tracks[i2];
          track2.enabled = track2 === this.track;
        }
      };
      AudioTrackMenuItem2.prototype.handleTracksChange = function handleTracksChange(event2) {
        this.selected(this.track.enabled);
      };
      return AudioTrackMenuItem2;
    }(MenuItem);
    Component.registerComponent("AudioTrackMenuItem", AudioTrackMenuItem);
    var AudioTrackButton = function(_TrackButton) {
      inherits(AudioTrackButton2, _TrackButton);
      function AudioTrackButton2(player) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        classCallCheck(this, AudioTrackButton2);
        options.tracks = player.audioTracks();
        return possibleConstructorReturn(this, _TrackButton.call(this, player, options));
      }
      AudioTrackButton2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-audio-button " + _TrackButton.prototype.buildCSSClass.call(this);
      };
      AudioTrackButton2.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
        return "vjs-audio-button " + _TrackButton.prototype.buildWrapperCSSClass.call(this);
      };
      AudioTrackButton2.prototype.createItems = function createItems() {
        var items = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        this.hideThreshold_ = 1;
        var tracks = this.player_.audioTracks();
        for (var i2 = 0; i2 < tracks.length; i2++) {
          var track2 = tracks[i2];
          items.push(new AudioTrackMenuItem(this.player_, {
            track: track2,
            // MenuItem is selectable
            selectable: true,
            // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
            multiSelectable: false
          }));
        }
        return items;
      };
      return AudioTrackButton2;
    }(TrackButton);
    AudioTrackButton.prototype.controlText_ = "Audio Track";
    Component.registerComponent("AudioTrackButton", AudioTrackButton);
    var PlaybackRateMenuItem = function(_MenuItem) {
      inherits(PlaybackRateMenuItem2, _MenuItem);
      function PlaybackRateMenuItem2(player, options) {
        classCallCheck(this, PlaybackRateMenuItem2);
        var label = options.rate;
        var rate = parseFloat(label, 10);
        options.label = label;
        options.selected = rate === 1;
        options.selectable = true;
        options.multiSelectable = false;
        var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));
        _this.label = label;
        _this.rate = rate;
        _this.on(player, "ratechange", _this.update);
        return _this;
      }
      PlaybackRateMenuItem2.prototype.handleClick = function handleClick(event2) {
        _MenuItem.prototype.handleClick.call(this);
        this.player().playbackRate(this.rate);
      };
      PlaybackRateMenuItem2.prototype.update = function update(event2) {
        this.selected(this.player().playbackRate() === this.rate);
      };
      return PlaybackRateMenuItem2;
    }(MenuItem);
    PlaybackRateMenuItem.prototype.contentElType = "button";
    Component.registerComponent("PlaybackRateMenuItem", PlaybackRateMenuItem);
    var PlaybackRateMenuButton = function(_MenuButton) {
      inherits(PlaybackRateMenuButton2, _MenuButton);
      function PlaybackRateMenuButton2(player, options) {
        classCallCheck(this, PlaybackRateMenuButton2);
        var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));
        _this.updateVisibility();
        _this.updateLabel();
        _this.on(player, "loadstart", _this.updateVisibility);
        _this.on(player, "ratechange", _this.updateLabel);
        return _this;
      }
      PlaybackRateMenuButton2.prototype.createEl = function createEl$$1() {
        var el = _MenuButton.prototype.createEl.call(this);
        this.labelEl_ = createEl("div", {
          className: "vjs-playback-rate-value",
          innerHTML: "1x"
        });
        el.appendChild(this.labelEl_);
        return el;
      };
      PlaybackRateMenuButton2.prototype.dispose = function dispose() {
        this.labelEl_ = null;
        _MenuButton.prototype.dispose.call(this);
      };
      PlaybackRateMenuButton2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-playback-rate " + _MenuButton.prototype.buildCSSClass.call(this);
      };
      PlaybackRateMenuButton2.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
        return "vjs-playback-rate " + _MenuButton.prototype.buildWrapperCSSClass.call(this);
      };
      PlaybackRateMenuButton2.prototype.createMenu = function createMenu() {
        var menu = new Menu(this.player());
        var rates = this.playbackRates();
        if (rates) {
          for (var i2 = rates.length - 1; i2 >= 0; i2--) {
            menu.addChild(new PlaybackRateMenuItem(this.player(), { rate: rates[i2] + "x" }));
          }
        }
        return menu;
      };
      PlaybackRateMenuButton2.prototype.updateARIAAttributes = function updateARIAAttributes() {
        this.el().setAttribute("aria-valuenow", this.player().playbackRate());
      };
      PlaybackRateMenuButton2.prototype.handleClick = function handleClick(event2) {
        var currentRate = this.player().playbackRate();
        var rates = this.playbackRates();
        var newRate = rates[0];
        for (var i2 = 0; i2 < rates.length; i2++) {
          if (rates[i2] > currentRate) {
            newRate = rates[i2];
            break;
          }
        }
        this.player().playbackRate(newRate);
      };
      PlaybackRateMenuButton2.prototype.playbackRates = function playbackRates() {
        return this.options_.playbackRates || this.options_.playerOptions && this.options_.playerOptions.playbackRates;
      };
      PlaybackRateMenuButton2.prototype.playbackRateSupported = function playbackRateSupported() {
        return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
      };
      PlaybackRateMenuButton2.prototype.updateVisibility = function updateVisibility(event2) {
        if (this.playbackRateSupported()) {
          this.removeClass("vjs-hidden");
        } else {
          this.addClass("vjs-hidden");
        }
      };
      PlaybackRateMenuButton2.prototype.updateLabel = function updateLabel(event2) {
        if (this.playbackRateSupported()) {
          this.labelEl_.innerHTML = this.player().playbackRate() + "x";
        }
      };
      return PlaybackRateMenuButton2;
    }(MenuButton);
    PlaybackRateMenuButton.prototype.controlText_ = "Playback Rate";
    Component.registerComponent("PlaybackRateMenuButton", PlaybackRateMenuButton);
    var Spacer = function(_Component) {
      inherits(Spacer2, _Component);
      function Spacer2() {
        classCallCheck(this, Spacer2);
        return possibleConstructorReturn(this, _Component.apply(this, arguments));
      }
      Spacer2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-spacer " + _Component.prototype.buildCSSClass.call(this);
      };
      Spacer2.prototype.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "div", {
          className: this.buildCSSClass()
        });
      };
      return Spacer2;
    }(Component);
    Component.registerComponent("Spacer", Spacer);
    var CustomControlSpacer = function(_Spacer) {
      inherits(CustomControlSpacer2, _Spacer);
      function CustomControlSpacer2() {
        classCallCheck(this, CustomControlSpacer2);
        return possibleConstructorReturn(this, _Spacer.apply(this, arguments));
      }
      CustomControlSpacer2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-custom-control-spacer " + _Spacer.prototype.buildCSSClass.call(this);
      };
      CustomControlSpacer2.prototype.createEl = function createEl2() {
        var el = _Spacer.prototype.createEl.call(this, {
          className: this.buildCSSClass()
        });
        el.innerHTML = " ";
        return el;
      };
      return CustomControlSpacer2;
    }(Spacer);
    Component.registerComponent("CustomControlSpacer", CustomControlSpacer);
    var ControlBar = function(_Component) {
      inherits(ControlBar2, _Component);
      function ControlBar2() {
        classCallCheck(this, ControlBar2);
        return possibleConstructorReturn(this, _Component.apply(this, arguments));
      }
      ControlBar2.prototype.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-control-bar",
          dir: "ltr"
        });
      };
      return ControlBar2;
    }(Component);
    ControlBar.prototype.options_ = {
      children: ["playToggle", "volumePanel", "currentTimeDisplay", "timeDivider", "durationDisplay", "progressControl", "liveDisplay", "remainingTimeDisplay", "customControlSpacer", "playbackRateMenuButton", "chaptersButton", "descriptionsButton", "subsCapsButton", "audioTrackButton", "fullscreenToggle"]
    };
    Component.registerComponent("ControlBar", ControlBar);
    var ErrorDisplay = function(_ModalDialog) {
      inherits(ErrorDisplay2, _ModalDialog);
      function ErrorDisplay2(player, options) {
        classCallCheck(this, ErrorDisplay2);
        var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));
        _this.on(player, "error", _this.open);
        return _this;
      }
      ErrorDisplay2.prototype.buildCSSClass = function buildCSSClass() {
        return "vjs-error-display " + _ModalDialog.prototype.buildCSSClass.call(this);
      };
      ErrorDisplay2.prototype.content = function content() {
        var error = this.player().error();
        return error ? this.localize(error.message) : "";
      };
      return ErrorDisplay2;
    }(ModalDialog);
    ErrorDisplay.prototype.options_ = mergeOptions(ModalDialog.prototype.options_, {
      pauseOnOpen: false,
      fillAlways: true,
      temporary: false,
      uncloseable: true
    });
    Component.registerComponent("ErrorDisplay", ErrorDisplay);
    var LOCAL_STORAGE_KEY = "vjs-text-track-settings";
    var COLOR_BLACK = ["#000", "Black"];
    var COLOR_BLUE = ["#00F", "Blue"];
    var COLOR_CYAN = ["#0FF", "Cyan"];
    var COLOR_GREEN = ["#0F0", "Green"];
    var COLOR_MAGENTA = ["#F0F", "Magenta"];
    var COLOR_RED = ["#F00", "Red"];
    var COLOR_WHITE = ["#FFF", "White"];
    var COLOR_YELLOW = ["#FF0", "Yellow"];
    var OPACITY_OPAQUE = ["1", "Opaque"];
    var OPACITY_SEMI = ["0.5", "Semi-Transparent"];
    var OPACITY_TRANS = ["0", "Transparent"];
    var selectConfigs = {
      backgroundColor: {
        selector: ".vjs-bg-color > select",
        id: "captions-background-color-%s",
        label: "Color",
        options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
      },
      backgroundOpacity: {
        selector: ".vjs-bg-opacity > select",
        id: "captions-background-opacity-%s",
        label: "Transparency",
        options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]
      },
      color: {
        selector: ".vjs-fg-color > select",
        id: "captions-foreground-color-%s",
        label: "Color",
        options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
      },
      edgeStyle: {
        selector: ".vjs-edge-style > select",
        id: "%s",
        label: "Text Edge Style",
        options: [["none", "None"], ["raised", "Raised"], ["depressed", "Depressed"], ["uniform", "Uniform"], ["dropshadow", "Dropshadow"]]
      },
      fontFamily: {
        selector: ".vjs-font-family > select",
        id: "captions-font-family-%s",
        label: "Font Family",
        options: [["proportionalSansSerif", "Proportional Sans-Serif"], ["monospaceSansSerif", "Monospace Sans-Serif"], ["proportionalSerif", "Proportional Serif"], ["monospaceSerif", "Monospace Serif"], ["casual", "Casual"], ["script", "Script"], ["small-caps", "Small Caps"]]
      },
      fontPercent: {
        selector: ".vjs-font-percent > select",
        id: "captions-font-size-%s",
        label: "Font Size",
        options: [["0.50", "50%"], ["0.75", "75%"], ["1.00", "100%"], ["1.25", "125%"], ["1.50", "150%"], ["1.75", "175%"], ["2.00", "200%"], ["3.00", "300%"], ["4.00", "400%"]],
        "default": 2,
        parser: function parser(v) {
          return v === "1.00" ? null : Number(v);
        }
      },
      textOpacity: {
        selector: ".vjs-text-opacity > select",
        id: "captions-foreground-opacity-%s",
        label: "Transparency",
        options: [OPACITY_OPAQUE, OPACITY_SEMI]
      },
      // Options for this object are defined below.
      windowColor: {
        selector: ".vjs-window-color > select",
        id: "captions-window-color-%s",
        label: "Color"
      },
      // Options for this object are defined below.
      windowOpacity: {
        selector: ".vjs-window-opacity > select",
        id: "captions-window-opacity-%s",
        label: "Transparency",
        options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]
      }
    };
    selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;
    function parseOptionValue(value, parser) {
      if (parser) {
        value = parser(value);
      }
      if (value && value !== "none") {
        return value;
      }
    }
    function getSelectedOptionValue(el, parser) {
      var value = el.options[el.options.selectedIndex].value;
      return parseOptionValue(value, parser);
    }
    function setSelectedOption(el, value, parser) {
      if (!value) {
        return;
      }
      for (var i2 = 0; i2 < el.options.length; i2++) {
        if (parseOptionValue(el.options[i2].value, parser) === value) {
          el.selectedIndex = i2;
          break;
        }
      }
    }
    var TextTrackSettings = function(_ModalDialog) {
      inherits(TextTrackSettings2, _ModalDialog);
      function TextTrackSettings2(player, options) {
        classCallCheck(this, TextTrackSettings2);
        options.temporary = false;
        var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));
        _this.updateDisplay = bind(_this, _this.updateDisplay);
        _this.fill();
        _this.hasBeenOpened_ = _this.hasBeenFilled_ = true;
        _this.endDialog = createEl("p", {
          className: "vjs-control-text",
          textContent: _this.localize("End of dialog window.")
        });
        _this.el().appendChild(_this.endDialog);
        _this.setDefaults();
        if (options.persistTextTrackSettings === void 0) {
          _this.options_.persistTextTrackSettings = _this.options_.playerOptions.persistTextTrackSettings;
        }
        _this.on(_this.$(".vjs-done-button"), "click", function() {
          _this.saveSettings();
          _this.close();
        });
        _this.on(_this.$(".vjs-default-button"), "click", function() {
          _this.setDefaults();
          _this.updateDisplay();
        });
        each(selectConfigs, function(config) {
          _this.on(_this.$(config.selector), "change", _this.updateDisplay);
        });
        if (_this.options_.persistTextTrackSettings) {
          _this.restoreSettings();
        }
        return _this;
      }
      TextTrackSettings2.prototype.dispose = function dispose() {
        this.endDialog = null;
        _ModalDialog.prototype.dispose.call(this);
      };
      TextTrackSettings2.prototype.createElSelect_ = function createElSelect_(key) {
        var _this2 = this;
        var legendId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        var type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "label";
        var config = selectConfigs[key];
        var id = config.id.replace("%s", this.id_);
        var selectLabelledbyIds = [legendId, id].join(" ").trim();
        return ["<" + type + ' id="' + id + '" class="' + (type === "label" ? "vjs-label" : "") + '">', this.localize(config.label), "</" + type + ">", '<select aria-labelledby="' + selectLabelledbyIds + '">'].concat(config.options.map(function(o) {
          var optionId = id + "-" + o[1].replace(/\W+/g, "");
          return ['<option id="' + optionId + '" value="' + o[0] + '" ', 'aria-labelledby="' + selectLabelledbyIds + " " + optionId + '">', _this2.localize(o[1]), "</option>"].join("");
        })).concat("</select>").join("");
      };
      TextTrackSettings2.prototype.createElFgColor_ = function createElFgColor_() {
        var legendId = "captions-text-legend-" + this.id_;
        return ['<fieldset class="vjs-fg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize("Text"), "</legend>", this.createElSelect_("color", legendId), '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_("textOpacity", legendId), "</span>", "</fieldset>"].join("");
      };
      TextTrackSettings2.prototype.createElBgColor_ = function createElBgColor_() {
        var legendId = "captions-background-" + this.id_;
        return ['<fieldset class="vjs-bg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize("Background"), "</legend>", this.createElSelect_("backgroundColor", legendId), '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_("backgroundOpacity", legendId), "</span>", "</fieldset>"].join("");
      };
      TextTrackSettings2.prototype.createElWinColor_ = function createElWinColor_() {
        var legendId = "captions-window-" + this.id_;
        return ['<fieldset class="vjs-window-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize("Window"), "</legend>", this.createElSelect_("windowColor", legendId), '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_("windowOpacity", legendId), "</span>", "</fieldset>"].join("");
      };
      TextTrackSettings2.prototype.createElColors_ = function createElColors_() {
        return createEl("div", {
          className: "vjs-track-settings-colors",
          innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join("")
        });
      };
      TextTrackSettings2.prototype.createElFont_ = function createElFont_() {
        return createEl("div", {
          className: "vjs-track-settings-font",
          innerHTML: ['<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_("fontPercent", "", "legend"), "</fieldset>", '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_("edgeStyle", "", "legend"), "</fieldset>", '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_("fontFamily", "", "legend"), "</fieldset>"].join("")
        });
      };
      TextTrackSettings2.prototype.createElControls_ = function createElControls_() {
        var defaultsDescription = this.localize("restore all settings to the default values");
        return createEl("div", {
          className: "vjs-track-settings-controls",
          innerHTML: ['<button type="button" class="vjs-default-button" title="' + defaultsDescription + '">', this.localize("Reset"), '<span class="vjs-control-text"> ' + defaultsDescription + "</span>", "</button>", '<button type="button" class="vjs-done-button">' + this.localize("Done") + "</button>"].join("")
        });
      };
      TextTrackSettings2.prototype.content = function content() {
        return [this.createElColors_(), this.createElFont_(), this.createElControls_()];
      };
      TextTrackSettings2.prototype.label = function label() {
        return this.localize("Caption Settings Dialog");
      };
      TextTrackSettings2.prototype.description = function description() {
        return this.localize("Beginning of dialog window. Escape will cancel and close the window.");
      };
      TextTrackSettings2.prototype.buildCSSClass = function buildCSSClass() {
        return _ModalDialog.prototype.buildCSSClass.call(this) + " vjs-text-track-settings";
      };
      TextTrackSettings2.prototype.getValues = function getValues() {
        var _this3 = this;
        return reduce(selectConfigs, function(accum, config, key) {
          var value = getSelectedOptionValue(_this3.$(config.selector), config.parser);
          if (value !== void 0) {
            accum[key] = value;
          }
          return accum;
        }, {});
      };
      TextTrackSettings2.prototype.setValues = function setValues(values) {
        var _this4 = this;
        each(selectConfigs, function(config, key) {
          setSelectedOption(_this4.$(config.selector), values[key], config.parser);
        });
      };
      TextTrackSettings2.prototype.setDefaults = function setDefaults() {
        var _this5 = this;
        each(selectConfigs, function(config) {
          var index = config.hasOwnProperty("default") ? config["default"] : 0;
          _this5.$(config.selector).selectedIndex = index;
        });
      };
      TextTrackSettings2.prototype.restoreSettings = function restoreSettings() {
        var values = void 0;
        try {
          values = JSON.parse(window2.localStorage.getItem(LOCAL_STORAGE_KEY));
        } catch (err) {
          log.warn(err);
        }
        if (values) {
          this.setValues(values);
        }
      };
      TextTrackSettings2.prototype.saveSettings = function saveSettings() {
        if (!this.options_.persistTextTrackSettings) {
          return;
        }
        var values = this.getValues();
        try {
          if (Object.keys(values).length) {
            window2.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(values));
          } else {
            window2.localStorage.removeItem(LOCAL_STORAGE_KEY);
          }
        } catch (err) {
          log.warn(err);
        }
      };
      TextTrackSettings2.prototype.updateDisplay = function updateDisplay() {
        var ttDisplay = this.player_.getChild("textTrackDisplay");
        if (ttDisplay) {
          ttDisplay.updateDisplay();
        }
      };
      TextTrackSettings2.prototype.conditionalBlur_ = function conditionalBlur_() {
        this.previouslyActiveEl_ = null;
        this.off(document2, "keydown", this.handleKeyDown);
        var cb = this.player_.controlBar;
        var subsCapsBtn = cb && cb.subsCapsButton;
        var ccBtn = cb && cb.captionsButton;
        if (subsCapsBtn) {
          subsCapsBtn.focus();
        } else if (ccBtn) {
          ccBtn.focus();
        }
      };
      return TextTrackSettings2;
    }(ModalDialog);
    Component.registerComponent("TextTrackSettings", TextTrackSettings);
    var ResizeManager = function(_Component) {
      inherits(ResizeManager2, _Component);
      function ResizeManager2(player, options) {
        classCallCheck(this, ResizeManager2);
        var RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || window2.ResizeObserver;
        if (options.ResizeObserver === null) {
          RESIZE_OBSERVER_AVAILABLE = false;
        }
        var options_ = mergeOptions({ createEl: !RESIZE_OBSERVER_AVAILABLE }, options);
        var _this = possibleConstructorReturn(this, _Component.call(this, player, options_));
        _this.ResizeObserver = options.ResizeObserver || window2.ResizeObserver;
        _this.loadListener_ = null;
        _this.resizeObserver_ = null;
        _this.debouncedHandler_ = debounce(function() {
          _this.resizeHandler();
        }, 100, false, _this);
        if (RESIZE_OBSERVER_AVAILABLE) {
          _this.resizeObserver_ = new _this.ResizeObserver(_this.debouncedHandler_);
          _this.resizeObserver_.observe(player.el());
        } else {
          _this.loadListener_ = function() {
            if (!_this.el_ || !_this.el_.contentWindow) {
              return;
            }
            on(_this.el_.contentWindow, "resize", _this.debouncedHandler_);
          };
          _this.one("load", _this.loadListener_);
        }
        return _this;
      }
      ResizeManager2.prototype.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "iframe", {
          className: "vjs-resize-manager"
        });
      };
      ResizeManager2.prototype.resizeHandler = function resizeHandler() {
        if (!this.player_ || !this.player_.trigger) {
          return;
        }
        this.player_.trigger("playerresize");
      };
      ResizeManager2.prototype.dispose = function dispose() {
        if (this.debouncedHandler_) {
          this.debouncedHandler_.cancel();
        }
        if (this.resizeObserver_) {
          if (this.player_.el()) {
            this.resizeObserver_.unobserve(this.player_.el());
          }
          this.resizeObserver_.disconnect();
        }
        if (this.el_ && this.el_.contentWindow) {
          off(this.el_.contentWindow, "resize", this.debouncedHandler_);
        }
        if (this.loadListener_) {
          this.off("load", this.loadListener_);
        }
        this.ResizeObserver = null;
        this.resizeObserver = null;
        this.debouncedHandler_ = null;
        this.loadListener_ = null;
      };
      return ResizeManager2;
    }(Component);
    Component.registerComponent("ResizeManager", ResizeManager);
    var sourcesetLoad = function sourcesetLoad2(tech) {
      var el = tech.el();
      if (el.hasAttribute("src")) {
        tech.triggerSourceset(el.src);
        return true;
      }
      var sources = tech.$$("source");
      var srcUrls = [];
      var src = "";
      if (!sources.length) {
        return false;
      }
      for (var i2 = 0; i2 < sources.length; i2++) {
        var url = sources[i2].src;
        if (url && srcUrls.indexOf(url) === -1) {
          srcUrls.push(url);
        }
      }
      if (!srcUrls.length) {
        return false;
      }
      if (srcUrls.length === 1) {
        src = srcUrls[0];
      }
      tech.triggerSourceset(src);
      return true;
    };
    var innerHTMLDescriptorPolyfill = {};
    if (!IS_IE8) {
      innerHTMLDescriptorPolyfill = Object.defineProperty({}, "innerHTML", {
        get: function get() {
          return this.cloneNode(true).innerHTML;
        },
        set: function set(v) {
          var dummy = document2.createElement(this.nodeName.toLowerCase());
          dummy.innerHTML = v;
          var docFrag = document2.createDocumentFragment();
          while (dummy.childNodes.length) {
            docFrag.appendChild(dummy.childNodes[0]);
          }
          this.innerText = "";
          window2.Element.prototype.appendChild.call(this, docFrag);
          return this.innerHTML;
        }
      });
    }
    var getDescriptor = function getDescriptor2(priority, prop) {
      var descriptor = {};
      for (var i2 = 0; i2 < priority.length; i2++) {
        descriptor = Object.getOwnPropertyDescriptor(priority[i2], prop);
        if (descriptor && descriptor.set && descriptor.get) {
          break;
        }
      }
      descriptor.enumerable = true;
      descriptor.configurable = true;
      return descriptor;
    };
    var getInnerHTMLDescriptor = function getInnerHTMLDescriptor2(tech) {
      return getDescriptor([tech.el(), window2.HTMLMediaElement.prototype, window2.Element.prototype, innerHTMLDescriptorPolyfill], "innerHTML");
    };
    var firstSourceWatch = function firstSourceWatch2(tech) {
      var el = tech.el();
      if (el.resetSourceWatch_) {
        return;
      }
      var old = {};
      var innerDescriptor = getInnerHTMLDescriptor(tech);
      var appendWrapper = function appendWrapper2(appendFn) {
        return function() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var retval = appendFn.apply(el, args);
          sourcesetLoad(tech);
          return retval;
        };
      };
      ["append", "appendChild", "insertAdjacentHTML"].forEach(function(k) {
        if (!el[k]) {
          return;
        }
        old[k] = el[k];
        el[k] = appendWrapper(old[k]);
      });
      Object.defineProperty(el, "innerHTML", mergeOptions(innerDescriptor, {
        set: appendWrapper(innerDescriptor.set)
      }));
      el.resetSourceWatch_ = function() {
        el.resetSourceWatch_ = null;
        Object.keys(old).forEach(function(k) {
          el[k] = old[k];
        });
        Object.defineProperty(el, "innerHTML", innerDescriptor);
      };
      tech.one("sourceset", el.resetSourceWatch_);
    };
    var srcDescriptorPolyfill = {};
    if (!IS_IE8) {
      srcDescriptorPolyfill = Object.defineProperty({}, "src", {
        get: function get() {
          if (this.hasAttribute("src")) {
            return getAbsoluteURL(window2.Element.prototype.getAttribute.call(this, "src"));
          }
          return "";
        },
        set: function set(v) {
          window2.Element.prototype.setAttribute.call(this, "src", v);
          return v;
        }
      });
    }
    var getSrcDescriptor = function getSrcDescriptor2(tech) {
      return getDescriptor([tech.el(), window2.HTMLMediaElement.prototype, srcDescriptorPolyfill], "src");
    };
    var setupSourceset = function setupSourceset2(tech) {
      if (!tech.featuresSourceset) {
        return;
      }
      var el = tech.el();
      if (el.resetSourceset_) {
        return;
      }
      var srcDescriptor = getSrcDescriptor(tech);
      var oldSetAttribute = el.setAttribute;
      var oldLoad = el.load;
      Object.defineProperty(el, "src", mergeOptions(srcDescriptor, {
        set: function set(v) {
          var retval = srcDescriptor.set.call(el, v);
          tech.triggerSourceset(el.src);
          return retval;
        }
      }));
      el.setAttribute = function(n, v) {
        var retval = oldSetAttribute.call(el, n, v);
        if (/src/i.test(n)) {
          tech.triggerSourceset(el.src);
        }
        return retval;
      };
      el.load = function() {
        var retval = oldLoad.call(el);
        if (!sourcesetLoad(tech)) {
          tech.triggerSourceset("");
          firstSourceWatch(tech);
        }
        return retval;
      };
      if (el.currentSrc) {
        tech.triggerSourceset(el.currentSrc);
      } else if (!sourcesetLoad(tech)) {
        firstSourceWatch(tech);
      }
      el.resetSourceset_ = function() {
        el.resetSourceset_ = null;
        el.load = oldLoad;
        el.setAttribute = oldSetAttribute;
        Object.defineProperty(el, "src", srcDescriptor);
        if (el.resetSourceWatch_) {
          el.resetSourceWatch_();
        }
      };
    };
    var _templateObject$2 = taggedTemplateLiteralLoose(["Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.\n            This may prevent text tracks from loading."], ["Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.\n            This may prevent text tracks from loading."]);
    var Html5 = function(_Tech) {
      inherits(Html52, _Tech);
      function Html52(options, ready) {
        classCallCheck(this, Html52);
        var _this = possibleConstructorReturn(this, _Tech.call(this, options, ready));
        var source = options.source;
        var crossoriginTracks = false;
        if (source && (_this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
          _this.setSource(source);
        } else {
          _this.handleLateInit_(_this.el_);
        }
        if (options.enableSourceset) {
          _this.setupSourcesetHandling_();
        }
        if (_this.el_.hasChildNodes()) {
          var nodes = _this.el_.childNodes;
          var nodesLength = nodes.length;
          var removeNodes = [];
          while (nodesLength--) {
            var node = nodes[nodesLength];
            var nodeName = node.nodeName.toLowerCase();
            if (nodeName === "track") {
              if (!_this.featuresNativeTextTracks) {
                removeNodes.push(node);
              } else {
                _this.remoteTextTrackEls().addTrackElement_(node);
                _this.remoteTextTracks().addTrack(node.track);
                _this.textTracks().addTrack(node.track);
                if (!crossoriginTracks && !_this.el_.hasAttribute("crossorigin") && isCrossOrigin(node.src)) {
                  crossoriginTracks = true;
                }
              }
            }
          }
          for (var i2 = 0; i2 < removeNodes.length; i2++) {
            _this.el_.removeChild(removeNodes[i2]);
          }
        }
        _this.proxyNativeTracks_();
        if (_this.featuresNativeTextTracks && crossoriginTracks) {
          log.warn(tsml(_templateObject$2));
        }
        _this.restoreMetadataTracksInIOSNativePlayer_();
        if ((TOUCH_ENABLED || IS_IPHONE || IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {
          _this.setControls(true);
        }
        _this.proxyWebkitFullscreen_();
        _this.triggerReady();
        return _this;
      }
      Html52.prototype.dispose = function dispose() {
        if (this.el_ && this.el_.resetSourceset_) {
          this.el_.resetSourceset_();
        }
        Html52.disposeMediaElement(this.el_);
        this.options_ = null;
        _Tech.prototype.dispose.call(this);
      };
      Html52.prototype.setupSourcesetHandling_ = function setupSourcesetHandling_() {
        setupSourceset(this);
      };
      Html52.prototype.restoreMetadataTracksInIOSNativePlayer_ = function restoreMetadataTracksInIOSNativePlayer_() {
        var textTracks = this.textTracks();
        var metadataTracksPreFullscreenState = void 0;
        var takeMetadataTrackSnapshot = function takeMetadataTrackSnapshot2() {
          metadataTracksPreFullscreenState = [];
          for (var i2 = 0; i2 < textTracks.length; i2++) {
            var track2 = textTracks[i2];
            if (track2.kind === "metadata") {
              metadataTracksPreFullscreenState.push({
                track: track2,
                storedMode: track2.mode
              });
            }
          }
        };
        takeMetadataTrackSnapshot();
        textTracks.addEventListener("change", takeMetadataTrackSnapshot);
        this.on("dispose", function() {
          return textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
        });
        var restoreTrackMode = function restoreTrackMode2() {
          for (var i2 = 0; i2 < metadataTracksPreFullscreenState.length; i2++) {
            var storedTrack = metadataTracksPreFullscreenState[i2];
            if (storedTrack.track.mode === "disabled" && storedTrack.track.mode !== storedTrack.storedMode) {
              storedTrack.track.mode = storedTrack.storedMode;
            }
          }
          textTracks.removeEventListener("change", restoreTrackMode2);
        };
        this.on("webkitbeginfullscreen", function() {
          textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
          textTracks.removeEventListener("change", restoreTrackMode);
          textTracks.addEventListener("change", restoreTrackMode);
        });
        this.on("webkitendfullscreen", function() {
          textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
          textTracks.addEventListener("change", takeMetadataTrackSnapshot);
          textTracks.removeEventListener("change", restoreTrackMode);
        });
      };
      Html52.prototype.proxyNativeTracks_ = function proxyNativeTracks_() {
        var _this2 = this;
        NORMAL.names.forEach(function(name) {
          var props = NORMAL[name];
          var elTracks = _this2.el()[props.getterName];
          var techTracks = _this2[props.getterName]();
          if (!_this2["featuresNative" + props.capitalName + "Tracks"] || !elTracks || !elTracks.addEventListener) {
            return;
          }
          var listeners = {
            change: function change(e) {
              techTracks.trigger({
                type: "change",
                target: techTracks,
                currentTarget: techTracks,
                srcElement: techTracks
              });
            },
            addtrack: function addtrack(e) {
              techTracks.addTrack(e.track);
            },
            removetrack: function removetrack(e) {
              techTracks.removeTrack(e.track);
            }
          };
          var removeOldTracks = function removeOldTracks2() {
            var removeTracks = [];
            for (var i2 = 0; i2 < techTracks.length; i2++) {
              var found = false;
              for (var j = 0; j < elTracks.length; j++) {
                if (elTracks[j] === techTracks[i2]) {
                  found = true;
                  break;
                }
              }
              if (!found) {
                removeTracks.push(techTracks[i2]);
              }
            }
            while (removeTracks.length) {
              techTracks.removeTrack(removeTracks.shift());
            }
          };
          Object.keys(listeners).forEach(function(eventName) {
            var listener = listeners[eventName];
            elTracks.addEventListener(eventName, listener);
            _this2.on("dispose", function(e) {
              return elTracks.removeEventListener(eventName, listener);
            });
          });
          _this2.on("loadstart", removeOldTracks);
          _this2.on("dispose", function(e) {
            return _this2.off("loadstart", removeOldTracks);
          });
        });
      };
      Html52.prototype.createEl = function createEl$$1() {
        var el = this.options_.tag;
        if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
          if (el) {
            var clone = el.cloneNode(true);
            if (el.parentNode) {
              el.parentNode.insertBefore(clone, el);
            }
            Html52.disposeMediaElement(el);
            el = clone;
          } else {
            el = document2.createElement("video");
            var tagAttributes = this.options_.tag && getAttributes(this.options_.tag);
            var attributes = mergeOptions({}, tagAttributes);
            if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
              delete attributes.controls;
            }
            setAttributes(el, assign(attributes, {
              id: this.options_.techId,
              "class": "vjs-tech"
            }));
          }
          el.playerId = this.options_.playerId;
        }
        if (typeof this.options_.preload !== "undefined") {
          setAttribute(el, "preload", this.options_.preload);
        }
        var settingsAttrs = ["loop", "muted", "playsinline", "autoplay"];
        for (var i2 = 0; i2 < settingsAttrs.length; i2++) {
          var attr = settingsAttrs[i2];
          var value = this.options_[attr];
          if (typeof value !== "undefined") {
            if (value) {
              setAttribute(el, attr, attr);
            } else {
              removeAttribute(el, attr);
            }
            el[attr] = value;
          }
        }
        return el;
      };
      Html52.prototype.handleLateInit_ = function handleLateInit_(el) {
        if (el.networkState === 0 || el.networkState === 3) {
          return;
        }
        if (el.readyState === 0) {
          var loadstartFired = false;
          var setLoadstartFired = function setLoadstartFired2() {
            loadstartFired = true;
          };
          this.on("loadstart", setLoadstartFired);
          var triggerLoadstart = function triggerLoadstart2() {
            if (!loadstartFired) {
              this.trigger("loadstart");
            }
          };
          this.on("loadedmetadata", triggerLoadstart);
          this.ready(function() {
            this.off("loadstart", setLoadstartFired);
            this.off("loadedmetadata", triggerLoadstart);
            if (!loadstartFired) {
              this.trigger("loadstart");
            }
          });
          return;
        }
        var eventsToTrigger = ["loadstart"];
        eventsToTrigger.push("loadedmetadata");
        if (el.readyState >= 2) {
          eventsToTrigger.push("loadeddata");
        }
        if (el.readyState >= 3) {
          eventsToTrigger.push("canplay");
        }
        if (el.readyState >= 4) {
          eventsToTrigger.push("canplaythrough");
        }
        this.ready(function() {
          eventsToTrigger.forEach(function(type) {
            this.trigger(type);
          }, this);
        });
      };
      Html52.prototype.setCurrentTime = function setCurrentTime(seconds) {
        try {
          this.el_.currentTime = seconds;
        } catch (e) {
          log(e, "Video is not ready. (Video.js)");
        }
      };
      Html52.prototype.duration = function duration() {
        var _this3 = this;
        if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {
          var checkProgress = function checkProgress2() {
            if (_this3.el_.currentTime > 0) {
              if (_this3.el_.duration === Infinity) {
                _this3.trigger("durationchange");
              }
              _this3.off("timeupdate", checkProgress2);
            }
          };
          this.on("timeupdate", checkProgress);
          return NaN;
        }
        return this.el_.duration || NaN;
      };
      Html52.prototype.width = function width() {
        return this.el_.offsetWidth;
      };
      Html52.prototype.height = function height() {
        return this.el_.offsetHeight;
      };
      Html52.prototype.proxyWebkitFullscreen_ = function proxyWebkitFullscreen_() {
        var _this4 = this;
        if (!("webkitDisplayingFullscreen" in this.el_)) {
          return;
        }
        var endFn = function endFn2() {
          this.trigger("fullscreenchange", { isFullscreen: false });
        };
        var beginFn = function beginFn2() {
          if ("webkitPresentationMode" in this.el_ && this.el_.webkitPresentationMode !== "picture-in-picture") {
            this.one("webkitendfullscreen", endFn);
            this.trigger("fullscreenchange", { isFullscreen: true });
          }
        };
        this.on("webkitbeginfullscreen", beginFn);
        this.on("dispose", function() {
          _this4.off("webkitbeginfullscreen", beginFn);
          _this4.off("webkitendfullscreen", endFn);
        });
      };
      Html52.prototype.supportsFullScreen = function supportsFullScreen() {
        if (typeof this.el_.webkitEnterFullScreen === "function") {
          var userAgent = window2.navigator && window2.navigator.userAgent || "";
          if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {
            return true;
          }
        }
        return false;
      };
      Html52.prototype.enterFullScreen = function enterFullScreen() {
        var video = this.el_;
        if (video.paused && video.networkState <= video.HAVE_METADATA) {
          this.el_.play();
          this.setTimeout(function() {
            video.pause();
            video.webkitEnterFullScreen();
          }, 0);
        } else {
          video.webkitEnterFullScreen();
        }
      };
      Html52.prototype.exitFullScreen = function exitFullScreen() {
        this.el_.webkitExitFullScreen();
      };
      Html52.prototype.src = function src(_src) {
        if (_src === void 0) {
          return this.el_.src;
        }
        this.setSrc(_src);
      };
      Html52.prototype.reset = function reset() {
        Html52.resetMediaElement(this.el_);
      };
      Html52.prototype.currentSrc = function currentSrc() {
        if (this.currentSource_) {
          return this.currentSource_.src;
        }
        return this.el_.currentSrc;
      };
      Html52.prototype.setControls = function setControls(val) {
        this.el_.controls = !!val;
      };
      Html52.prototype.addTextTrack = function addTextTrack(kind, label, language) {
        if (!this.featuresNativeTextTracks) {
          return _Tech.prototype.addTextTrack.call(this, kind, label, language);
        }
        return this.el_.addTextTrack(kind, label, language);
      };
      Html52.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {
        if (!this.featuresNativeTextTracks) {
          return _Tech.prototype.createRemoteTextTrack.call(this, options);
        }
        var htmlTrackElement = document2.createElement("track");
        if (options.kind) {
          htmlTrackElement.kind = options.kind;
        }
        if (options.label) {
          htmlTrackElement.label = options.label;
        }
        if (options.language || options.srclang) {
          htmlTrackElement.srclang = options.language || options.srclang;
        }
        if (options["default"]) {
          htmlTrackElement["default"] = options["default"];
        }
        if (options.id) {
          htmlTrackElement.id = options.id;
        }
        if (options.src) {
          htmlTrackElement.src = options.src;
        }
        return htmlTrackElement;
      };
      Html52.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
        var htmlTrackElement = _Tech.prototype.addRemoteTextTrack.call(this, options, manualCleanup);
        if (this.featuresNativeTextTracks) {
          this.el().appendChild(htmlTrackElement);
        }
        return htmlTrackElement;
      };
      Html52.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track2) {
        _Tech.prototype.removeRemoteTextTrack.call(this, track2);
        if (this.featuresNativeTextTracks) {
          var tracks = this.$$("track");
          var i2 = tracks.length;
          while (i2--) {
            if (track2 === tracks[i2] || track2 === tracks[i2].track) {
              this.el().removeChild(tracks[i2]);
            }
          }
        }
      };
      Html52.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
        if (typeof this.el().getVideoPlaybackQuality === "function") {
          return this.el().getVideoPlaybackQuality();
        }
        var videoPlaybackQuality = {};
        if (typeof this.el().webkitDroppedFrameCount !== "undefined" && typeof this.el().webkitDecodedFrameCount !== "undefined") {
          videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;
          videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;
        }
        if (window2.performance && typeof window2.performance.now === "function") {
          videoPlaybackQuality.creationTime = window2.performance.now();
        } else if (window2.performance && window2.performance.timing && typeof window2.performance.timing.navigationStart === "number") {
          videoPlaybackQuality.creationTime = window2.Date.now() - window2.performance.timing.navigationStart;
        }
        return videoPlaybackQuality;
      };
      return Html52;
    }(Tech);
    if (isReal()) {
      Html5.TEST_VID = document2.createElement("video");
      track = document2.createElement("track");
      track.kind = "captions";
      track.srclang = "en";
      track.label = "English";
      Html5.TEST_VID.appendChild(track);
    }
    var track;
    Html5.isSupported = function() {
      try {
        Html5.TEST_VID.volume = 0.5;
      } catch (e) {
        return false;
      }
      return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);
    };
    Html5.canPlayType = function(type) {
      return Html5.TEST_VID.canPlayType(type);
    };
    Html5.canPlaySource = function(srcObj, options) {
      return Html5.canPlayType(srcObj.type);
    };
    Html5.canControlVolume = function() {
      try {
        var volume = Html5.TEST_VID.volume;
        Html5.TEST_VID.volume = volume / 2 + 0.1;
        return volume !== Html5.TEST_VID.volume;
      } catch (e) {
        return false;
      }
    };
    Html5.canMuteVolume = function() {
      try {
        var muted = Html5.TEST_VID.muted;
        Html5.TEST_VID.muted = !muted;
        if (Html5.TEST_VID.muted) {
          setAttribute(Html5.TEST_VID, "muted", "muted");
        } else {
          removeAttribute(Html5.TEST_VID, "muted", "muted");
        }
        return muted !== Html5.TEST_VID.muted;
      } catch (e) {
        return false;
      }
    };
    Html5.canControlPlaybackRate = function() {
      if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {
        return false;
      }
      try {
        var playbackRate = Html5.TEST_VID.playbackRate;
        Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
        return playbackRate !== Html5.TEST_VID.playbackRate;
      } catch (e) {
        return false;
      }
    };
    Html5.canOverrideAttributes = function() {
      if (IS_IE8) {
        return false;
      }
      try {
        var noop = function noop2() {
        };
        Object.defineProperty(document2.createElement("video"), "src", { get: noop, set: noop });
        Object.defineProperty(document2.createElement("audio"), "src", { get: noop, set: noop });
        Object.defineProperty(document2.createElement("video"), "innerHTML", { get: noop, set: noop });
        Object.defineProperty(document2.createElement("audio"), "innerHTML", { get: noop, set: noop });
      } catch (e) {
        return false;
      }
      return true;
    };
    Html5.supportsNativeTextTracks = function() {
      return IS_ANY_SAFARI || IS_IOS && IS_CHROME;
    };
    Html5.supportsNativeVideoTracks = function() {
      return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);
    };
    Html5.supportsNativeAudioTracks = function() {
      return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);
    };
    Html5.Events = ["loadstart", "suspend", "abort", "error", "emptied", "stalled", "loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "seeking", "seeked", "ended", "durationchange", "timeupdate", "progress", "play", "pause", "ratechange", "resize", "volumechange"];
    Html5.prototype.featuresVolumeControl = Html5.canControlVolume();
    Html5.prototype.featuresMuteControl = Html5.canMuteVolume();
    Html5.prototype.featuresPlaybackRate = Html5.canControlPlaybackRate();
    Html5.prototype.featuresSourceset = Html5.canOverrideAttributes();
    Html5.prototype.movingMediaElementInDOM = !IS_IOS;
    Html5.prototype.featuresFullscreenResize = true;
    Html5.prototype.featuresProgressEvents = true;
    Html5.prototype.featuresTimeupdateEvents = true;
    Html5.prototype.featuresNativeTextTracks = Html5.supportsNativeTextTracks();
    Html5.prototype.featuresNativeVideoTracks = Html5.supportsNativeVideoTracks();
    Html5.prototype.featuresNativeAudioTracks = Html5.supportsNativeAudioTracks();
    var canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType;
    var mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
    var mp4RE = /^video\/mp4/i;
    Html5.patchCanPlayType = function() {
      if (ANDROID_VERSION >= 4 && !IS_FIREFOX && !IS_CHROME) {
        Html5.TEST_VID.constructor.prototype.canPlayType = function(type) {
          if (type && mpegurlRE.test(type)) {
            return "maybe";
          }
          return canPlayType.call(this, type);
        };
      } else if (IS_OLD_ANDROID) {
        Html5.TEST_VID.constructor.prototype.canPlayType = function(type) {
          if (type && mp4RE.test(type)) {
            return "maybe";
          }
          return canPlayType.call(this, type);
        };
      }
    };
    Html5.unpatchCanPlayType = function() {
      var r = Html5.TEST_VID.constructor.prototype.canPlayType;
      Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;
      return r;
    };
    Html5.patchCanPlayType();
    Html5.disposeMediaElement = function(el) {
      if (!el) {
        return;
      }
      if (el.parentNode) {
        el.parentNode.removeChild(el);
      }
      while (el.hasChildNodes()) {
        el.removeChild(el.firstChild);
      }
      el.removeAttribute("src");
      if (typeof el.load === "function") {
        (function() {
          try {
            el.load();
          } catch (e) {
          }
        })();
      }
    };
    Html5.resetMediaElement = function(el) {
      if (!el) {
        return;
      }
      var sources = el.querySelectorAll("source");
      var i2 = sources.length;
      while (i2--) {
        el.removeChild(sources[i2]);
      }
      el.removeAttribute("src");
      if (typeof el.load === "function") {
        (function() {
          try {
            el.load();
          } catch (e) {
          }
        })();
      }
    };
    [
      /**
       * Get the value of `muted` from the media element. `muted` indicates
       * that the volume for the media should be set to silent. This does not actually change
       * the `volume` attribute.
       *
       * @method Html5#muted
       * @return {boolean}
       *         - True if the value of `volume` should be ignored and the audio set to silent.
       *         - False if the value of `volume` should be used.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
       */
      "muted",
      /**
       * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
       * whether the media should start muted or not. Only changes the default state of the
       * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the
       * current state.
       *
       * @method Html5#defaultMuted
       * @return {boolean}
       *         - The value of `defaultMuted` from the media element.
       *         - True indicates that the media should start muted.
       *         - False indicates that the media should not start muted
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
       */
      "defaultMuted",
      /**
       * Get the value of `autoplay` from the media element. `autoplay` indicates
       * that the media should start to play as soon as the page is ready.
       *
       * @method Html5#autoplay
       * @return {boolean}
       *         - The value of `autoplay` from the media element.
       *         - True indicates that the media should start as soon as the page loads.
       *         - False indicates that the media should not start as soon as the page loads.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
       */
      "autoplay",
      /**
       * Get the value of `controls` from the media element. `controls` indicates
       * whether the native media controls should be shown or hidden.
       *
       * @method Html5#controls
       * @return {boolean}
       *         - The value of `controls` from the media element.
       *         - True indicates that native controls should be showing.
       *         - False indicates that native controls should be hidden.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}
       */
      "controls",
      /**
       * Get the value of `loop` from the media element. `loop` indicates
       * that the media should return to the start of the media and continue playing once
       * it reaches the end.
       *
       * @method Html5#loop
       * @return {boolean}
       *         - The value of `loop` from the media element.
       *         - True indicates that playback should seek back to start once
       *           the end of a media is reached.
       *         - False indicates that playback should not loop back to the start when the
       *           end of the media is reached.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
       */
      "loop",
      /**
       * Get the value of `playsinline` from the media element. `playsinline` indicates
       * to the browser that non-fullscreen playback is preferred when fullscreen
       * playback is the native default, such as in iOS Safari.
       *
       * @method Html5#playsinline
       * @return {boolean}
       *         - The value of `playsinline` from the media element.
       *         - True indicates that the media should play inline.
       *         - False indicates that the media should not play inline.
       *
       * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
       */
      "playsinline"
    ].forEach(function(prop) {
      Html5.prototype[prop] = function() {
        return this.el_[prop] || this.el_.hasAttribute(prop);
      };
    });
    [
      /**
       * Set the value of `muted` on the media element. `muted` indicates that the current
       * audio level should be silent.
       *
       * @method Html5#setMuted
       * @param {boolean} muted
       *        - True if the audio should be set to silent
       *        - False otherwise
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
       */
      "muted",
      /**
       * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current
       * audio level should be silent, but will only effect the muted level on intial playback..
       *
       * @method Html5.prototype.setDefaultMuted
       * @param {boolean} defaultMuted
       *        - True if the audio should be set to silent
       *        - False otherwise
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
       */
      "defaultMuted",
      /**
       * Set the value of `autoplay` on the media element. `autoplay` indicates
       * that the media should start to play as soon as the page is ready.
       *
       * @method Html5#setAutoplay
       * @param {boolean} autoplay
       *         - True indicates that the media should start as soon as the page loads.
       *         - False indicates that the media should not start as soon as the page loads.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
       */
      "autoplay",
      /**
       * Set the value of `loop` on the media element. `loop` indicates
       * that the media should return to the start of the media and continue playing once
       * it reaches the end.
       *
       * @method Html5#setLoop
       * @param {boolean} loop
       *         - True indicates that playback should seek back to start once
       *           the end of a media is reached.
       *         - False indicates that playback should not loop back to the start when the
       *           end of the media is reached.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
       */
      "loop",
      /**
       * Set the value of `playsinline` from the media element. `playsinline` indicates
       * to the browser that non-fullscreen playback is preferred when fullscreen
       * playback is the native default, such as in iOS Safari.
       *
       * @method Html5#setPlaysinline
       * @param {boolean} playsinline
       *         - True indicates that the media should play inline.
       *         - False indicates that the media should not play inline.
       *
       * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
       */
      "playsinline"
    ].forEach(function(prop) {
      Html5.prototype["set" + toTitleCase(prop)] = function(v) {
        this.el_[prop] = v;
        if (v) {
          this.el_.setAttribute(prop, prop);
        } else {
          this.el_.removeAttribute(prop);
        }
      };
    });
    [
      /**
       * Get the value of `paused` from the media element. `paused` indicates whether the media element
       * is currently paused or not.
       *
       * @method Html5#paused
       * @return {boolean}
       *         The value of `paused` from the media element.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}
       */
      "paused",
      /**
       * Get the value of `currentTime` from the media element. `currentTime` indicates
       * the current second that the media is at in playback.
       *
       * @method Html5#currentTime
       * @return {number}
       *         The value of `currentTime` from the media element.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}
       */
      "currentTime",
      /**
       * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`
       * object that represents the parts of the media that are already downloaded and
       * available for playback.
       *
       * @method Html5#buffered
       * @return {TimeRange}
       *         The value of `buffered` from the media element.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}
       */
      "buffered",
      /**
       * Get the value of `volume` from the media element. `volume` indicates
       * the current playback volume of audio for a media. `volume` will be a value from 0
       * (silent) to 1 (loudest and default).
       *
       * @method Html5#volume
       * @return {number}
       *         The value of `volume` from the media element. Value will be between 0-1.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
       */
      "volume",
      /**
       * Get the value of `poster` from the media element. `poster` indicates
       * that the url of an image file that can/will be shown when no media data is available.
       *
       * @method Html5#poster
       * @return {string}
       *         The value of `poster` from the media element. Value will be a url to an
       *         image.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}
       */
      "poster",
      /**
       * Get the value of `preload` from the media element. `preload` indicates
       * what should download before the media is interacted with. It can have the following
       * values:
       * - none: nothing should be downloaded
       * - metadata: poster and the first few frames of the media may be downloaded to get
       *   media dimensions and other metadata
       * - auto: allow the media and metadata for the media to be downloaded before
       *    interaction
       *
       * @method Html5#preload
       * @return {string}
       *         The value of `preload` from the media element. Will be 'none', 'metadata',
       *         or 'auto'.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
       */
      "preload",
      /**
       * Get the value of the `error` from the media element. `error` indicates any
       * MediaError that may have occured during playback. If error returns null there is no
       * current error.
       *
       * @method Html5#error
       * @return {MediaError|null}
       *         The value of `error` from the media element. Will be `MediaError` if there
       *         is a current error and null otherwise.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}
       */
      "error",
      /**
       * Get the value of `seeking` from the media element. `seeking` indicates whether the
       * media is currently seeking to a new position or not.
       *
       * @method Html5#seeking
       * @return {boolean}
       *         - The value of `seeking` from the media element.
       *         - True indicates that the media is currently seeking to a new position.
       *         - Flase indicates that the media is not seeking to a new position at this time.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}
       */
      "seeking",
      /**
       * Get the value of `seekable` from the media element. `seekable` returns a
       * `TimeRange` object indicating ranges of time that can currently be `seeked` to.
       *
       * @method Html5#seekable
       * @return {TimeRange}
       *         The value of `seekable` from the media element. A `TimeRange` object
       *         indicating the current ranges of time that can be seeked to.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}
       */
      "seekable",
      /**
       * Get the value of `ended` from the media element. `ended` indicates whether
       * the media has reached the end or not.
       *
       * @method Html5#ended
       * @return {boolean}
       *         - The value of `ended` from the media element.
       *         - True indicates that the media has ended.
       *         - False indicates that the media has not ended.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}
       */
      "ended",
      /**
       * Get the value of `playbackRate` from the media element. `playbackRate` indicates
       * the rate at which the media is currently playing back. Examples:
       *   - if playbackRate is set to 2, media will play twice as fast.
       *   - if playbackRate is set to 0.5, media will play half as fast.
       *
       * @method Html5#playbackRate
       * @return {number}
       *         The value of `playbackRate` from the media element. A number indicating
       *         the current playback speed of the media, where 1 is normal speed.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
       */
      "playbackRate",
      /**
       * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates
       * the rate at which the media is currently playing back. This value will not indicate the current
       * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.
       *
       * Examples:
       *   - if defaultPlaybackRate is set to 2, media will play twice as fast.
       *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.
       *
       * @method Html5.prototype.defaultPlaybackRate
       * @return {number}
       *         The value of `defaultPlaybackRate` from the media element. A number indicating
       *         the current playback speed of the media, where 1 is normal speed.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
       */
      "defaultPlaybackRate",
      /**
       * Get the value of `played` from the media element. `played` returns a `TimeRange`
       * object representing points in the media timeline that have been played.
       *
       * @method Html5#played
       * @return {TimeRange}
       *         The value of `played` from the media element. A `TimeRange` object indicating
       *         the ranges of time that have been played.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}
       */
      "played",
      /**
       * Get the value of `networkState` from the media element. `networkState` indicates
       * the current network state. It returns an enumeration from the following list:
       * - 0: NETWORK_EMPTY
       * - 1: NEWORK_IDLE
       * - 2: NETWORK_LOADING
       * - 3: NETWORK_NO_SOURCE
       *
       * @method Html5#networkState
       * @return {number}
       *         The value of `networkState` from the media element. This will be a number
       *         from the list in the description.
       *
       * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}
       */
      "networkState",
      /**
       * Get the value of `readyState` from the media element. `readyState` indicates
       * the current state of the media element. It returns an enumeration from the
       * following list:
       * - 0: HAVE_NOTHING
       * - 1: HAVE_METADATA
       * - 2: HAVE_CURRENT_DATA
       * - 3: HAVE_FUTURE_DATA
       * - 4: HAVE_ENOUGH_DATA
       *
       * @method Html5#readyState
       * @return {number}
       *         The value of `readyState` from the media element. This will be a number
       *         from the list in the description.
       *
       * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}
       */
      "readyState",
      /**
       * Get the value of `videoWidth` from the video element. `videoWidth` indicates
       * the current width of the video in css pixels.
       *
       * @method Html5#videoWidth
       * @return {number}
       *         The value of `videoWidth` from the video element. This will be a number
       *         in css pixels.
       *
       * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
       */
      "videoWidth",
      /**
       * Get the value of `videoHeight` from the video element. `videoHeigth` indicates
       * the current height of the video in css pixels.
       *
       * @method Html5#videoHeight
       * @return {number}
       *         The value of `videoHeight` from the video element. This will be a number
       *         in css pixels.
       *
       * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
       */
      "videoHeight"
    ].forEach(function(prop) {
      Html5.prototype[prop] = function() {
        return this.el_[prop];
      };
    });
    [
      /**
       * Set the value of `volume` on the media element. `volume` indicates the current
       * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
       * so on.
       *
       * @method Html5#setVolume
       * @param {number} percentAsDecimal
       *        The volume percent as a decimal. Valid range is from 0-1.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
       */
      "volume",
      /**
       * Set the value of `src` on the media element. `src` indicates the current
       * {@link Tech~SourceObject} for the media.
       *
       * @method Html5#setSrc
       * @param {Tech~SourceObject} src
       *        The source object to set as the current source.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}
       */
      "src",
      /**
       * Set the value of `poster` on the media element. `poster` is the url to
       * an image file that can/will be shown when no media data is available.
       *
       * @method Html5#setPoster
       * @param {string} poster
       *        The url to an image that should be used as the `poster` for the media
       *        element.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}
       */
      "poster",
      /**
       * Set the value of `preload` on the media element. `preload` indicates
       * what should download before the media is interacted with. It can have the following
       * values:
       * - none: nothing should be downloaded
       * - metadata: poster and the first few frames of the media may be downloaded to get
       *   media dimensions and other metadata
       * - auto: allow the media and metadata for the media to be downloaded before
       *    interaction
       *
       * @method Html5#setPreload
       * @param {string} preload
       *         The value of `preload` to set on the media element. Must be 'none', 'metadata',
       *         or 'auto'.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
       */
      "preload",
      /**
       * Set the value of `playbackRate` on the media element. `playbackRate` indicates
       * the rate at which the media should play back. Examples:
       *   - if playbackRate is set to 2, media will play twice as fast.
       *   - if playbackRate is set to 0.5, media will play half as fast.
       *
       * @method Html5#setPlaybackRate
       * @return {number}
       *         The value of `playbackRate` from the media element. A number indicating
       *         the current playback speed of the media, where 1 is normal speed.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
       */
      "playbackRate",
      /**
       * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates
       * the rate at which the media should play back upon initial startup. Changing this value
       * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.
       *
       * Example Values:
       *   - if playbackRate is set to 2, media will play twice as fast.
       *   - if playbackRate is set to 0.5, media will play half as fast.
       *
       * @method Html5.prototype.setDefaultPlaybackRate
       * @return {number}
       *         The value of `defaultPlaybackRate` from the media element. A number indicating
       *         the current playback speed of the media, where 1 is normal speed.
       *
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}
       */
      "defaultPlaybackRate"
    ].forEach(function(prop) {
      Html5.prototype["set" + toTitleCase(prop)] = function(v) {
        this.el_[prop] = v;
      };
    });
    [
      /**
       * A wrapper around the media elements `pause` function. This will call the `HTML5`
       * media elements `pause` function.
       *
       * @method Html5#pause
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}
       */
      "pause",
      /**
       * A wrapper around the media elements `load` function. This will call the `HTML5`s
       * media element `load` function.
       *
       * @method Html5#load
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}
       */
      "load",
      /**
       * A wrapper around the media elements `play` function. This will call the `HTML5`s
       * media element `play` function.
       *
       * @method Html5#play
       * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}
       */
      "play"
    ].forEach(function(prop) {
      Html5.prototype[prop] = function() {
        return this.el_[prop]();
      };
    });
    Tech.withSourceHandlers(Html5);
    Html5.nativeSourceHandler = {};
    Html5.nativeSourceHandler.canPlayType = function(type) {
      try {
        return Html5.TEST_VID.canPlayType(type);
      } catch (e) {
        return "";
      }
    };
    Html5.nativeSourceHandler.canHandleSource = function(source, options) {
      if (source.type) {
        return Html5.nativeSourceHandler.canPlayType(source.type);
      } else if (source.src) {
        var ext = getFileExtension(source.src);
        return Html5.nativeSourceHandler.canPlayType("video/" + ext);
      }
      return "";
    };
    Html5.nativeSourceHandler.handleSource = function(source, tech, options) {
      tech.setSrc(source.src);
    };
    Html5.nativeSourceHandler.dispose = function() {
    };
    Html5.registerSourceHandler(Html5.nativeSourceHandler);
    Tech.registerTech("Html5", Html5);
    var _templateObject$1 = taggedTemplateLiteralLoose(["\n        Using the tech directly can be dangerous. I hope you know what you're doing.\n        See https://github.com/videojs/video.js/issues/2617 for more info.\n      "], ["\n        Using the tech directly can be dangerous. I hope you know what you're doing.\n        See https://github.com/videojs/video.js/issues/2617 for more info.\n      "]);
    var TECH_EVENTS_RETRIGGER = [
      /**
       * Fired while the user agent is downloading media data.
       *
       * @event Player#progress
       * @type {EventTarget~Event}
       */
      /**
       * Retrigger the `progress` event that was triggered by the {@link Tech}.
       *
       * @private
       * @method Player#handleTechProgress_
       * @fires Player#progress
       * @listens Tech#progress
       */
      "progress",
      /**
       * Fires when the loading of an audio/video is aborted.
       *
       * @event Player#abort
       * @type {EventTarget~Event}
       */
      /**
       * Retrigger the `abort` event that was triggered by the {@link Tech}.
       *
       * @private
       * @method Player#handleTechAbort_
       * @fires Player#abort
       * @listens Tech#abort
       */
      "abort",
      /**
       * Fires when the browser is intentionally not getting media data.
       *
       * @event Player#suspend
       * @type {EventTarget~Event}
       */
      /**
       * Retrigger the `suspend` event that was triggered by the {@link Tech}.
       *
       * @private
       * @method Player#handleTechSuspend_
       * @fires Player#suspend
       * @listens Tech#suspend
       */
      "suspend",
      /**
       * Fires when the current playlist is empty.
       *
       * @event Player#emptied
       * @type {EventTarget~Event}
       */
      /**
       * Retrigger the `emptied` event that was triggered by the {@link Tech}.
       *
       * @private
       * @method Player#handleTechEmptied_
       * @fires Player#emptied
       * @listens Tech#emptied
       */
      "emptied",
      /**
       * Fires when the browser is trying to get media data, but data is not available.
       *
       * @event Player#stalled
       * @type {EventTarget~Event}
       */
      /**
       * Retrigger the `stalled` event that was triggered by the {@link Tech}.
       *
       * @private
       * @method Player#handleTechStalled_
       * @fires Player#stalled
       * @listens Tech#stalled
       */
      "stalled",
      /**
       * Fires when the browser has loaded meta data for the audio/video.
       *
       * @event Player#loadedmetadata
       * @type {EventTarget~Event}
       */
      /**
       * Retrigger the `stalled` event that was triggered by the {@link Tech}.
       *
       * @private
       * @method Player#handleTechLoadedmetadata_
       * @fires Player#loadedmetadata
       * @listens Tech#loadedmetadata
       */
      "loadedmetadata",
      /**
       * Fires when the browser has loaded the current frame of the audio/video.
       *
       * @event Player#loadeddata
       * @type {event}
       */
      /**
       * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.
       *
       * @private
       * @method Player#handleTechLoaddeddata_
       * @fires Player#loadeddata
       * @listens Tech#loadeddata
       */
      "loadeddata",
      /**
       * Fires when the current playback position has changed.
       *
       * @event Player#timeupdate
       * @type {event}
       */
      /**
       * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.
       *
       * @private
       * @method Player#handleTechTimeUpdate_
       * @fires Player#timeupdate
       * @listens Tech#timeupdate
       */
      "timeupdate",
      /**
       * Fires when the video's intrinsic dimensions change
       *
       * @event Player#resize
       * @type {event}
       */
      /**
       * Retrigger the `resize` event that was triggered by the {@link Tech}.
       *
       * @private
       * @method Player#handleTechResize_
       * @fires Player#resize
       * @listens Tech#resize
       */
      "resize",
      /**
       * Fires when the volume has been changed
       *
       * @event Player#volumechange
       * @type {event}
       */
      /**
       * Retrigger the `volumechange` event that was triggered by the {@link Tech}.
       *
       * @private
       * @method Player#handleTechVolumechange_
       * @fires Player#volumechange
       * @listens Tech#volumechange
       */
      "volumechange",
      /**
       * Fires when the text track has been changed
       *
       * @event Player#texttrackchange
       * @type {event}
       */
      /**
       * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.
       *
       * @private
       * @method Player#handleTechTexttrackchange_
       * @fires Player#texttrackchange
       * @listens Tech#texttrackchange
       */
      "texttrackchange"
    ];
    var TECH_EVENTS_QUEUE = {
      canplay: "CanPlay",
      canplaythrough: "CanPlayThrough",
      playing: "Playing",
      seeked: "Seeked"
    };
    var BREAKPOINT_ORDER = ["tiny", "xsmall", "small", "medium", "large", "xlarge", "huge"];
    var BREAKPOINT_CLASSES = {};
    BREAKPOINT_ORDER.forEach(function(k) {
      var v = k.charAt(0) === "x" ? "x-" + k.substring(1) : k;
      BREAKPOINT_CLASSES[k] = "vjs-layout-" + v;
    });
    var DEFAULT_BREAKPOINTS = {
      tiny: 210,
      xsmall: 320,
      small: 425,
      medium: 768,
      large: 1440,
      xlarge: 2560,
      huge: Infinity
    };
    var Player = function(_Component) {
      inherits(Player2, _Component);
      function Player2(tag, options, ready) {
        classCallCheck(this, Player2);
        tag.id = tag.id || options.id || "vjs_video_" + newGUID();
        options = assign(Player2.getTagSettings(tag), options);
        options.initChildren = false;
        options.createEl = false;
        options.evented = false;
        options.reportTouchActivity = false;
        if (!options.language) {
          if (typeof tag.closest === "function") {
            var closest = tag.closest("[lang]");
            if (closest && closest.getAttribute) {
              options.language = closest.getAttribute("lang");
            }
          } else {
            var element = tag;
            while (element && element.nodeType === 1) {
              if (getAttributes(element).hasOwnProperty("lang")) {
                options.language = element.getAttribute("lang");
                break;
              }
              element = element.parentNode;
            }
          }
        }
        var _this = possibleConstructorReturn(this, _Component.call(this, null, options, ready));
        _this.log = createLogger(_this.id_);
        _this.isPosterFromTech_ = false;
        _this.queuedCallbacks_ = [];
        _this.isReady_ = false;
        _this.hasStarted_ = false;
        _this.userActive_ = false;
        if (!_this.options_ || !_this.options_.techOrder || !_this.options_.techOrder.length) {
          throw new Error("No techOrder specified. Did you overwrite videojs.options instead of just changing the properties you want to override?");
        }
        _this.tag = tag;
        _this.tagAttributes = tag && getAttributes(tag);
        _this.language(_this.options_.language);
        if (options.languages) {
          var languagesToLower = {};
          Object.getOwnPropertyNames(options.languages).forEach(function(name$$1) {
            languagesToLower[name$$1.toLowerCase()] = options.languages[name$$1];
          });
          _this.languages_ = languagesToLower;
        } else {
          _this.languages_ = Player2.prototype.options_.languages;
        }
        _this.cache_ = {};
        _this.poster_ = options.poster || "";
        _this.controls_ = !!options.controls;
        _this.cache_.lastVolume = 1;
        tag.controls = false;
        tag.removeAttribute("controls");
        if (tag.hasAttribute("autoplay")) {
          _this.options_.autoplay = true;
        } else {
          _this.autoplay(_this.options_.autoplay);
        }
        _this.scrubbing_ = false;
        _this.el_ = _this.createEl();
        _this.cache_.lastPlaybackRate = _this.defaultPlaybackRate();
        evented(_this, { eventBusKey: "el_" });
        var playerOptionsCopy = mergeOptions(_this.options_);
        if (options.plugins) {
          var plugins = options.plugins;
          Object.keys(plugins).forEach(function(name$$1) {
            if (typeof this[name$$1] === "function") {
              this[name$$1](plugins[name$$1]);
            } else {
              throw new Error('plugin "' + name$$1 + '" does not exist');
            }
          }, _this);
        }
        _this.options_.playerOptions = playerOptionsCopy;
        _this.middleware_ = [];
        _this.initChildren();
        _this.isAudio(tag.nodeName.toLowerCase() === "audio");
        if (_this.controls()) {
          _this.addClass("vjs-controls-enabled");
        } else {
          _this.addClass("vjs-controls-disabled");
        }
        _this.el_.setAttribute("role", "region");
        if (_this.isAudio()) {
          _this.el_.setAttribute("aria-label", _this.localize("Audio Player"));
        } else {
          _this.el_.setAttribute("aria-label", _this.localize("Video Player"));
        }
        if (_this.isAudio()) {
          _this.addClass("vjs-audio");
        }
        if (_this.flexNotSupported_()) {
          _this.addClass("vjs-no-flex");
        }
        if (!IS_IOS) {
          _this.addClass("vjs-workinghover");
        }
        Player2.players[_this.id_] = _this;
        var majorVersion = version.split(".")[0];
        _this.addClass("vjs-v" + majorVersion);
        _this.userActive(true);
        _this.reportUserActivity();
        _this.one("play", _this.listenForUserActivity_);
        _this.on("fullscreenchange", _this.handleFullscreenChange_);
        _this.on("stageclick", _this.handleStageClick_);
        _this.breakpoints(_this.options_.breakpoints);
        _this.responsive(_this.options_.responsive);
        _this.changingSrc_ = false;
        _this.playWaitingForReady_ = false;
        _this.playOnLoadstart_ = null;
        return _this;
      }
      Player2.prototype.dispose = function dispose() {
        this.trigger("dispose");
        this.off("dispose");
        if (this.styleEl_ && this.styleEl_.parentNode) {
          this.styleEl_.parentNode.removeChild(this.styleEl_);
          this.styleEl_ = null;
        }
        Player2.players[this.id_] = null;
        if (this.tag && this.tag.player) {
          this.tag.player = null;
        }
        if (this.el_ && this.el_.player) {
          this.el_.player = null;
        }
        if (this.tech_) {
          this.tech_.dispose();
          this.isPosterFromTech_ = false;
          this.poster_ = "";
        }
        if (this.playerElIngest_) {
          this.playerElIngest_ = null;
        }
        if (this.tag) {
          this.tag = null;
        }
        clearCacheForPlayer(this);
        _Component.prototype.dispose.call(this);
      };
      Player2.prototype.createEl = function createEl$$1() {
        var tag = this.tag;
        var el = void 0;
        var playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute("data-vjs-player");
        var divEmbed = this.tag.tagName.toLowerCase() === "video-js";
        if (playerElIngest) {
          el = this.el_ = tag.parentNode;
        } else if (!divEmbed) {
          el = this.el_ = _Component.prototype.createEl.call(this, "div");
        }
        var attrs = getAttributes(tag);
        if (divEmbed) {
          el = this.el_ = tag;
          tag = this.tag = document2.createElement("video");
          while (el.children.length) {
            tag.appendChild(el.firstChild);
          }
          if (!hasClass(el, "video-js")) {
            addClass(el, "video-js");
          }
          el.appendChild(tag);
          playerElIngest = this.playerElIngest_ = el;
          ["autoplay", "controls", "crossOrigin", "defaultMuted", "defaultPlaybackRate", "loop", "muted", "playbackRate", "src", "volume"].forEach(function(prop) {
            if (typeof el[prop] !== "undefined") {
              tag[prop] = el[prop];
            }
          });
        }
        tag.setAttribute("tabindex", "-1");
        attrs.tabindex = "-1";
        if (IE_VERSION) {
          tag.setAttribute("role", "application");
          attrs.role = "application";
        }
        tag.removeAttribute("width");
        tag.removeAttribute("height");
        if ("width" in attrs) {
          delete attrs.width;
        }
        if ("height" in attrs) {
          delete attrs.height;
        }
        Object.getOwnPropertyNames(attrs).forEach(function(attr) {
          if (attr === "class") {
            el.className += " " + attrs[attr];
            if (divEmbed) {
              tag.className += " " + attrs[attr];
            }
          } else {
            el.setAttribute(attr, attrs[attr]);
            if (divEmbed) {
              tag.setAttribute(attr, attrs[attr]);
            }
          }
        });
        tag.playerId = tag.id;
        tag.id += "_html5_api";
        tag.className = "vjs-tech";
        tag.player = el.player = this;
        this.addClass("vjs-paused");
        if (window2.VIDEOJS_NO_DYNAMIC_STYLE !== true) {
          this.styleEl_ = createStyleElement("vjs-styles-dimensions");
          var defaultsStyleEl = $(".vjs-styles-defaults");
          var head2 = $("head");
          head2.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head2.firstChild);
        }
        this.fill_ = false;
        this.fluid_ = false;
        this.width(this.options_.width);
        this.height(this.options_.height);
        this.fill(this.options_.fill);
        this.fluid(this.options_.fluid);
        this.aspectRatio(this.options_.aspectRatio);
        var links = tag.getElementsByTagName("a");
        for (var i2 = 0; i2 < links.length; i2++) {
          var linkEl = links.item(i2);
          addClass(linkEl, "vjs-hidden");
          linkEl.setAttribute("hidden", "hidden");
        }
        tag.initNetworkState_ = tag.networkState;
        if (tag.parentNode && !playerElIngest) {
          tag.parentNode.insertBefore(el, tag);
        }
        prependTo(tag, el);
        this.children_.unshift(tag);
        this.el_.setAttribute("lang", this.language_);
        this.el_ = el;
        return el;
      };
      Player2.prototype.width = function width(value) {
        return this.dimension("width", value);
      };
      Player2.prototype.height = function height(value) {
        return this.dimension("height", value);
      };
      Player2.prototype.dimension = function dimension(_dimension, value) {
        var privDimension = _dimension + "_";
        if (value === void 0) {
          return this[privDimension] || 0;
        }
        if (value === "") {
          this[privDimension] = void 0;
          this.updateStyleEl_();
          return;
        }
        var parsedVal = parseFloat(value);
        if (isNaN(parsedVal)) {
          log.error('Improper value "' + value + '" supplied for for ' + _dimension);
          return;
        }
        this[privDimension] = parsedVal;
        this.updateStyleEl_();
      };
      Player2.prototype.fluid = function fluid(bool) {
        if (bool === void 0) {
          return !!this.fluid_;
        }
        this.fluid_ = !!bool;
        if (bool) {
          this.addClass("vjs-fluid");
          this.fill(false);
        } else {
          this.removeClass("vjs-fluid");
        }
        this.updateStyleEl_();
      };
      Player2.prototype.fill = function fill(bool) {
        if (bool === void 0) {
          return !!this.fill_;
        }
        this.fill_ = !!bool;
        if (bool) {
          this.addClass("vjs-fill");
          this.fluid(false);
        } else {
          this.removeClass("vjs-fill");
        }
      };
      Player2.prototype.aspectRatio = function aspectRatio(ratio) {
        if (ratio === void 0) {
          return this.aspectRatio_;
        }
        if (!/^\d+\:\d+$/.test(ratio)) {
          throw new Error("Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.");
        }
        this.aspectRatio_ = ratio;
        this.fluid(true);
        this.updateStyleEl_();
      };
      Player2.prototype.updateStyleEl_ = function updateStyleEl_() {
        if (window2.VIDEOJS_NO_DYNAMIC_STYLE === true) {
          var _width = typeof this.width_ === "number" ? this.width_ : this.options_.width;
          var _height = typeof this.height_ === "number" ? this.height_ : this.options_.height;
          var techEl = this.tech_ && this.tech_.el();
          if (techEl) {
            if (_width >= 0) {
              techEl.width = _width;
            }
            if (_height >= 0) {
              techEl.height = _height;
            }
          }
          return;
        }
        var width = void 0;
        var height = void 0;
        var aspectRatio = void 0;
        var idClass = void 0;
        if (this.aspectRatio_ !== void 0 && this.aspectRatio_ !== "auto") {
          aspectRatio = this.aspectRatio_;
        } else if (this.videoWidth() > 0) {
          aspectRatio = this.videoWidth() + ":" + this.videoHeight();
        } else {
          aspectRatio = "16:9";
        }
        var ratioParts = aspectRatio.split(":");
        var ratioMultiplier = ratioParts[1] / ratioParts[0];
        if (this.width_ !== void 0) {
          width = this.width_;
        } else if (this.height_ !== void 0) {
          width = this.height_ / ratioMultiplier;
        } else {
          width = this.videoWidth() || 300;
        }
        if (this.height_ !== void 0) {
          height = this.height_;
        } else {
          height = width * ratioMultiplier;
        }
        if (/^[^a-zA-Z]/.test(this.id())) {
          idClass = "dimensions-" + this.id();
        } else {
          idClass = this.id() + "-dimensions";
        }
        this.addClass(idClass);
        setTextContent(this.styleEl_, "\n      ." + idClass + " {\n        width: " + width + "px;\n        height: " + height + "px;\n      }\n\n      ." + idClass + ".vjs-fluid {\n        padding-top: " + ratioMultiplier * 100 + "%;\n      }\n    ");
      };
      Player2.prototype.loadTech_ = function loadTech_(techName, source) {
        var _this2 = this;
        if (this.tech_) {
          this.unloadTech_();
        }
        var titleTechName = toTitleCase(techName);
        var camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);
        if (titleTechName !== "Html5" && this.tag) {
          Tech.getTech("Html5").disposeMediaElement(this.tag);
          this.tag.player = null;
          this.tag = null;
        }
        this.techName_ = titleTechName;
        this.isReady_ = false;
        var autoplay = typeof this.autoplay() === "string" ? false : this.autoplay();
        var techOptions = {
          source,
          autoplay,
          "nativeControlsForTouch": this.options_.nativeControlsForTouch,
          "playerId": this.id(),
          "techId": this.id() + "_" + camelTechName + "_api",
          "playsinline": this.options_.playsinline,
          "preload": this.options_.preload,
          "loop": this.options_.loop,
          "muted": this.options_.muted,
          "poster": this.poster(),
          "language": this.language(),
          "playerElIngest": this.playerElIngest_ || false,
          "vtt.js": this.options_["vtt.js"],
          "canOverridePoster": !!this.options_.techCanOverridePoster,
          "enableSourceset": this.options_.enableSourceset
        };
        ALL.names.forEach(function(name$$1) {
          var props = ALL[name$$1];
          techOptions[props.getterName] = _this2[props.privateName];
        });
        assign(techOptions, this.options_[titleTechName]);
        assign(techOptions, this.options_[camelTechName]);
        assign(techOptions, this.options_[techName.toLowerCase()]);
        if (this.tag) {
          techOptions.tag = this.tag;
        }
        if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {
          techOptions.startTime = this.cache_.currentTime;
        }
        var TechClass = Tech.getTech(techName);
        if (!TechClass) {
          throw new Error("No Tech named '" + titleTechName + "' exists! '" + titleTechName + "' should be registered using videojs.registerTech()'");
        }
        this.tech_ = new TechClass(techOptions);
        this.tech_.ready(bind(this, this.handleTechReady_), true);
        textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);
        TECH_EVENTS_RETRIGGER.forEach(function(event2) {
          _this2.on(_this2.tech_, event2, _this2["handleTech" + toTitleCase(event2) + "_"]);
        });
        Object.keys(TECH_EVENTS_QUEUE).forEach(function(event2) {
          _this2.on(_this2.tech_, event2, function(eventObj) {
            if (_this2.tech_.playbackRate() === 0 && _this2.tech_.seeking()) {
              _this2.queuedCallbacks_.push({
                callback: _this2["handleTech" + TECH_EVENTS_QUEUE[event2] + "_"].bind(_this2),
                event: eventObj
              });
              return;
            }
            _this2["handleTech" + TECH_EVENTS_QUEUE[event2] + "_"](eventObj);
          });
        });
        this.on(this.tech_, "loadstart", this.handleTechLoadStart_);
        this.on(this.tech_, "sourceset", this.handleTechSourceset_);
        this.on(this.tech_, "waiting", this.handleTechWaiting_);
        this.on(this.tech_, "ended", this.handleTechEnded_);
        this.on(this.tech_, "seeking", this.handleTechSeeking_);
        this.on(this.tech_, "play", this.handleTechPlay_);
        this.on(this.tech_, "firstplay", this.handleTechFirstPlay_);
        this.on(this.tech_, "pause", this.handleTechPause_);
        this.on(this.tech_, "durationchange", this.handleTechDurationChange_);
        this.on(this.tech_, "fullscreenchange", this.handleTechFullscreenChange_);
        this.on(this.tech_, "error", this.handleTechError_);
        this.on(this.tech_, "loadedmetadata", this.updateStyleEl_);
        this.on(this.tech_, "posterchange", this.handleTechPosterChange_);
        this.on(this.tech_, "textdata", this.handleTechTextData_);
        this.on(this.tech_, "ratechange", this.handleTechRateChange_);
        this.usingNativeControls(this.techGet_("controls"));
        if (this.controls() && !this.usingNativeControls()) {
          this.addTechControlsListeners_();
        }
        if (this.tech_.el().parentNode !== this.el() && (titleTechName !== "Html5" || !this.tag)) {
          prependTo(this.tech_.el(), this.el());
        }
        if (this.tag) {
          this.tag.player = null;
          this.tag = null;
        }
      };
      Player2.prototype.unloadTech_ = function unloadTech_() {
        var _this3 = this;
        ALL.names.forEach(function(name$$1) {
          var props = ALL[name$$1];
          _this3[props.privateName] = _this3[props.getterName]();
        });
        this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);
        this.isReady_ = false;
        this.tech_.dispose();
        this.tech_ = false;
        if (this.isPosterFromTech_) {
          this.poster_ = "";
          this.trigger("posterchange");
        }
        this.isPosterFromTech_ = false;
      };
      Player2.prototype.tech = function tech(safety) {
        if (safety === void 0) {
          log.warn(tsml(_templateObject$1));
        }
        return this.tech_;
      };
      Player2.prototype.addTechControlsListeners_ = function addTechControlsListeners_() {
        this.removeTechControlsListeners_();
        this.on(this.tech_, "mousedown", this.handleTechClick_);
        this.on(this.tech_, "touchstart", this.handleTechTouchStart_);
        this.on(this.tech_, "touchmove", this.handleTechTouchMove_);
        this.on(this.tech_, "touchend", this.handleTechTouchEnd_);
        this.on(this.tech_, "tap", this.handleTechTap_);
      };
      Player2.prototype.removeTechControlsListeners_ = function removeTechControlsListeners_() {
        this.off(this.tech_, "tap", this.handleTechTap_);
        this.off(this.tech_, "touchstart", this.handleTechTouchStart_);
        this.off(this.tech_, "touchmove", this.handleTechTouchMove_);
        this.off(this.tech_, "touchend", this.handleTechTouchEnd_);
        this.off(this.tech_, "mousedown", this.handleTechClick_);
      };
      Player2.prototype.handleTechReady_ = function handleTechReady_() {
        this.triggerReady();
        if (this.cache_.volume) {
          this.techCall_("setVolume", this.cache_.volume);
        }
        this.handleTechPosterChange_();
        this.handleTechDurationChange_();
        if ((this.src() || this.currentSrc()) && this.tag && this.options_.autoplay && this.paused()) {
          try {
            delete this.tag.poster;
          } catch (e) {
            log("deleting tag.poster throws in some browsers", e);
          }
        }
      };
      Player2.prototype.handleTechLoadStart_ = function handleTechLoadStart_() {
        this.removeClass("vjs-ended");
        this.removeClass("vjs-seeking");
        this.error(null);
        if (!this.paused()) {
          this.trigger("loadstart");
          this.trigger("firstplay");
        } else {
          this.hasStarted(false);
          this.trigger("loadstart");
        }
        this.manualAutoplay_(this.autoplay());
      };
      Player2.prototype.manualAutoplay_ = function manualAutoplay_(type) {
        var _this4 = this;
        if (!this.tech_ || typeof type !== "string") {
          return;
        }
        var muted = function muted2() {
          var previouslyMuted = _this4.muted();
          _this4.muted(true);
          var playPromise = _this4.play();
          if (!playPromise || !playPromise.then || !playPromise["catch"]) {
            return;
          }
          return playPromise["catch"](function(e) {
            _this4.muted(previouslyMuted);
          });
        };
        var promise = void 0;
        if (type === "any") {
          promise = this.play();
          if (promise && promise.then && promise["catch"]) {
            promise["catch"](function() {
              return muted();
            });
          }
        } else if (type === "muted") {
          promise = muted();
        } else {
          promise = this.play();
        }
        if (!promise || !promise.then || !promise["catch"]) {
          return;
        }
        return promise.then(function() {
          _this4.trigger({ type: "autoplay-success", autoplay: type });
        })["catch"](function(e) {
          _this4.trigger({ type: "autoplay-failure", autoplay: type });
        });
      };
      Player2.prototype.updateSourceCaches_ = function updateSourceCaches_() {
        var srcObj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        var src = srcObj;
        var type = "";
        if (typeof src !== "string") {
          src = srcObj.src;
          type = srcObj.type;
        }
        this.cache_.source = this.cache_.source || {};
        this.cache_.sources = this.cache_.sources || [];
        if (src && !type) {
          type = findMimetype(this, src);
        }
        this.cache_.source = mergeOptions({}, srcObj, { src, type });
        var matchingSources = this.cache_.sources.filter(function(s) {
          return s.src && s.src === src;
        });
        var sourceElSources = [];
        var sourceEls = this.$$("source");
        var matchingSourceEls = [];
        for (var i2 = 0; i2 < sourceEls.length; i2++) {
          var sourceObj = getAttributes(sourceEls[i2]);
          sourceElSources.push(sourceObj);
          if (sourceObj.src && sourceObj.src === src) {
            matchingSourceEls.push(sourceObj.src);
          }
        }
        if (matchingSourceEls.length && !matchingSources.length) {
          this.cache_.sources = sourceElSources;
        } else if (!matchingSources.length) {
          this.cache_.sources = [this.cache_.source];
        }
        this.cache_.src = src;
      };
      Player2.prototype.handleTechSourceset_ = function handleTechSourceset_(event2) {
        var _this5 = this;
        if (!this.changingSrc_) {
          var updateSourceCaches = function updateSourceCaches2(src) {
            return _this5.updateSourceCaches_(src);
          };
          var playerSrc = this.currentSource().src;
          var eventSrc = event2.src;
          if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) {
            if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) {
              updateSourceCaches = function updateSourceCaches2() {
              };
            }
          }
          updateSourceCaches(eventSrc);
          if (!event2.src) {
            var updateCache = function updateCache2(e) {
              if (e.type !== "sourceset") {
                var techSrc = _this5.techGet("currentSrc");
                _this5.lastSource_.tech = techSrc;
                _this5.updateSourceCaches_(techSrc);
              }
              _this5.tech_.off(["sourceset", "loadstart"], updateCache2);
            };
            this.tech_.one(["sourceset", "loadstart"], updateCache);
          }
        }
        this.lastSource_ = { player: this.currentSource().src, tech: event2.src };
        this.trigger({
          src: event2.src,
          type: "sourceset"
        });
      };
      Player2.prototype.hasStarted = function hasStarted(request) {
        if (request === void 0) {
          return this.hasStarted_;
        }
        if (request === this.hasStarted_) {
          return;
        }
        this.hasStarted_ = request;
        if (this.hasStarted_) {
          this.addClass("vjs-has-started");
          this.trigger("firstplay");
        } else {
          this.removeClass("vjs-has-started");
        }
      };
      Player2.prototype.handleTechPlay_ = function handleTechPlay_() {
        this.removeClass("vjs-ended");
        this.removeClass("vjs-paused");
        this.addClass("vjs-playing");
        this.hasStarted(true);
        this.trigger("play");
      };
      Player2.prototype.handleTechRateChange_ = function handleTechRateChange_() {
        if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {
          this.queuedCallbacks_.forEach(function(queued) {
            return queued.callback(queued.event);
          });
          this.queuedCallbacks_ = [];
        }
        this.cache_.lastPlaybackRate = this.tech_.playbackRate();
        this.trigger("ratechange");
      };
      Player2.prototype.handleTechWaiting_ = function handleTechWaiting_() {
        var _this6 = this;
        this.addClass("vjs-waiting");
        this.trigger("waiting");
        this.one("timeupdate", function() {
          return _this6.removeClass("vjs-waiting");
        });
      };
      Player2.prototype.handleTechCanPlay_ = function handleTechCanPlay_() {
        this.removeClass("vjs-waiting");
        this.trigger("canplay");
      };
      Player2.prototype.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {
        this.removeClass("vjs-waiting");
        this.trigger("canplaythrough");
      };
      Player2.prototype.handleTechPlaying_ = function handleTechPlaying_() {
        this.removeClass("vjs-waiting");
        this.trigger("playing");
      };
      Player2.prototype.handleTechSeeking_ = function handleTechSeeking_() {
        this.addClass("vjs-seeking");
        this.trigger("seeking");
      };
      Player2.prototype.handleTechSeeked_ = function handleTechSeeked_() {
        this.removeClass("vjs-seeking");
        this.trigger("seeked");
      };
      Player2.prototype.handleTechFirstPlay_ = function handleTechFirstPlay_() {
        if (this.options_.starttime) {
          log.warn("Passing the `starttime` option to the player will be deprecated in 6.0");
          this.currentTime(this.options_.starttime);
        }
        this.addClass("vjs-has-started");
        this.trigger("firstplay");
      };
      Player2.prototype.handleTechPause_ = function handleTechPause_() {
        this.removeClass("vjs-playing");
        this.addClass("vjs-paused");
        this.trigger("pause");
      };
      Player2.prototype.handleTechEnded_ = function handleTechEnded_() {
        this.addClass("vjs-ended");
        if (this.options_.loop) {
          this.currentTime(0);
          this.play();
        } else if (!this.paused()) {
          this.pause();
        }
        this.trigger("ended");
      };
      Player2.prototype.handleTechDurationChange_ = function handleTechDurationChange_() {
        this.duration(this.techGet_("duration"));
      };
      Player2.prototype.handleTechClick_ = function handleTechClick_(event2) {
        if (!isSingleLeftClick(event2)) {
          return;
        }
        if (!this.controls_) {
          return;
        }
        if (this.paused()) {
          silencePromise(this.play());
        } else {
          this.pause();
        }
      };
      Player2.prototype.handleTechTap_ = function handleTechTap_() {
        this.userActive(!this.userActive());
      };
      Player2.prototype.handleTechTouchStart_ = function handleTechTouchStart_() {
        this.userWasActive = this.userActive();
      };
      Player2.prototype.handleTechTouchMove_ = function handleTechTouchMove_() {
        if (this.userWasActive) {
          this.reportUserActivity();
        }
      };
      Player2.prototype.handleTechTouchEnd_ = function handleTechTouchEnd_(event2) {
        event2.preventDefault();
      };
      Player2.prototype.handleFullscreenChange_ = function handleFullscreenChange_() {
        if (this.isFullscreen()) {
          this.addClass("vjs-fullscreen");
        } else {
          this.removeClass("vjs-fullscreen");
        }
      };
      Player2.prototype.handleStageClick_ = function handleStageClick_() {
        this.reportUserActivity();
      };
      Player2.prototype.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event2, data) {
        if (data) {
          this.isFullscreen(data.isFullscreen);
        }
        this.trigger("fullscreenchange");
      };
      Player2.prototype.handleTechError_ = function handleTechError_() {
        var error = this.tech_.error();
        this.error(error);
      };
      Player2.prototype.handleTechTextData_ = function handleTechTextData_() {
        var data = null;
        if (arguments.length > 1) {
          data = arguments[1];
        }
        this.trigger("textdata", data);
      };
      Player2.prototype.getCache = function getCache() {
        return this.cache_;
      };
      Player2.prototype.techCall_ = function techCall_(method, arg) {
        this.ready(function() {
          if (method in allowedSetters) {
            return set$1(this.middleware_, this.tech_, method, arg);
          } else if (method in allowedMediators) {
            return mediate(this.middleware_, this.tech_, method, arg);
          }
          try {
            if (this.tech_) {
              this.tech_[method](arg);
            }
          } catch (e) {
            log(e);
            throw e;
          }
        }, true);
      };
      Player2.prototype.techGet_ = function techGet_(method) {
        if (!this.tech_ || !this.tech_.isReady_) {
          return;
        }
        if (method in allowedGetters) {
          return get$1(this.middleware_, this.tech_, method);
        } else if (method in allowedMediators) {
          return mediate(this.middleware_, this.tech_, method);
        }
        try {
          return this.tech_[method]();
        } catch (e) {
          if (this.tech_[method] === void 0) {
            log("Video.js: " + method + " method not defined for " + this.techName_ + " playback technology.", e);
            throw e;
          }
          if (e.name === "TypeError") {
            log("Video.js: " + method + " unavailable on " + this.techName_ + " playback technology element.", e);
            this.tech_.isReady_ = false;
            throw e;
          }
          log(e);
          throw e;
        }
      };
      Player2.prototype.play = function play() {
        var _this7 = this;
        var PromiseClass = this.options_.Promise || window2.Promise;
        if (PromiseClass) {
          return new PromiseClass(function(resolve) {
            _this7.play_(resolve);
          });
        }
        return this.play_();
      };
      Player2.prototype.play_ = function play_() {
        var _this8 = this;
        var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : silencePromise;
        if (this.playOnLoadstart_) {
          this.off("loadstart", this.playOnLoadstart_);
        }
        if (!this.isReady_) {
          if (this.playWaitingForReady_) {
            return;
          }
          this.playWaitingForReady_ = true;
          this.ready(function() {
            _this8.playWaitingForReady_ = false;
            callback(_this8.play());
          });
        } else if (!this.changingSrc_ && (this.src() || this.currentSrc())) {
          callback(this.techGet_("play"));
          return;
        } else {
          this.playOnLoadstart_ = function() {
            _this8.playOnLoadstart_ = null;
            callback(_this8.play());
          };
          this.one("loadstart", this.playOnLoadstart_);
        }
      };
      Player2.prototype.pause = function pause() {
        this.techCall_("pause");
      };
      Player2.prototype.paused = function paused() {
        return this.techGet_("paused") === false ? false : true;
      };
      Player2.prototype.played = function played() {
        return this.techGet_("played") || createTimeRanges(0, 0);
      };
      Player2.prototype.scrubbing = function scrubbing(isScrubbing) {
        if (typeof isScrubbing === "undefined") {
          return this.scrubbing_;
        }
        this.scrubbing_ = !!isScrubbing;
        if (isScrubbing) {
          this.addClass("vjs-scrubbing");
        } else {
          this.removeClass("vjs-scrubbing");
        }
      };
      Player2.prototype.currentTime = function currentTime(seconds) {
        if (typeof seconds !== "undefined") {
          if (seconds < 0) {
            seconds = 0;
          }
          this.techCall_("setCurrentTime", seconds);
          return;
        }
        this.cache_.currentTime = this.techGet_("currentTime") || 0;
        return this.cache_.currentTime;
      };
      Player2.prototype.duration = function duration(seconds) {
        if (seconds === void 0) {
          return this.cache_.duration !== void 0 ? this.cache_.duration : NaN;
        }
        seconds = parseFloat(seconds);
        if (seconds < 0) {
          seconds = Infinity;
        }
        if (seconds !== this.cache_.duration) {
          this.cache_.duration = seconds;
          if (seconds === Infinity) {
            this.addClass("vjs-live");
          } else {
            this.removeClass("vjs-live");
          }
          this.trigger("durationchange");
        }
      };
      Player2.prototype.remainingTime = function remainingTime() {
        return this.duration() - this.currentTime();
      };
      Player2.prototype.remainingTimeDisplay = function remainingTimeDisplay() {
        return Math.floor(this.duration()) - Math.floor(this.currentTime());
      };
      Player2.prototype.buffered = function buffered() {
        var buffered2 = this.techGet_("buffered");
        if (!buffered2 || !buffered2.length) {
          buffered2 = createTimeRanges(0, 0);
        }
        return buffered2;
      };
      Player2.prototype.bufferedPercent = function bufferedPercent$$1() {
        return bufferedPercent(this.buffered(), this.duration());
      };
      Player2.prototype.bufferedEnd = function bufferedEnd() {
        var buffered = this.buffered();
        var duration = this.duration();
        var end = buffered.end(buffered.length - 1);
        if (end > duration) {
          end = duration;
        }
        return end;
      };
      Player2.prototype.volume = function volume(percentAsDecimal) {
        var vol = void 0;
        if (percentAsDecimal !== void 0) {
          vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));
          this.cache_.volume = vol;
          this.techCall_("setVolume", vol);
          if (vol > 0) {
            this.lastVolume_(vol);
          }
          return;
        }
        vol = parseFloat(this.techGet_("volume"));
        return isNaN(vol) ? 1 : vol;
      };
      Player2.prototype.muted = function muted(_muted) {
        if (_muted !== void 0) {
          this.techCall_("setMuted", _muted);
          return;
        }
        return this.techGet_("muted") || false;
      };
      Player2.prototype.defaultMuted = function defaultMuted(_defaultMuted) {
        if (_defaultMuted !== void 0) {
          return this.techCall_("setDefaultMuted", _defaultMuted);
        }
        return this.techGet_("defaultMuted") || false;
      };
      Player2.prototype.lastVolume_ = function lastVolume_(percentAsDecimal) {
        if (percentAsDecimal !== void 0 && percentAsDecimal !== 0) {
          this.cache_.lastVolume = percentAsDecimal;
          return;
        }
        return this.cache_.lastVolume;
      };
      Player2.prototype.supportsFullScreen = function supportsFullScreen() {
        return this.techGet_("supportsFullScreen") || false;
      };
      Player2.prototype.isFullscreen = function isFullscreen(isFS) {
        if (isFS !== void 0) {
          this.isFullscreen_ = !!isFS;
          return;
        }
        return !!this.isFullscreen_;
      };
      Player2.prototype.requestFullscreen = function requestFullscreen() {
        var fsApi = FullscreenApi;
        this.isFullscreen(true);
        if (fsApi.requestFullscreen) {
          on(document2, fsApi.fullscreenchange, bind(this, function documentFullscreenChange(e) {
            this.isFullscreen(document2[fsApi.fullscreenElement]);
            if (this.isFullscreen() === false) {
              off(document2, fsApi.fullscreenchange, documentFullscreenChange);
            }
            this.trigger("fullscreenchange");
          }));
          this.el_[fsApi.requestFullscreen]();
        } else if (this.tech_.supportsFullScreen()) {
          this.techCall_("enterFullScreen");
        } else {
          this.enterFullWindow();
          this.trigger("fullscreenchange");
        }
      };
      Player2.prototype.exitFullscreen = function exitFullscreen() {
        var fsApi = FullscreenApi;
        this.isFullscreen(false);
        if (fsApi.requestFullscreen) {
          document2[fsApi.exitFullscreen]();
        } else if (this.tech_.supportsFullScreen()) {
          this.techCall_("exitFullScreen");
        } else {
          this.exitFullWindow();
          this.trigger("fullscreenchange");
        }
      };
      Player2.prototype.enterFullWindow = function enterFullWindow() {
        this.isFullWindow = true;
        this.docOrigOverflow = document2.documentElement.style.overflow;
        on(document2, "keydown", bind(this, this.fullWindowOnEscKey));
        document2.documentElement.style.overflow = "hidden";
        addClass(document2.body, "vjs-full-window");
        this.trigger("enterFullWindow");
      };
      Player2.prototype.fullWindowOnEscKey = function fullWindowOnEscKey(event2) {
        if (event2.keyCode === 27) {
          if (this.isFullscreen() === true) {
            this.exitFullscreen();
          } else {
            this.exitFullWindow();
          }
        }
      };
      Player2.prototype.exitFullWindow = function exitFullWindow() {
        this.isFullWindow = false;
        off(document2, "keydown", this.fullWindowOnEscKey);
        document2.documentElement.style.overflow = this.docOrigOverflow;
        removeClass(document2.body, "vjs-full-window");
        this.trigger("exitFullWindow");
      };
      Player2.prototype.canPlayType = function canPlayType2(type) {
        var can = void 0;
        for (var i2 = 0, j = this.options_.techOrder; i2 < j.length; i2++) {
          var techName = j[i2];
          var tech = Tech.getTech(techName);
          if (!tech) {
            tech = Component.getComponent(techName);
          }
          if (!tech) {
            log.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
            continue;
          }
          if (tech.isSupported()) {
            can = tech.canPlayType(type);
            if (can) {
              return can;
            }
          }
        }
        return "";
      };
      Player2.prototype.selectSource = function selectSource(sources) {
        var _this9 = this;
        var techs = this.options_.techOrder.map(function(techName) {
          return [techName, Tech.getTech(techName)];
        }).filter(function(_ref) {
          var techName = _ref[0], tech = _ref[1];
          if (tech) {
            return tech.isSupported();
          }
          log.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
          return false;
        });
        var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair2(outerArray, innerArray, tester) {
          var found = void 0;
          outerArray.some(function(outerChoice) {
            return innerArray.some(function(innerChoice) {
              found = tester(outerChoice, innerChoice);
              if (found) {
                return true;
              }
            });
          });
          return found;
        };
        var foundSourceAndTech = void 0;
        var flip = function flip2(fn) {
          return function(a, b) {
            return fn(b, a);
          };
        };
        var finder = function finder2(_ref2, source) {
          var techName = _ref2[0], tech = _ref2[1];
          if (tech.canPlaySource(source, _this9.options_[techName.toLowerCase()])) {
            return { source, tech: techName };
          }
        };
        if (this.options_.sourceOrder) {
          foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));
        } else {
          foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
        }
        return foundSourceAndTech || false;
      };
      Player2.prototype.src = function src(source) {
        var _this10 = this;
        if (typeof source === "undefined") {
          return this.cache_.src || "";
        }
        var sources = filterSource(source);
        if (!sources.length) {
          this.setTimeout(function() {
            this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });
          }, 0);
          return;
        }
        this.changingSrc_ = true;
        this.cache_.sources = sources;
        this.updateSourceCaches_(sources[0]);
        setSource(this, sources[0], function(middlewareSource, mws) {
          _this10.middleware_ = mws;
          _this10.cache_.sources = sources;
          _this10.updateSourceCaches_(middlewareSource);
          var err = _this10.src_(middlewareSource);
          if (err) {
            if (sources.length > 1) {
              return _this10.src(sources.slice(1));
            }
            _this10.changingSrc_ = false;
            _this10.setTimeout(function() {
              this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });
            }, 0);
            _this10.triggerReady();
            return;
          }
          setTech(mws, _this10.tech_);
        });
      };
      Player2.prototype.src_ = function src_(source) {
        var _this11 = this;
        var sourceTech = this.selectSource([source]);
        if (!sourceTech) {
          return true;
        }
        if (!titleCaseEquals(sourceTech.tech, this.techName_)) {
          this.changingSrc_ = true;
          this.loadTech_(sourceTech.tech, sourceTech.source);
          this.tech_.ready(function() {
            _this11.changingSrc_ = false;
          });
          return false;
        }
        this.ready(function() {
          if (this.tech_.constructor.prototype.hasOwnProperty("setSource")) {
            this.techCall_("setSource", source);
          } else {
            this.techCall_("src", source.src);
          }
          this.changingSrc_ = false;
        }, true);
        return false;
      };
      Player2.prototype.load = function load() {
        this.techCall_("load");
      };
      Player2.prototype.reset = function reset() {
        if (this.tech_) {
          this.tech_.clearTracks("text");
        }
        this.loadTech_(this.options_.techOrder[0], null);
        this.techCall_("reset");
      };
      Player2.prototype.currentSources = function currentSources() {
        var source = this.currentSource();
        var sources = [];
        if (Object.keys(source).length !== 0) {
          sources.push(source);
        }
        return this.cache_.sources || sources;
      };
      Player2.prototype.currentSource = function currentSource() {
        return this.cache_.source || {};
      };
      Player2.prototype.currentSrc = function currentSrc() {
        return this.currentSource() && this.currentSource().src || "";
      };
      Player2.prototype.currentType = function currentType() {
        return this.currentSource() && this.currentSource().type || "";
      };
      Player2.prototype.preload = function preload(value) {
        if (value !== void 0) {
          this.techCall_("setPreload", value);
          this.options_.preload = value;
          return;
        }
        return this.techGet_("preload");
      };
      Player2.prototype.autoplay = function autoplay(value) {
        if (value === void 0) {
          return this.options_.autoplay || false;
        }
        var techAutoplay = void 0;
        if (typeof value === "string" && /(any|play|muted)/.test(value)) {
          this.options_.autoplay = value;
          this.manualAutoplay_(value);
          techAutoplay = false;
        } else if (!value) {
          this.options_.autoplay = false;
        } else {
          this.options_.autoplay = true;
        }
        techAutoplay = techAutoplay || this.options_.autoplay;
        if (this.tech_) {
          this.techCall_("setAutoplay", techAutoplay);
        }
      };
      Player2.prototype.playsinline = function playsinline(value) {
        if (value !== void 0) {
          this.techCall_("setPlaysinline", value);
          this.options_.playsinline = value;
          return this;
        }
        return this.techGet_("playsinline");
      };
      Player2.prototype.loop = function loop(value) {
        if (value !== void 0) {
          this.techCall_("setLoop", value);
          this.options_.loop = value;
          return;
        }
        return this.techGet_("loop");
      };
      Player2.prototype.poster = function poster(src) {
        if (src === void 0) {
          return this.poster_;
        }
        if (!src) {
          src = "";
        }
        if (src === this.poster_) {
          return;
        }
        this.poster_ = src;
        this.techCall_("setPoster", src);
        this.isPosterFromTech_ = false;
        this.trigger("posterchange");
      };
      Player2.prototype.handleTechPosterChange_ = function handleTechPosterChange_() {
        if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
          var newPoster = this.tech_.poster() || "";
          if (newPoster !== this.poster_) {
            this.poster_ = newPoster;
            this.isPosterFromTech_ = true;
            this.trigger("posterchange");
          }
        }
      };
      Player2.prototype.controls = function controls(bool) {
        if (bool === void 0) {
          return !!this.controls_;
        }
        bool = !!bool;
        if (this.controls_ === bool) {
          return;
        }
        this.controls_ = bool;
        if (this.usingNativeControls()) {
          this.techCall_("setControls", bool);
        }
        if (this.controls_) {
          this.removeClass("vjs-controls-disabled");
          this.addClass("vjs-controls-enabled");
          this.trigger("controlsenabled");
          if (!this.usingNativeControls()) {
            this.addTechControlsListeners_();
          }
        } else {
          this.removeClass("vjs-controls-enabled");
          this.addClass("vjs-controls-disabled");
          this.trigger("controlsdisabled");
          if (!this.usingNativeControls()) {
            this.removeTechControlsListeners_();
          }
        }
      };
      Player2.prototype.usingNativeControls = function usingNativeControls(bool) {
        if (bool === void 0) {
          return !!this.usingNativeControls_;
        }
        bool = !!bool;
        if (this.usingNativeControls_ === bool) {
          return;
        }
        this.usingNativeControls_ = bool;
        if (this.usingNativeControls_) {
          this.addClass("vjs-using-native-controls");
          this.trigger("usingnativecontrols");
        } else {
          this.removeClass("vjs-using-native-controls");
          this.trigger("usingcustomcontrols");
        }
      };
      Player2.prototype.error = function error(err) {
        if (err === void 0) {
          return this.error_ || null;
        }
        if (err === null) {
          this.error_ = err;
          this.removeClass("vjs-error");
          if (this.errorDisplay) {
            this.errorDisplay.close();
          }
          return;
        }
        this.error_ = new MediaError(err);
        this.addClass("vjs-error");
        log.error("(CODE:" + this.error_.code + " " + MediaError.errorTypes[this.error_.code] + ")", this.error_.message, this.error_);
        this.trigger("error");
        return;
      };
      Player2.prototype.reportUserActivity = function reportUserActivity(event2) {
        this.userActivity_ = true;
      };
      Player2.prototype.userActive = function userActive(bool) {
        if (bool === void 0) {
          return this.userActive_;
        }
        bool = !!bool;
        if (bool === this.userActive_) {
          return;
        }
        this.userActive_ = bool;
        if (this.userActive_) {
          this.userActivity_ = true;
          this.removeClass("vjs-user-inactive");
          this.addClass("vjs-user-active");
          this.trigger("useractive");
          return;
        }
        if (this.tech_) {
          this.tech_.one("mousemove", function(e) {
            e.stopPropagation();
            e.preventDefault();
          });
        }
        this.userActivity_ = false;
        this.removeClass("vjs-user-active");
        this.addClass("vjs-user-inactive");
        this.trigger("userinactive");
      };
      Player2.prototype.listenForUserActivity_ = function listenForUserActivity_() {
        var mouseInProgress = void 0;
        var lastMoveX = void 0;
        var lastMoveY = void 0;
        var handleActivity = bind(this, this.reportUserActivity);
        var handleMouseMove = function handleMouseMove2(e) {
          if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
            lastMoveX = e.screenX;
            lastMoveY = e.screenY;
            handleActivity();
          }
        };
        var handleMouseDown = function handleMouseDown2() {
          handleActivity();
          this.clearInterval(mouseInProgress);
          mouseInProgress = this.setInterval(handleActivity, 250);
        };
        var handleMouseUp = function handleMouseUp2(event2) {
          handleActivity();
          this.clearInterval(mouseInProgress);
        };
        this.on("mousedown", handleMouseDown);
        this.on("mousemove", handleMouseMove);
        this.on("mouseup", handleMouseUp);
        this.on("keydown", handleActivity);
        this.on("keyup", handleActivity);
        var inactivityTimeout = void 0;
        this.setInterval(function() {
          if (!this.userActivity_) {
            return;
          }
          this.userActivity_ = false;
          this.userActive(true);
          this.clearTimeout(inactivityTimeout);
          var timeout = this.options_.inactivityTimeout;
          if (timeout <= 0) {
            return;
          }
          inactivityTimeout = this.setTimeout(function() {
            if (!this.userActivity_) {
              this.userActive(false);
            }
          }, timeout);
        }, 250);
      };
      Player2.prototype.playbackRate = function playbackRate(rate) {
        if (rate !== void 0) {
          this.techCall_("setPlaybackRate", rate);
          return;
        }
        if (this.tech_ && this.tech_.featuresPlaybackRate) {
          return this.cache_.lastPlaybackRate || this.techGet_("playbackRate");
        }
        return 1;
      };
      Player2.prototype.defaultPlaybackRate = function defaultPlaybackRate(rate) {
        if (rate !== void 0) {
          return this.techCall_("setDefaultPlaybackRate", rate);
        }
        if (this.tech_ && this.tech_.featuresPlaybackRate) {
          return this.techGet_("defaultPlaybackRate");
        }
        return 1;
      };
      Player2.prototype.isAudio = function isAudio(bool) {
        if (bool !== void 0) {
          this.isAudio_ = !!bool;
          return;
        }
        return !!this.isAudio_;
      };
      Player2.prototype.addTextTrack = function addTextTrack(kind, label, language) {
        if (this.tech_) {
          return this.tech_.addTextTrack(kind, label, language);
        }
      };
      Player2.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
        if (this.tech_) {
          return this.tech_.addRemoteTextTrack(options, manualCleanup);
        }
      };
      Player2.prototype.removeRemoteTextTrack = function removeRemoteTextTrack() {
        var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$track = _ref3.track, track2 = _ref3$track === void 0 ? arguments[0] : _ref3$track;
        if (this.tech_) {
          return this.tech_.removeRemoteTextTrack(track2);
        }
      };
      Player2.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
        return this.techGet_("getVideoPlaybackQuality");
      };
      Player2.prototype.videoWidth = function videoWidth() {
        return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
      };
      Player2.prototype.videoHeight = function videoHeight() {
        return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
      };
      Player2.prototype.language = function language(code) {
        if (code === void 0) {
          return this.language_;
        }
        this.language_ = String(code).toLowerCase();
      };
      Player2.prototype.languages = function languages() {
        return mergeOptions(Player2.prototype.options_.languages, this.languages_);
      };
      Player2.prototype.toJSON = function toJSON() {
        var options = mergeOptions(this.options_);
        var tracks = options.tracks;
        options.tracks = [];
        for (var i2 = 0; i2 < tracks.length; i2++) {
          var track2 = tracks[i2];
          track2 = mergeOptions(track2);
          track2.player = void 0;
          options.tracks[i2] = track2;
        }
        return options;
      };
      Player2.prototype.createModal = function createModal(content, options) {
        var _this12 = this;
        options = options || {};
        options.content = content || "";
        var modal = new ModalDialog(this, options);
        this.addChild(modal);
        modal.on("dispose", function() {
          _this12.removeChild(modal);
        });
        modal.open();
        return modal;
      };
      Player2.prototype.updateCurrentBreakpoint_ = function updateCurrentBreakpoint_() {
        if (!this.responsive()) {
          return;
        }
        var currentBreakpoint = this.currentBreakpoint();
        var currentWidth = this.currentWidth();
        for (var i2 = 0; i2 < BREAKPOINT_ORDER.length; i2++) {
          var candidateBreakpoint = BREAKPOINT_ORDER[i2];
          var maxWidth = this.breakpoints_[candidateBreakpoint];
          if (currentWidth <= maxWidth) {
            if (currentBreakpoint === candidateBreakpoint) {
              return;
            }
            if (currentBreakpoint) {
              this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]);
            }
            this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]);
            this.breakpoint_ = candidateBreakpoint;
            break;
          }
        }
      };
      Player2.prototype.removeCurrentBreakpoint_ = function removeCurrentBreakpoint_() {
        var className = this.currentBreakpointClass();
        this.breakpoint_ = "";
        if (className) {
          this.removeClass(className);
        }
      };
      Player2.prototype.breakpoints = function breakpoints(_breakpoints) {
        if (_breakpoints === void 0) {
          return assign(this.breakpoints_);
        }
        this.breakpoint_ = "";
        this.breakpoints_ = assign({}, DEFAULT_BREAKPOINTS, _breakpoints);
        this.updateCurrentBreakpoint_();
        return assign(this.breakpoints_);
      };
      Player2.prototype.responsive = function responsive(value) {
        if (value === void 0) {
          return this.responsive_;
        }
        value = Boolean(value);
        var current = this.responsive_;
        if (value === current) {
          return;
        }
        this.responsive_ = value;
        if (value) {
          this.on("playerresize", this.updateCurrentBreakpoint_);
          this.updateCurrentBreakpoint_();
        } else {
          this.off("playerresize", this.updateCurrentBreakpoint_);
          this.removeCurrentBreakpoint_();
        }
        return value;
      };
      Player2.prototype.currentBreakpoint = function currentBreakpoint() {
        return this.breakpoint_;
      };
      Player2.prototype.currentBreakpointClass = function currentBreakpointClass() {
        return BREAKPOINT_CLASSES[this.breakpoint_] || "";
      };
      Player2.getTagSettings = function getTagSettings(tag) {
        var baseOptions = {
          sources: [],
          tracks: []
        };
        var tagOptions = getAttributes(tag);
        var dataSetup = tagOptions["data-setup"];
        if (hasClass(tag, "vjs-fill")) {
          tagOptions.fill = true;
        }
        if (hasClass(tag, "vjs-fluid")) {
          tagOptions.fluid = true;
        }
        if (dataSetup !== null) {
          var _safeParseTuple = safeParseTuple(dataSetup || "{}"), err = _safeParseTuple[0], data = _safeParseTuple[1];
          if (err) {
            log.error(err);
          }
          assign(tagOptions, data);
        }
        assign(baseOptions, tagOptions);
        if (tag.hasChildNodes()) {
          var children = tag.childNodes;
          for (var i2 = 0, j = children.length; i2 < j; i2++) {
            var child = children[i2];
            var childName = child.nodeName.toLowerCase();
            if (childName === "source") {
              baseOptions.sources.push(getAttributes(child));
            } else if (childName === "track") {
              baseOptions.tracks.push(getAttributes(child));
            }
          }
        }
        return baseOptions;
      };
      Player2.prototype.flexNotSupported_ = function flexNotSupported_() {
        var elem = document2.createElement("i");
        return !("flexBasis" in elem.style || "webkitFlexBasis" in elem.style || "mozFlexBasis" in elem.style || "msFlexBasis" in elem.style || // IE10-specific (2012 flex spec)
        "msFlexOrder" in elem.style);
      };
      return Player2;
    }(Component);
    ALL.names.forEach(function(name$$1) {
      var props = ALL[name$$1];
      Player.prototype[props.getterName] = function() {
        if (this.tech_) {
          return this.tech_[props.getterName]();
        }
        this[props.privateName] = this[props.privateName] || new props.ListClass();
        return this[props.privateName];
      };
    });
    Player.players = {};
    var navigator2 = window2.navigator;
    Player.prototype.options_ = {
      // Default order of fallback technology
      techOrder: Tech.defaultTechOrder_,
      html5: {},
      flash: {},
      // default inactivity timeout
      inactivityTimeout: 2e3,
      // default playback rates
      playbackRates: [],
      // Add playback rate selection by adding rates
      // 'playbackRates': [0.5, 1, 1.5, 2],
      // Included control sets
      children: ["mediaLoader", "posterImage", "textTrackDisplay", "loadingSpinner", "bigPlayButton", "controlBar", "errorDisplay", "textTrackSettings"],
      language: navigator2 && (navigator2.languages && navigator2.languages[0] || navigator2.userLanguage || navigator2.language) || "en",
      // locales and their language translations
      languages: {},
      // Default message to show when a video cannot be played.
      notSupportedMessage: "No compatible source was found for this media.",
      breakpoints: {},
      responsive: false
    };
    if (!IS_IE8) {
      Player.prototype.options_.children.push("resizeManager");
    }
    [
      /**
       * Returns whether or not the player is in the "ended" state.
       *
       * @return {Boolean} True if the player is in the ended state, false if not.
       * @method Player#ended
       */
      "ended",
      /**
       * Returns whether or not the player is in the "seeking" state.
       *
       * @return {Boolean} True if the player is in the seeking state, false if not.
       * @method Player#seeking
       */
      "seeking",
      /**
       * Returns the TimeRanges of the media that are currently available
       * for seeking to.
       *
       * @return {TimeRanges} the seekable intervals of the media timeline
       * @method Player#seekable
       */
      "seekable",
      /**
       * Returns the current state of network activity for the element, from
       * the codes in the list below.
       * - NETWORK_EMPTY (numeric value 0)
       *   The element has not yet been initialised. All attributes are in
       *   their initial states.
       * - NETWORK_IDLE (numeric value 1)
       *   The element's resource selection algorithm is active and has
       *   selected a resource, but it is not actually using the network at
       *   this time.
       * - NETWORK_LOADING (numeric value 2)
       *   The user agent is actively trying to download data.
       * - NETWORK_NO_SOURCE (numeric value 3)
       *   The element's resource selection algorithm is active, but it has
       *   not yet found a resource to use.
       *
       * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
       * @return {number} the current network activity state
       * @method Player#networkState
       */
      "networkState",
      /**
       * Returns a value that expresses the current state of the element
       * with respect to rendering the current playback position, from the
       * codes in the list below.
       * - HAVE_NOTHING (numeric value 0)
       *   No information regarding the media resource is available.
       * - HAVE_METADATA (numeric value 1)
       *   Enough of the resource has been obtained that the duration of the
       *   resource is available.
       * - HAVE_CURRENT_DATA (numeric value 2)
       *   Data for the immediate current playback position is available.
       * - HAVE_FUTURE_DATA (numeric value 3)
       *   Data for the immediate current playback position is available, as
       *   well as enough data for the user agent to advance the current
       *   playback position in the direction of playback.
       * - HAVE_ENOUGH_DATA (numeric value 4)
       *   The user agent estimates that enough data is available for
       *   playback to proceed uninterrupted.
       *
       * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
       * @return {number} the current playback rendering state
       * @method Player#readyState
       */
      "readyState"
    ].forEach(function(fn) {
      Player.prototype[fn] = function() {
        return this.techGet_(fn);
      };
    });
    TECH_EVENTS_RETRIGGER.forEach(function(event2) {
      Player.prototype["handleTech" + toTitleCase(event2) + "_"] = function() {
        return this.trigger(event2);
      };
    });
    Component.registerComponent("Player", Player);
    var BASE_PLUGIN_NAME = "plugin";
    var PLUGIN_CACHE_KEY = "activePlugins_";
    var pluginStorage = {};
    var pluginExists = function pluginExists2(name) {
      return pluginStorage.hasOwnProperty(name);
    };
    var getPlugin = function getPlugin2(name) {
      return pluginExists(name) ? pluginStorage[name] : void 0;
    };
    var markPluginAsActive = function markPluginAsActive2(player, name) {
      player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};
      player[PLUGIN_CACHE_KEY][name] = true;
    };
    var triggerSetupEvent = function triggerSetupEvent2(player, hash, before) {
      var eventName = (before ? "before" : "") + "pluginsetup";
      player.trigger(eventName, hash);
      player.trigger(eventName + ":" + hash.name, hash);
    };
    var createBasicPlugin = function createBasicPlugin2(name, plugin) {
      var basicPluginWrapper = function basicPluginWrapper2() {
        triggerSetupEvent(this, { name, plugin, instance: null }, true);
        var instance = plugin.apply(this, arguments);
        markPluginAsActive(this, name);
        triggerSetupEvent(this, { name, plugin, instance });
        return instance;
      };
      Object.keys(plugin).forEach(function(prop) {
        basicPluginWrapper[prop] = plugin[prop];
      });
      return basicPluginWrapper;
    };
    var createPluginFactory = function createPluginFactory2(name, PluginSubClass) {
      PluginSubClass.prototype.name = name;
      return function() {
        triggerSetupEvent(this, { name, plugin: PluginSubClass, instance: null }, true);
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var instance = new (Function.prototype.bind.apply(PluginSubClass, [null].concat([this].concat(args))))();
        this[name] = function() {
          return instance;
        };
        triggerSetupEvent(this, instance.getEventHash());
        return instance;
      };
    };
    var Plugin = function() {
      function Plugin2(player) {
        classCallCheck(this, Plugin2);
        if (this.constructor === Plugin2) {
          throw new Error("Plugin must be sub-classed; not directly instantiated.");
        }
        this.player = player;
        evented(this);
        delete this.trigger;
        stateful(this, this.constructor.defaultState);
        markPluginAsActive(player, this.name);
        this.dispose = bind(this, this.dispose);
        player.on("dispose", this.dispose);
      }
      Plugin2.prototype.version = function version2() {
        return this.constructor.VERSION;
      };
      Plugin2.prototype.getEventHash = function getEventHash() {
        var hash = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        hash.name = this.name;
        hash.plugin = this.constructor;
        hash.instance = this;
        return hash;
      };
      Plugin2.prototype.trigger = function trigger$$1(event2) {
        var hash = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return trigger(this.eventBusEl_, event2, this.getEventHash(hash));
      };
      Plugin2.prototype.handleStateChanged = function handleStateChanged(e) {
      };
      Plugin2.prototype.dispose = function dispose() {
        var name = this.name, player = this.player;
        this.trigger("dispose");
        this.off();
        player.off("dispose", this.dispose);
        player[PLUGIN_CACHE_KEY][name] = false;
        this.player = this.state = null;
        player[name] = createPluginFactory(name, pluginStorage[name]);
      };
      Plugin2.isBasic = function isBasic(plugin) {
        var p = typeof plugin === "string" ? getPlugin(plugin) : plugin;
        return typeof p === "function" && !Plugin2.prototype.isPrototypeOf(p.prototype);
      };
      Plugin2.registerPlugin = function registerPlugin(name, plugin) {
        if (typeof name !== "string") {
          throw new Error('Illegal plugin name, "' + name + '", must be a string, was ' + (typeof name === "undefined" ? "undefined" : _typeof(name)) + ".");
        }
        if (pluginExists(name)) {
          log.warn('A plugin named "' + name + '" already exists. You may want to avoid re-registering plugins!');
        } else if (Player.prototype.hasOwnProperty(name)) {
          throw new Error('Illegal plugin name, "' + name + '", cannot share a name with an existing player method!');
        }
        if (typeof plugin !== "function") {
          throw new Error('Illegal plugin for "' + name + '", must be a function, was ' + (typeof plugin === "undefined" ? "undefined" : _typeof(plugin)) + ".");
        }
        pluginStorage[name] = plugin;
        if (name !== BASE_PLUGIN_NAME) {
          if (Plugin2.isBasic(plugin)) {
            Player.prototype[name] = createBasicPlugin(name, plugin);
          } else {
            Player.prototype[name] = createPluginFactory(name, plugin);
          }
        }
        return plugin;
      };
      Plugin2.deregisterPlugin = function deregisterPlugin(name) {
        if (name === BASE_PLUGIN_NAME) {
          throw new Error("Cannot de-register base plugin.");
        }
        if (pluginExists(name)) {
          delete pluginStorage[name];
          delete Player.prototype[name];
        }
      };
      Plugin2.getPlugins = function getPlugins() {
        var names = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Object.keys(pluginStorage);
        var result = void 0;
        names.forEach(function(name) {
          var plugin = getPlugin(name);
          if (plugin) {
            result = result || {};
            result[name] = plugin;
          }
        });
        return result;
      };
      Plugin2.getPluginVersion = function getPluginVersion(name) {
        var plugin = getPlugin(name);
        return plugin && plugin.VERSION || "";
      };
      return Plugin2;
    }();
    Plugin.getPlugin = getPlugin;
    Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;
    Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);
    Player.prototype.usingPlugin = function(name) {
      return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;
    };
    Player.prototype.hasPlugin = function(name) {
      return !!pluginExists(name);
    };
    var _inherits = function _inherits2(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass) {
        subClass.super_ = superClass;
      }
    };
    var extendFn = function extendFn2(superClass) {
      var subClassMethods = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var subClass = function subClass2() {
        superClass.apply(this, arguments);
      };
      var methods = {};
      if ((typeof subClassMethods === "undefined" ? "undefined" : _typeof(subClassMethods)) === "object") {
        if (subClassMethods.constructor !== Object.prototype.constructor) {
          subClass = subClassMethods.constructor;
        }
        methods = subClassMethods;
      } else if (typeof subClassMethods === "function") {
        subClass = subClassMethods;
      }
      _inherits(subClass, superClass);
      for (var name in methods) {
        if (methods.hasOwnProperty(name)) {
          subClass.prototype[name] = methods[name];
        }
      }
      return subClass;
    };
    if (typeof HTMLVideoElement === "undefined" && isReal()) {
      document2.createElement("video");
      document2.createElement("audio");
      document2.createElement("track");
      document2.createElement("video-js");
    }
    var normalizeId = function normalizeId2(id) {
      return id.indexOf("#") === 0 ? id.slice(1) : id;
    };
    function videojs2(id, options, ready) {
      var player = videojs2.getPlayer(id);
      if (player) {
        if (options) {
          log.warn('Player "' + id + '" is already initialised. Options will not be applied.');
        }
        if (ready) {
          player.ready(ready);
        }
        return player;
      }
      var el = typeof id === "string" ? $("#" + normalizeId(id)) : id;
      if (!isEl(el)) {
        throw new TypeError("The element or ID supplied is not valid. (videojs)");
      }
      if (!document2.body.contains(el)) {
        log.warn("The element supplied is not included in the DOM");
      }
      options = options || {};
      videojs2.hooks("beforesetup").forEach(function(hookFunction) {
        var opts = hookFunction(el, mergeOptions(options));
        if (!isObject(opts) || Array.isArray(opts)) {
          log.error("please return an object in beforesetup hooks");
          return;
        }
        options = mergeOptions(options, opts);
      });
      var PlayerComponent = Component.getComponent("Player");
      player = new PlayerComponent(el, options, ready);
      videojs2.hooks("setup").forEach(function(hookFunction) {
        return hookFunction(player);
      });
      return player;
    }
    videojs2.hooks_ = {};
    videojs2.hooks = function(type, fn) {
      videojs2.hooks_[type] = videojs2.hooks_[type] || [];
      if (fn) {
        videojs2.hooks_[type] = videojs2.hooks_[type].concat(fn);
      }
      return videojs2.hooks_[type];
    };
    videojs2.hook = function(type, fn) {
      videojs2.hooks(type, fn);
    };
    videojs2.hookOnce = function(type, fn) {
      videojs2.hooks(type, [].concat(fn).map(function(original) {
        var wrapper = function wrapper2() {
          videojs2.removeHook(type, wrapper2);
          return original.apply(void 0, arguments);
        };
        return wrapper;
      }));
    };
    videojs2.removeHook = function(type, fn) {
      var index = videojs2.hooks(type).indexOf(fn);
      if (index <= -1) {
        return false;
      }
      videojs2.hooks_[type] = videojs2.hooks_[type].slice();
      videojs2.hooks_[type].splice(index, 1);
      return true;
    };
    if (window2.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {
      style = $(".vjs-styles-defaults");
      if (!style) {
        style = createStyleElement("vjs-styles-defaults");
        head = $("head");
        if (head) {
          head.insertBefore(style, head.firstChild);
        }
        setTextContent(style, "\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid {\n        padding-top: 56.25%\n      }\n    ");
      }
    }
    var style;
    var head;
    autoSetupTimeout(1, videojs2);
    videojs2.VERSION = version;
    videojs2.options = Player.prototype.options_;
    videojs2.getPlayers = function() {
      return Player.players;
    };
    videojs2.getPlayer = function(id) {
      var players = Player.players;
      var tag = void 0;
      if (typeof id === "string") {
        var nId = normalizeId(id);
        var player = players[nId];
        if (player) {
          return player;
        }
        tag = $("#" + nId);
      } else {
        tag = id;
      }
      if (isEl(tag)) {
        var _tag = tag, _player = _tag.player, playerId = _tag.playerId;
        if (_player || players[playerId]) {
          return _player || players[playerId];
        }
      }
    };
    videojs2.getAllPlayers = function() {
      return (
        // Disposed players leave a key with a `null` value, so we need to make sure
        // we filter those out.
        Object.keys(Player.players).map(function(k) {
          return Player.players[k];
        }).filter(Boolean)
      );
    };
    videojs2.players = Player.players;
    videojs2.getComponent = Component.getComponent;
    videojs2.registerComponent = function(name$$1, comp) {
      if (Tech.isTech(comp)) {
        log.warn("The " + name$$1 + " tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)");
      }
      Component.registerComponent.call(Component, name$$1, comp);
    };
    videojs2.getTech = Tech.getTech;
    videojs2.registerTech = Tech.registerTech;
    videojs2.use = use;
    if (!IS_IE8 && Object.defineProperty) {
      Object.defineProperty(videojs2, "middleware", {
        value: {},
        writeable: false,
        enumerable: true
      });
      Object.defineProperty(videojs2.middleware, "TERMINATOR", {
        value: TERMINATOR,
        writeable: false,
        enumerable: true
      });
    } else {
      videojs2.middleware = { TERMINATOR };
    }
    videojs2.browser = browser;
    videojs2.TOUCH_ENABLED = TOUCH_ENABLED;
    videojs2.extend = extendFn;
    videojs2.mergeOptions = mergeOptions;
    videojs2.bind = bind;
    videojs2.registerPlugin = Plugin.registerPlugin;
    videojs2.deregisterPlugin = Plugin.deregisterPlugin;
    videojs2.plugin = function(name$$1, plugin) {
      log.warn("videojs.plugin() is deprecated; use videojs.registerPlugin() instead");
      return Plugin.registerPlugin(name$$1, plugin);
    };
    videojs2.getPlugins = Plugin.getPlugins;
    videojs2.getPlugin = Plugin.getPlugin;
    videojs2.getPluginVersion = Plugin.getPluginVersion;
    videojs2.addLanguage = function(code, data) {
      var _mergeOptions;
      code = ("" + code).toLowerCase();
      videojs2.options.languages = mergeOptions(videojs2.options.languages, (_mergeOptions = {}, _mergeOptions[code] = data, _mergeOptions));
      return videojs2.options.languages[code];
    };
    videojs2.log = log;
    videojs2.createLogger = createLogger;
    videojs2.createTimeRange = videojs2.createTimeRanges = createTimeRanges;
    videojs2.formatTime = formatTime;
    videojs2.setFormatTime = setFormatTime;
    videojs2.resetFormatTime = resetFormatTime;
    videojs2.parseUrl = parseUrl;
    videojs2.isCrossOrigin = isCrossOrigin;
    videojs2.EventTarget = EventTarget;
    videojs2.on = on;
    videojs2.one = one;
    videojs2.off = off;
    videojs2.trigger = trigger;
    videojs2.xhr = xhr;
    videojs2.TextTrack = TextTrack;
    videojs2.AudioTrack = AudioTrack;
    videojs2.VideoTrack = VideoTrack;
    ["isEl", "isTextNode", "createEl", "hasClass", "addClass", "removeClass", "toggleClass", "setAttributes", "getAttributes", "emptyEl", "appendContent", "insertContent"].forEach(function(k) {
      videojs2[k] = function() {
        log.warn("videojs." + k + "() is deprecated; use videojs.dom." + k + "() instead");
        return Dom[k].apply(null, arguments);
      };
    });
    videojs2.computedStyle = computedStyle;
    videojs2.dom = Dom;
    videojs2.url = Url;
    module.exports = videojs2;
  }
});

// node_modules/.pnpm/vue-video-player@5.0.2/node_modules/vue-video-player/src/index.js
var import_video = __toESM(require_video_cjs());
import videoPlayer from "/Users/bixiaoyu/2023/xiao-admin/node_modules/.pnpm/vue-video-player@5.0.2/node_modules/vue-video-player/src/player.vue";
var videojs = window.videojs || import_video.default;
var install = function(Vue, config) {
  if (config) {
    if (config.options) {
      videoPlayer.props.globalOptions.default = () => config.options;
    }
    if (config.events) {
      videoPlayer.props.globalEvents.default = () => config.events;
    }
  }
  Vue.component(videoPlayer.name, videoPlayer);
};
var VueVideoPlayer = { videojs, videoPlayer, install };
var src_default = VueVideoPlayer;
export {
  src_default as default,
  install,
  videoPlayer,
  videojs
};
/*! Bundled license information:

video.js/dist/video.cjs.js:
  (**
   * @license
   * Video.js 6.13.0 <http://videojs.com/>
   * Copyright Brightcove, Inc. <https://www.brightcove.com/>
   * Available under Apache License Version 2.0
   * <https://github.com/videojs/video.js/blob/master/LICENSE>
   *
   * Includes vtt.js <https://github.com/mozilla/vtt.js>
   * Available under Apache License Version 2.0
   * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>
   *)
*/
//# sourceMappingURL=vue-video-player_src.js.map
